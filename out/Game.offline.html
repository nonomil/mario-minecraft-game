<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>æˆ‘çš„ä¸–ç•Œï¼šå•è¯å¤§å†’é™© (å®ç®±å¢å¼ºç‰ˆ)</title>
    <style>
:root {
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --vvw: 100vw;
    --vvh: 100vh;
    --ui-scale: 1;
    --touch-btn-size: 64px;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overscroll-behavior: none;
    touch-action: none;
}

body {
    background-color: #1a1a1a;
    display: block;
    /* Prefer modern dynamic viewport units when available; JS still updates --vvw/--vvh for older quirks. */
    width: var(--vvw, 100vw);
    height: var(--vvh, 100vh);
    min-height: var(--vvh, 100vh);
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
    font-family: "Verdana", sans-serif;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
}

@supports (height: 100dvh) {
    body {
        width: var(--vvw, 100dvw);
        height: var(--vvh, 100dvh);
        min-height: var(--vvh, 100dvh);
    }
}

#game-container {
    position: relative;
    width: 100%;
    height: 100%;
    box-shadow: none;
    border: none;
    border-radius: 0;
    overflow: hidden;
    transform-origin: center center;
}

.screen-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.55);
    z-index: 180;
    pointer-events: auto;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
}

.screen-overlay.visible {
    display: flex;
}

.overlay-card {
    width: min(560px, 90vw);
    max-width: calc(100% - 32px);
    background: rgba(20,20,20,0.95);
    border: 3px solid rgba(255,255,255,0.4);
    border-radius: 16px;
    box-shadow: 0 0 50px rgba(0,0,0,0.9);
    padding: 18px 18px 16px 18px;
    text-align: center;
    color: #fff;
}

.overlay-title {
    font-size: clamp(22px, 4vw, 34px);
    font-weight: 900;
    margin-bottom: 10px;
    color: #FFD700;
    text-shadow: 2px 2px 0 #000;
}

.overlay-text {
    font-size: clamp(14px, 3vw, 20px);
    font-weight: 900;
    line-height: 1.6;
    margin-bottom: 14px;
    text-shadow: 2px 2px 0 #000;
}

.overlay-btn:disabled {
    opacity: 0.55;
    cursor: not-allowed;
}

.overlay-start {
    text-align: left;
}

.overlay-start .overlay-page {
    display: none;
}

.overlay-start .overlay-page.active {
    display: block;
}

.overlay-intro-title {
    font-size: clamp(20px, 4vw, 28px);
    font-weight: 900;
    margin-bottom: 6px;
}

.overlay-intro-sub {
    font-size: clamp(14px, 3vw, 18px);
    font-weight: 700;
    opacity: 0.95;
    line-height: 1.6;
}

.overlay-account {
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.06);
    margin-bottom: 12px;
}

.overlay-account-title {
    font-weight: 900;
    margin-bottom: 8px;
    color: #FFD700;
    text-shadow: 2px 2px 0 #000;
}

.overlay-account-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 10px;
}

.overlay-account-hint {
    font-size: 13px;
    opacity: 0.85;
    margin-bottom: 8px;
}

.overlay-input {
    flex: 1 1 160px;
    min-width: 140px;
    padding: 10px 12px;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.05);
    color: #fff;
    font-size: 15px;
}

.overlay-hints-title {
    font-weight: 900;
    margin-bottom: 6px;
    color: #FFD700;
    text-shadow: 2px 2px 0 #000;
}

.overlay-hints-text {
    font-size: clamp(13px, 3vw, 18px);
    line-height: 1.6;
}

.overlay-btn {
    width: 100%;
    height: clamp(44px, 6vh, 56px);
    border-radius: 12px;
    border: 3px solid rgba(255,255,255,0.8);
    background: #4CAF50;
    color: #fff;
    font-size: clamp(16px, 3vw, 22px);
    font-weight: 900;
    cursor: pointer;
}

.overlay-btn:active {
    transform: scale(0.98);
}

.overlay-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 12px;
}

#btn-overlay-score-revive {
    background: linear-gradient(135deg, #ffd700, #ffaa00);
    color: #333;
    border: none;
    padding: 12px 18px;
    border-radius: 10px;
    font-size: 17px;
    font-weight: 900;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 6px 15px rgba(255, 215, 0, 0.4);
}

#btn-overlay-score-revive:hover {
    transform: translateY(-2px);
}

#btn-overlay-score-revive:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    box-shadow: none;
}

 .learning-modal,
.word-match-screen {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.75);
    z-index: 190;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
 }

.learning-modal.visible,
.word-match-screen.visible {
    display: flex;
 }

.learning-modal-content,
.word-match-content {
    width: min(640px, 92vw);
    background: rgba(12, 12, 12, 0.95);
    border-radius: 20px;
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.85);
    border: 3px solid rgba(255, 255, 255, 0.35);
    padding: 24px;
    color: #fff;
    text-align: center;
 }

.learning-modal-header {
    font-size: clamp(22px, 3vw, 32px);
    font-weight: 900;
    margin-bottom: 12px;
    color: #FFD54F;
 }

.learning-modal-question {
    font-size: clamp(18px, 2.5vw, 26px);
    margin-bottom: 16px;
    min-height: 48px;
}

.challenge-fill {
    display: grid;
    gap: 8px;
    justify-items: center;
}

.challenge-fill-word {
    font-size: clamp(28px, 5vw, 44px);
    letter-spacing: 6px;
    font-weight: 900;
    color: #4FC3F7;
    text-shadow: 1px 1px 0 #000;
}

.challenge-fill-hint {
    font-size: 16px;
    opacity: 0.9;
}

.challenge-fill-zh {
    font-size: 18px;
    color: #FFE082;
}

.learning-modal-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-bottom: 14px;
}

.learning-modal-options button {
    padding: 10px 14px;
    border-radius: 12px;
    border: 2px solid rgba(255, 255, 255, 0.6);
    background: linear-gradient(180deg, #333, #111);
    color: #fff;
    font-size: 16px;
    font-weight: 800;
    cursor: pointer;
    transition: transform 0.2s ease, background 0.2s ease;
 }

.learning-modal-options button.correct {
    background: linear-gradient(180deg, #26a69a, #00796b);
    border-color: #26a69a;
 }

.learning-modal-options button.wrong {
    background: linear-gradient(180deg, #f44336, #c62828);
    border-color: #f44336;
 }

.learning-modal-options button:hover:not(.correct):not(.wrong) {
    transform: translateY(-2px);
    background: linear-gradient(180deg, #555, #222);
}

.learning-modal-options .letter-option {
    font-size: 26px;
    font-weight: 900;
    background: linear-gradient(135deg, #667eea, #764ba2);
}

.learning-modal-input {
    display: none;
    margin-bottom: 12px;
 }

.learning-modal-input.active {
    display: block;
 }

.learning-modal-input input {
    width: 100%;
    font-size: 20px;
    padding: 10px 14px;
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.06);
    color: #fff;
    text-align: center;
 }

.learning-modal-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
 }

.learning-modal-timer {
    font-size: 24px;
    font-weight: 900;
    color: #ffecb3;
    min-width: 48px;
 }

.game-btn-small {
    padding: 6px 14px;
    font-size: 14px;
}

.word-match-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
}

.match-timer {
    font-size: 28px;
    font-weight: 900;
    color: #ffd700;
}

.word-match-subtitle {
    font-size: 16px;
    color: #f0f0f0;
    margin-bottom: 10px;
}

.match-container {
    display: flex;
    gap: 40px;
    position: relative;
    min-height: 260px;
    align-items: flex-start;
    justify-content: center;
}

.match-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 150px;
}

.match-item {
    padding: 12px 10px;
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.07);
    cursor: pointer;
    font-weight: 700;
    transition: transform 0.2s ease, border-color 0.2s ease;
}

.match-item.selected {
    border-color: #ffd700;
    transform: scale(1.02);
}

.match-item.correct {
    background: #4caf50;
    border-color: #1b5e20;
    color: #fff;
}

.match-item.wrong {
    background: #f44336;
    border-color: #c62828;
    color: #fff;
}

.match-lines {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.match-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
    font-size: 18px;
}

.match-result {
    margin-top: 18px;
    padding: 16px;
    border-radius: 16px;
    border: 2px solid transparent;
    background: rgba(0, 0, 0, 0.4);
    font-weight: 700;
    display: none;
}

.match-result.visible {
    display: block;
}
canvas {
    background-color: #87CEEB;
    display: block;
    image-rendering: pixelated;
    width: 100%;
    height: 100%;
}

#ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: calc(100% / var(--ui-scale));
    height: calc(100% / var(--ui-scale));
    pointer-events: none;
    transform: scale(var(--ui-scale));
    transform-origin: top left;
}

.hud-top {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 8px;
    padding: clamp(8px, 2vh, 18px);
}

.hud-box {
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    border: 2px solid rgba(255,255,255,0.3);
    text-shadow: 1px 1px 0 #000;
}

.hud-box-clickable {
    cursor: pointer;
}

.hud-box-clickable:hover {
    border-color: #FFD700;
}

.hud-box-active {
    border-color: #4CAF50;
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
}

#hp {
    min-width: 140px;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 6px 10px;
}

.hp-row {
    display: flex;
    justify-content: center;
    gap: 2px;
    line-height: 1;
}

.hp-heart {
    font-size: 14px;
}

#level-info {
    color: #87CEEB;
}

#difficulty-info {
    color: #FFB74D;
}

#word-display {
    color: #FFD700;
    font-size: 24px;
    transition: transform 0.2s;
}

.inventory-bar {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    border-top: 3px solid #8B8B8B;
    border-left: 3px solid #8B8B8B;
    border-right: 3px solid #8B8B8B;
    border-radius: 6px 6px 0 0;
    display: flex;
    gap: 2px;
    padding: 4px 6px 0 6px;
    pointer-events: auto;
}

.inv-slot {
    width: 40px;
    height: 40px;
    background: #8B8B8B;
    border: 2px solid #373737;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    margin-bottom: 4px;
}

.inv-slot-button {
    cursor: pointer;
    padding: 0;
    font-family: inherit;
    color: #fff;
    background: #6D6D6D;
}

.inv-slot-button .inv-label {
    font-size: 9px;
    line-height: 1;
    color: #fff;
}

.inv-slot-button:active {
    transform: scale(0.95);
}

.inv-slot.selected {
    border: 3px solid #FFD700;
    box-shadow: 0 0 10px #FFD700;
}

.inv-icon {
    font-size: 20px;
    margin-bottom: 0;
    line-height: 1;
}

.inv-count {
    font-size: 10px;
    color: white;
    font-weight: bold;
    position: absolute;
    bottom: 0;
    right: 2px;
    text-shadow: 1px 1px 0 #000;
}

.btn-group {
    position: absolute;
    top: 60px;
    right: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: auto;
}

.game-btn {
    background: #4CAF50;
    color: white;
    border: 2px solid #fff;
    padding: 5px 10px;
    cursor: pointer;
    font-weight: bold;
    border-radius: 4px;
}

.game-btn:active {
    transform: scale(0.95);
}

#toast {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 32px;
    font-weight: bold;
    display: none;
    text-align: center;
    border: 4px solid #FFD700;
    z-index: 100;
}

#word-card {
    position: absolute;
    left: 50%;
    top: 45%;
    transform: translate(-50%, -50%);
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.15s ease;
    z-index: 120;
}

#word-card.visible {
    opacity: 1;
}

.word-card-inner {
    background: rgba(0,0,0,0.75);
    border: 4px solid rgba(255,255,255,0.6);
    border-radius: 16px;
    padding: 18px 24px;
    min-width: 340px;
    text-align: center;
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
}

.word-card-en {
    font-size: 54px;
    font-weight: 900;
    color: #FFD700;
    letter-spacing: 1px;
    text-shadow: 2px 2px 0 #000;
}

.word-card-zh {
    margin-top: 8px;
    font-size: 36px;
    font-weight: 900;
    color: #FFFFFF;
    text-shadow: 2px 2px 0 #000;
}

.word-card-image {
    width: 260px;
    height: 160px;
    object-fit: cover;
    border-radius: 10px;
    margin-top: 14px;
    border: 3px solid rgba(255,255,255,0.35);
    background: rgba(255,255,255,0.08);
}

/* ???? - ????????? */
/* ç‘™ï¸½æ‡œéºÑƒåŸ— - é´æˆ æ®‘æ¶“æ «æ™«ç»‰è¯²å§©é—å ¥î—“é?*/
#touch-controls {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    display: none;
    pointer-events: none;
    z-index: 110;
    touch-action: none;
}

#touch-controls.visible {
    display: block;
}

/* å®¸ï¸¿æ™¶éºÑƒåŸ—é–å“„ç…™ - çå¿“ç®·å®¸ï¸¿æ™¶æ¶“î…¢æ£¿ */
.touch-left {
    position: absolute;
    left: 20px;
    bottom: 20px;
    display: flex;
    flex-direction: row;
    gap: 15px;
    pointer-events: auto;
}

/* é™å……æ™¶éºÑƒåŸ—é–å“„ç…™ - çå¿“ç®·é™å……æ™¶æ¶“î…¢æ£¿ */
.touch-right {
    position: absolute;
    right: 20px;
    bottom: 20px;
    display: grid;
    grid-template-columns: repeat(2, var(--touch-btn-size));
    grid-template-rows: repeat(3, var(--touch-btn-size));
    gap: 12px;
    align-items: end;
    pointer-events: auto;
}

/* é—å©‡â‚¬å¿”æ§‘å¨´å‘¯æ«§é‘¹èŒ¶ç«Ÿå¦—å—˜å¯œé–½?- é´æˆ æ®‘æ¶“æ «æ™«ç»‰è¯²å§©é—å ¥î—“é?*/
.touch-btn {
    width: var(--touch-btn-size);
    height: var(--touch-btn-size);
    border-radius: 999px;
    border: 2px solid rgba(255,255,255,0.5);
    background: rgba(255,255,255,0.16);
    color: rgba(255, 255, 255, 0.9);
    font-size: 30px;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
}

.touch-btn:active {
    transform: scale(0.92);
}

.touch-spacer {
    width: var(--touch-btn-size);
    height: var(--touch-btn-size);
    display: block;
}

#settings-modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 200;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
}

#settings-modal.visible {
    display: flex;
}

.settings-panel {
    width: 520px;
    max-width: calc(100% - 30px);
    max-height: calc(var(--vvh, 100vh) - 30px);
    background: rgba(20,20,20,0.95);
    border: 3px solid rgba(255,255,255,0.4);
    border-radius: 14px;
    box-shadow: 0 0 40px rgba(0,0,0,0.85);
    padding: 16px 16px 12px 16px;
    color: #fff;
    pointer-events: auto;
    overflow-y: auto;
    overflow-x: hidden;
    overscroll-behavior: contain;
}

.settings-title {
    font-size: 22px;
    font-weight: 900;
    margin-bottom: 10px;
}

.settings-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 8px 0;
}

.settings-label {
    font-size: 16px;
    font-weight: 700;
}

.settings-hint {
    font-size: 14px;
    line-height: 1.5;
    opacity: 0.9;
}

.settings-range {
    width: 250px;
}

.settings-select {
    width: 250px;
    padding: 8px 10px;
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.35);
    background: rgba(0,0,0,0.35);
    color: #fff;
    font-size: 15px;
}

.settings-input {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.35);
    background: rgba(0,0,0,0.35);
    color: #fff;
    font-size: 15px;
}

#vocab-preview {
    font-size: 14px;
    color: #f0f0f0;
    text-align: right;
    line-height: 1.4;
}

.settings-row-keys {
    flex-direction: column;
    align-items: flex-start;
}

.settings-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 8px;
}

#armor-select-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 210;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
}

#armor-select-modal.visible {
    display: flex;
}

.armor-modal-content {
    width: min(420px, 90vw);
    background: rgba(10, 10, 10, 0.95);
    border-radius: 18px;
    border: 3px solid rgba(255, 215, 0, 0.5);
    padding: 18px;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.85);
    color: #fff;
    text-align: left;
}

.armor-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 22px;
    font-weight: 900;
    margin-bottom: 12px;
}

.armor-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 320px;
    overflow-y: auto;
}

.armor-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    cursor: pointer;
    transition: background 0.2s ease;
}

.armor-item:hover {
    background: rgba(255, 255, 255, 0.1);
}

.armor-item.equipped {
    border-color: #4CAF50;
}

.armor-icon {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    background: rgba(255, 255, 255, 0.2);
}

.armor-details {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 14px;
}

.armor-name {
    font-weight: 700;
}

.armor-defense {
    color: #4CAF50;
}

.armor-durability {
    color: #FFC107;
}

#inventory-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 210;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    box-sizing: border-box;
}

#inventory-modal.visible {
    display: flex;
}

.inventory-panel {
    width: min(520px, 92vw);
    background: rgba(12, 12, 12, 0.96);
    border-radius: 18px;
    border: 3px solid rgba(255, 255, 255, 0.25);
    padding: 18px;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.85);
    color: #fff;
}

.inventory-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 22px;
    font-weight: 900;
    margin-bottom: 12px;
    color: #FFD700;
}

.inventory-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.inventory-tab {
    flex: 1 1 0;
    padding: 8px 10px;
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.05);
    color: #fff;
    font-weight: 800;
    cursor: pointer;
}

.inventory-tab.active {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.2);
}

.inventory-content {
    display: grid;
    gap: 10px;
    max-height: 360px;
    overflow-y: auto;
}

.inventory-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    border: 2px solid rgba(255, 255, 255, 0.15);
}

.inventory-item-left {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
}

.inventory-item-icon {
    width: 30px;
    height: 30px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.2);
}

.inventory-empty {
    text-align: center;
    opacity: 0.8;
    padding: 16px 0;
}

.inventory-equipment {
    display: grid;
    gap: 8px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.04);
    border-radius: 12px;
    border: 2px dashed rgba(255, 255, 255, 0.2);
}

.settings-actions-top {
    position: sticky;
    top: 0;
    z-index: 2;
    background: rgba(20,20,20,0.95);
    padding: 6px 0 8px;
    margin: 4px 0 8px 0;
    border-bottom: 1px solid rgba(255,255,255,0.15);
}

.settings-row-progress {
    gap: 10px;
}

.settings-progress {
    font-weight: 900;
    color: #FFD700;
    margin-left: auto;
}

.game-btn-danger {
    background: #D32F2F;
}

.login-screen {
    position: fixed;
    inset: 0;
    background: rgba(8, 8, 16, 0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 220;
    padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
}

.login-screen.visible {
    display: flex;
}

.login-container {
    background: rgba(0, 0, 0, 0.9);
    border-radius: 18px;
    padding: 30px;
    text-align: center;
    width: min(420px, 90vw);
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.login-form .form-group {
    margin-bottom: 16px;
    text-align: left;
}

.login-form input {
    width: 100%;
    padding: 10px 12px;
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.05);
    color: #fff;
    font-size: 16px;
}

.account-list {
    margin-top: 16px;
    text-align: left;
}

.account-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: background 0.2s;
}

.account-item:hover {
    background: rgba(255, 255, 255, 0.1);
}

.account-avatar {
    font-size: 24px;
    margin-right: 12px;
}

.account-info {
    flex: 1;
}

.btn-delete-account {
    background: #D32F2F;
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 6px 12px;
    cursor: pointer;
}

.account-empty {
    padding: 12px;
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
}

.achievement-popup {
    position: fixed;
    top: 20px;
    right: -320px;
    background: linear-gradient(135deg, #ffd700, #ffa000);
    color: #222;
    padding: 12px 18px;
    border-radius: 10px;
    display: flex;
    gap: 12px;
    align-items: center;
    z-index: 3100;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
    transition: right 0.4s ease;
}

.achievement-popup.show {
    right: 20px;
}

.achievement-icon {
    font-size: 24px;
}

.profile-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 220;
}

.profile-modal.visible {
    display: flex;
}

.profile-modal-content {
    background: rgba(15, 15, 15, 0.95);
    border-radius: 20px;
    padding: 24px;
    width: min(460px, 90vw);
    border: 2px solid rgba(255, 215, 0, 0.6);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

.profile-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.profile-stats {
    display: grid;
    gap: 8px;
    margin-bottom: 16px;
}

.profile-achievements {
    margin-top: 12px;
}

.profile-achievements h3 {
    margin-bottom: 10px;
}

.achievement-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border-radius: 10px;
    margin-bottom: 6px;
    background: rgba(255, 255, 255, 0.05);
}

.achievement-item.unlocked {
    background: rgba(76, 175, 80, 0.2);
}

.achievement-content {
    flex: 1;
}

/* ==================== v1.6.4 å•è¯æœ¬æ ·å¼ ==================== */
.vocab-book {
    max-height: 70vh;
    overflow-y: auto;
}

.vocab-book-list {
    margin: 20px 0;
}

.vocab-book-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    font-size: 14px;
    transition: background 0.2s;
}

.vocab-book-item:hover {
    background: rgba(255,255,255,0.05);
}

.vocab-status {
    font-weight: bold;
    min-width: 20px;
    text-align: center;
}

.vocab-word {
    font-weight: bold;
    min-width: 100px;
    font-family: 'Courier New', monospace;
}

.vocab-zh {
    color: #ccc;
    min-width: 80px;
}

.vocab-rate {
    font-weight: bold;
    min-width: 40px;
    text-align: right;
}

.vocab-count {
    min-width: 80px;
    text-align: right;
    font-size: 12px;
    color: #888;
}


</style>
</head>
<body>

<div id="login-screen" class="login-screen visible">
    <div class="login-container">
        <h1 class="game-title">Minecraft å•è¯æ¸¸æˆ</h1>
        <div id="login-form" class="login-form">
            <div class="form-group">
                <label for="username-input">è¯·è¾“å…¥ç”¨æˆ·å</label>
                <input type="text" id="username-input" placeholder="æ˜µç§°" maxlength="20">
            </div>
            <button id="btn-login" class="game-btn">è¿æ¥</button>
        </div>
        <div id="account-list" class="account-list">
            <h3>å·²æœ‰è´¦å·</h3>
            <div id="accounts-container"></div>
            <button id="btn-new-account" class="game-btn game-btn-small">åˆ›å»ºæ–°è´¦å·</button>
        </div>
    </div>
</div>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
        <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-box">ğŸª™ é‡‘å¸: <span id="score">0</span></div>
            <div class="hud-box" id="hp"></div>
            <div class="hud-box" id="word-display">Start!</div>
            <div class="hud-box" id="level-info">ğŸŒ² æ£®æ—</div>
            <div class="hud-box" id="weapon-info">âš”ï¸ çŸ³å‰‘</div>
            <div class="hud-box hud-box-clickable" id="armor-status">ğŸ›¡ï¸ æ— </div>
            <div class="hud-box hud-box-clickable" id="inventory-status">ğŸ’ èƒŒåŒ…</div>
        </div>
        
        <div class="btn-group">
            <button class="game-btn" id="btn-settings">âš™ï¸ è®¾ç½®</button>
            <button class="game-btn" id="btn-profile">ğŸ“‹ æ¡£æ¡ˆ</button>
            <button class="game-btn" id="btn-repeat-pause">ğŸ”Š é‡è¯»/æš‚åœ</button>
        </div>

        <div class="inventory-bar">
            <button class="inv-slot inv-slot-button" id="btn-summon-golem" title="å¬å”¤å‚€å„¡ (X)">
                <span class="inv-icon">ğŸ—¿</span>
                <span class="inv-label">å¬å”¤</span>
            </button>
            <div class="inv-slot" title="é’»çŸ³"><span class="inv-icon">ğŸ’</span><span class="inv-count" id="count-diamond">0</span></div>
            <div class="inv-slot" title="å—ç“œ"><span class="inv-icon">ğŸƒ</span><span class="inv-count" id="count-pumpkin">0</span></div>
            <div class="inv-slot" title="é“å—"><span class="inv-icon">ğŸ§±</span><span class="inv-count" id="count-iron">0</span></div>
            <div class="inv-slot" title="æœ¨æ£"><span class="inv-icon">ğŸ¥¢</span><span class="inv-count" id="count-stick">0</span></div>
            <div class="inv-slot" title="çŸ³å‰‘"><span class="inv-icon">âš”ï¸</span><span class="inv-count" id="count-stone_sword">0</span></div>
            <div class="inv-slot" title="é“é•"><span class="inv-icon">â›ï¸</span><span class="inv-count" id="count-iron_pickaxe">0</span></div>
            <div class="inv-slot" title="å¼“"><span class="inv-icon">ğŸ¹</span><span class="inv-count" id="count-bow">0</span></div>
            <div class="inv-slot" title="ç®­çŸ¢"><span class="inv-icon">ğŸ¹</span><span class="inv-count" id="count-arrow">0</span></div>
        </div>

        <div id="toast">Level Up!</div>
        <div id="word-card" aria-hidden="true">
            <div class="word-card-inner">
                <div class="word-card-en" id="word-card-en"></div>
                <div class="word-card-zh" id="word-card-zh"></div>
                <div id="word-card-phrase" style="display:none;font-size:12px;color:#FFD54F;margin-top:4px;font-style:italic;"></div>
                <img class="word-card-image" id="word-card-image" alt="" style="display:none;">
            </div>
        </div>

        <div id="touch-controls" aria-hidden="true">
            <div class="touch-left">
                <button class="touch-btn" data-action="left">â¬…ï¸</button>
                <button class="touch-btn" data-action="right">â¡ï¸</button>
            </div>
            <div class="touch-right">
                <button class="touch-btn" data-action="use-diamond">ğŸ’</button>
                <button class="touch-btn" data-action="interact">ğŸ§°</button>
                <button class="touch-btn" data-action="switch">ğŸ”</button>
                <span class="touch-spacer"></span>
                <button class="touch-btn" data-action="jump">â¤´ï¸</button>
                <button class="touch-btn" data-action="attack">ğŸ—¡ï¸</button>
            </div>
        </div>
    </div>
</div>

<div id="screen-overlay" class="screen-overlay" aria-hidden="true">
    <div class="overlay-card">
        <div class="overlay-title" id="overlay-title">å‡†å¤‡å¼€å§‹</div>
                        <div class="overlay-text" id="overlay-text">
            â¬…ï¸â¡ï¸ ç§»åŠ¨  â¬†ï¸ è·³(å¯äºŒæ®µè·³)<br>
            âš”ï¸ æ”»å‡»  ğŸ”„ åˆ‡æ¢æ­¦å™¨  ğŸ’ ä½¿ç”¨é’»çŸ³<br>
            ğŸ“¦ æ‰“å¼€å®ç®±  â›ï¸ é‡‡é›†
        </div>
        <div class="overlay-buttons">
            <button class="overlay-btn" id="btn-overlay-action">å¼€å§‹æ¸¸æˆ</button>
            <button class="overlay-btn overlay-score" id="btn-overlay-score-revive" style="display:none;">ç§¯åˆ†å¤æ´»</button>
        </div>
    </div>
</div>

<div id="settings-modal" aria-hidden="true">
    <div class="settings-panel" role="dialog" aria-modal="true" aria-label="æ¸¸æˆè®¾ç½®">
        <div class="settings-title">æ¸¸æˆè®¾ç½®</div>

        <div class="settings-actions settings-actions-top">
            <button class="game-btn" id="btn-settings-save">ä¿å­˜</button>
        </div>

        <div class="settings-row settings-row-keys">
            <div class="settings-label">æ“ä½œæç¤º</div>
                                    <div class="settings-hint">
                â¬…ï¸â¡ï¸ ç§»åŠ¨  â¬†ï¸ è·³(å¯äºŒæ®µè·³)<br>
            âš”ï¸ æ”»å‡»  ğŸ”„ åˆ‡æ¢æ­¦å™¨  ğŸ’ ä½¿ç”¨é’»çŸ³<br>
            ğŸ“¦ æ‰“å¼€å®ç®±  â›ï¸ é‡‡é›†
            </div>
        </div>


        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-learning-mode"> å­¦ä¹ æ¨¡å¼(æ›´å°‘å¹²æ‰°)</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-challenge-mode"> å­¦ä¹ æŒ‘æˆ˜(éšæœºå¼¹å‡º)</label>
        </div>
        <div class="settings-row">
            <div class="settings-label">æŒ‘æˆ˜é¢‘ç‡</div>
            <select class="settings-select" id="opt-challenge-frequency">
                <option value="0.15">å¾ˆå°‘</option>
                <option value="0.3">é€‚ä¸­</option>
                <option value="0.5">é¢‘ç¹</option>
            </select>
        </div>
        <div class="settings-row">
            <div class="settings-label">è¯å¡æ˜¾ç¤ºæ—¶é•¿</div>
            <select class="settings-select" id="opt-word-card-duration">
                <option value="600">çŸ­ (0.6ç§’)</option>
                <option value="900">ä¸­ (0.9ç§’)</option>
                <option value="2000">é•¿ (2ç§’)</option>
                <option value="3000">å¾ˆé•¿ (3ç§’)</option>
            </select>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-speech"> æœ—è¯»å•è¯</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-speech-zh-enabled"> æœ—è¯»ä¸­æ–‡é‡Šä¹‰</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-bgm"> èƒŒæ™¯éŸ³ä¹</label>
        </div>
        <div class="settings-row">
            <div class="settings-label">è‹±æ–‡è¯­é€Ÿ</div>
            <input class="settings-range" id="opt-speech-en" type="range" min="0.5" max="1.2" step="0.05">
        </div>
        <div class="settings-row">
            <div class="settings-label">ä¸­æ–‡è¯­é€Ÿ</div>
            <input class="settings-range" id="opt-speech-zh" type="range" min="0.5" max="1.2" step="0.05">
        </div>
        <div class="settings-row">
            <div class="settings-label">ç•Œé¢å¤§å°</div>
            <input class="settings-range" id="opt-ui-scale" type="range" min="0.8" max="1.4" step="0.05">
        </div>
        <div class="settings-row">
            <div class="settings-label">æ˜¾ç¤ºæ¨¡å¼</div>
            <select class="settings-select" id="opt-device-mode">
                <option value="auto">è‡ªåŠ¨</option>
                <option value="phone">æ‰‹æœº</option>
                <option value="tablet">å¹³æ¿</option>
            </select>
        </div>
        <div class="settings-row">
            <div class="settings-label">å±å¹•æ–¹å‘</div>
            <select class="settings-select" id="opt-orientation-lock">
                <option value="auto">è‡ªåŠ¨</option>
                <option value="portrait">ç«–å±</option>
                <option value="landscape">æ¨ªå±</option>
            </select>
        </div>
        <div class="settings-row">
            <div class="settings-label">åŠ¨ä½œé€Ÿåº¦</div>
            <input class="settings-range" id="opt-motion-scale" type="range" min="0.8" max="1.8" step="0.05">
        </div>
        <div class="settings-row">
            <div class="settings-label">ç§»åŠ¨é€Ÿåº¦</div>
            <select class="settings-select" id="opt-speed">
                <option value="slow">æ…¢ï¼ˆç»ƒä¹ ï¼‰</option>
                <option value="normal">æ™®é€š</option>
                <option value="fast">å¿«ï¼ˆæŒ‘æˆ˜ï¼‰</option>
            </select>
        </div>
        <div class="settings-row">
            <div class="settings-label">æ¸¸æˆéš¾åº¦</div>
            <select class="settings-select" id="opt-difficulty">
                <option value="auto">è‡ªåŠ¨(éšç§¯åˆ†)</option>
                <option value="æ–°æ‰‹">æ–°æ‰‹</option>
                <option value="ç®€å•">ç®€å•</option>
                <option value="æ™®é€š">æ™®é€š</option>
                <option value="å›°éš¾">å›°éš¾</option>
                <option value="åœ°ç‹±">åœ°ç‹±</option>
            </select>
        </div>
        <div class="settings-row">
            <div class="settings-label">ç¯å¢ƒåˆ‡æ¢å‘¨æœŸ(åˆ†æ•°)</div>
            <input class="settings-range" id="opt-biome-step" type="range" min="50" max="1000" step="50">
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-touch"> å±å¹•æŒ‰é”®</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-no-repeat"> å•è¯ä¸é‡å¤(è½®æ¢)</label>
        </div>

        <div class="settings-row">
            <div class="settings-label">è¯åº“</div>
            <select class="settings-select" id="opt-vocab"></select>
        </div>
        <div class="settings-row">
            <div class="settings-label">è¯åº“é¢„è§ˆ</div>
            <div id="vocab-preview" class="settings-hint">è‡ªåŠ¨è½®æ¢è¯åº“</div>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-show-image"> æ˜¾ç¤ºå›¾ç‰‡</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-word-gate"> è¯è¯­é—¸é—¨(è§¦å‘é¢å¤–æŒ‘æˆ˜)</label>
        </div>
        <div class="settings-row">
            <label class="settings-label"><input type="checkbox" id="opt-word-match"> è¯è¯­åŒ¹é…å¤æ´»(ç»“æŸæ—¶)</label>
        </div>

        <div class="settings-row settings-row-keys">
            <div class="settings-label">æŒ‰é”®(é€—å·åˆ†éš”): è·³è·ƒ,æ”»å‡»,äº¤äº’,åˆ‡æ¢,ä½¿ç”¨é’»çŸ³</div>
            <input class="settings-input" id="opt-keys" type="text" value="Space,KeyJ,KeyY,KeyK,KeyZ">
        </div>

        <div class="settings-row settings-row-progress">
            <div class="settings-label">è¯åº“è½®æ¢</div>
            <div class="settings-progress" id="progress-vocab">æœªåŠ è½½</div>
            <button class="game-btn game-btn-danger" id="btn-reset-progress">é‡ç½®è½®æ¢</button>
        </div>

        <div class="settings-actions">
            <button class="game-btn" id="btn-settings-close">å…³é—­</button>
        </div>
    </div>
</div>
<div id="armor-select-modal" class="armor-modal" aria-hidden="true">
    <div class="armor-modal-content">
        <div class="armor-modal-header">
            <span>ç›”ç”²ä»“åº“</span>
            <button class="game-btn game-btn-small" id="btn-armor-close">å…³é—­</button>
        </div>
        <div class="armor-list"></div>
    </div>
</div>

<div id="inventory-modal" class="inventory-modal" aria-hidden="true">
    <div class="inventory-panel">
        <div class="inventory-header">
            <span>ğŸ’ èƒŒåŒ…</span>
            <button class="game-btn game-btn-small" id="btn-inventory-close">å…³é—­</button>
        </div>
        <div class="inventory-tabs">
            <button class="inventory-tab active" data-tab="items">ç‰©å“</button>
            <button class="inventory-tab" data-tab="materials">ææ–™</button>
            <button class="inventory-tab" data-tab="equipment">è£…å¤‡</button>
        </div>
        <div class="inventory-content" id="inventory-content"></div>
    </div>
</div>

<div id="challenge-modal" class="learning-modal" aria-hidden="true">
    <div class="learning-modal-content">
        <div class="learning-modal-header">
            <span>å­¦ä¹ æŒ‘æˆ˜</span>
        </div>
        <div class="learning-modal-question" id="challenge-question"></div>
        <div class="learning-modal-options" id="challenge-options"></div>
        <div class="learning-modal-input" id="challenge-input-wrapper">
            <input type="text" id="challenge-input" placeholder="è¾“å…¥è‹±æ–‡æˆ–ä¸­æ–‡" autocomplete="off">
        </div>
        <div class="learning-modal-footer">
            <div class="learning-modal-timer" id="challenge-timer">10</div>
            <button class="game-btn game-btn-small" id="challenge-repeat">å†å¬ä¸€æ¬¡</button>
        </div>
    </div>
</div>

<div id="word-match-screen" class="learning-modal" aria-hidden="true">
    <div class="learning-modal-content word-match-content">
        <div class="word-match-header">
            <h2>è¯è¯­åŒ¹é…å¤æ´»</h2>
            <div class="match-timer" id="match-timer">30</div>
        </div>
        <p class="word-match-subtitle" id="match-subtitle">å°†è‹±æ–‡ä¸ä¸­æ–‡æ‹‰çº¿è¿å¯¹ï¼Œåªæœ‰1æ¬¡æœºä¼š</p>
        <div class="match-container">
            <div class="match-column" id="match-left"></div>
            <svg class="match-lines" id="match-lines" xmlns="http://www.w3.org/2000/svg"></svg>
            <div class="match-column" id="match-right"></div>
        </div>
        <div class="match-footer">
            <div>å·²è¿çº¿: <span id="match-count">0</span>/<span id="match-total">0</span></div>
            <button class="game-btn" id="btn-match-submit">æäº¤å¤æ´»</button>
        </div>
        <div id="match-result" class="match-result"></div>
    </div>
</div>

<div id="profile-modal" class="profile-modal" aria-hidden="true">
    <div class="profile-modal-content">
        <div class="profile-header">
            <h2 id="profile-username">ç©å®¶æ¡£æ¡ˆ</h2>
            <button class="game-btn game-btn-small" id="btn-profile-close">å…³é—­</button>
        </div>
        <div class="profile-stats">
            <div>æ¸¸æˆæ¬¡æ•°: <span id="profile-games">0</span></div>
            <div>æœ€é«˜ç§¯åˆ†: <span id="profile-highscore">0</span></div>
            <div>å·²å­¦è¯æ•°: <span id="profile-words">0</span></div>
            <div>æ¸¸ç©æ—¶é•¿: <span id="profile-playtime">0 åˆ†é’Ÿ</span></div>
            <!-- v1.6.4 æ–°å¢ï¼šç­”é¢˜ç»Ÿè®¡ -->
            <div>ğŸ“ ç­”é¢˜ç»Ÿè®¡: <span id="profile-challenge-stats">-</span></div>
        </div>
        <!-- v1.6.4 æ–°å¢ï¼šå•è¯æœ¬æŒ‰é’® -->
        <div style="text-align:center;margin:15px 0;">
            <button id="btn-vocab-book" class="game-btn">ğŸ“– æˆ‘çš„å•è¯æœ¬</button>
        </div>
        <div class="profile-achievements">
            <h3>æˆå°±</h3>
            <div id="achievements-container"></div>
        </div>
    </div>
</div>

<!-- v1.6.4 æ–°å¢ï¼šå•è¯æœ¬æ¨¡æ€æ¡† -->
<div id="vocab-book-modal" class="profile-modal" aria-hidden="true">
    <div class="profile-modal-content vocab-book">
        <div class="profile-header">
            <h2>ğŸ“– æˆ‘çš„å•è¯æœ¬</h2>
            <button class="game-btn game-btn-small" id="btn-close-vocab-book">å…³é—­</button>
        </div>
        <div id="vocab-book-list" class="vocab-book-list"></div>
    </div>
</div>

<script>
window.MMWG_DEFAULTS = {
    gameConfig: {
        canvas: { width: 800, height: 600 },
        physics: {
            gravity: 0.2,
            friction: 0.85,
            jumpStrength: -7.0,
            movementSpeed: 1.2,
            groundY: 530
        },
        world: {
            blockSize: 50,
            cameraOffsetX: 300,
            mapBuffer: 1000,
            removeThreshold: 200,
            fallResetY: 800
        },
        scoring: {
            word: 10,
            enemy: 5,
            levelUp: 100,
            hitPenaltyScale: 0.5,
            minHitPenalty: 5,
            maxHitPenalty: 30
        },
        revive: {
            diamondCost: 10,
            scoreCost: 500,
            scoreReviveHpPercent: 0.5,
            invincibleFrames: 180
        },
        jump: {
            bufferFrames: 12,
            coyoteFrames: 10
        },
        player: {
            width: 26,
            height: 52,
            maxJumps: 2,
            maxHp: 10
        },
        spawn: {
            floatingPlatformChance: 0.6,
            floatingItemChance: 0.5,
            treeChance: 0.2,
            chestChance: 0.35,
            itemChance: 0.55,
            enemyChance: 0.7,
            wordItemMinGap: 150
        },
        platforms: {
            gapChance: 0.16,
            gapWeights: { narrow: 0.5, medium: 0.35, wide: 0.15 },
            gapSizes: { narrow: [1, 2], medium: [2, 3], wide: [3, 4] },
            cloudGapChance: 0.08,
            cloudHeightMin: 120,
            cloudHeightMax: 200,
            cloudPlatformMin: 2,
            cloudPlatformMax: 4,
            cloudSpacingMin: 1,
            cloudSpacingMax: 2,
            cloudFragileChance: 0.35,
            fragileBreakDelay: 120,
            jumpVerbMinAirFrames: 18,
            movingPlatformChance: 0.15,
            movingPlatformSpeedMin: 0.4,
            movingPlatformSpeedMax: 1.1,
            movingPlatformRangeMult: 0.4,
            cloudTypeWeights: { normal: 0.6, thin: 0.25, moving: 0.1, bouncy: 0.05 }
        },
        enemies: {
            maxOnScreen: 8,
            spawnChance: 0.45,
            difficultyThresholds: [500, 1000, 2000, 3000],
            bossSpawnScore: 5000
        },
        difficulty: {
            damageUnit: 20,
            invincibleFrames: 120,
            tiers: [
                { name: "æ–°æ‰‹", minScore: 0, maxScore: 500, enemyDamage: 0.8, enemyHp: 0.85, enemySpawn: 0.75, chestSpawn: 1.1, chestRareBoost: 0.25, chestRollBonus: 0.08, scoreMultiplier: 1.0 },
                { name: "ç®€å•", minScore: 500, maxScore: 1500, enemyDamage: 1.0, enemyHp: 1.0, enemySpawn: 0.95, chestSpawn: 1.0, chestRareBoost: 0.1, chestRollBonus: 0.04, scoreMultiplier: 1.0 },
                { name: "æ™®é€š", minScore: 1500, maxScore: 3000, enemyDamage: 1.15, enemyHp: 1.1, enemySpawn: 1.05, chestSpawn: 0.95, chestRareBoost: 0.0, chestRollBonus: 0.0, scoreMultiplier: 1.05 },
                { name: "å›°éš¾", minScore: 3000, maxScore: 5000, enemyDamage: 1.4, enemyHp: 1.25, enemySpawn: 1.2, chestSpawn: 0.9, chestRareBoost: -0.1, chestRollBonus: -0.02, scoreMultiplier: 1.1 },
                { name: "åœ°ç‹±", minScore: 5000, maxScore: 999999, enemyDamage: 1.8, enemyHp: 1.5, enemySpawn: 1.35, chestSpawn: 0.85, chestRareBoost: -0.2, chestRollBonus: -0.04, scoreMultiplier: 1.2 }
            ],
            dda: {
                enabled: true,
                lowHpThreshold: 1,
                lowHpEnemyDamage: 0.7,
                lowHpEnemySpawn: 0.8,
                lowHpChestBonus: 0.2,
                noHitFramesForBoost: 720,
                noHitEnemyDamage: 1.15,
                noHitEnemySpawn: 1.1,
                maxTotalEnemyDamage: 2.2,
                maxTotalEnemySpawn: 1.6
            }
        },
        loot: {
            chestRarities: [
                { id: "common", weight: 60 },
                { id: "rare", weight: 30 },
                { id: "epic", weight: 8 },
                { id: "legendary", weight: 2 }
            ],
            chestTables: {
                common: [
                    { item: "iron", weight: 18, min: 1, max: 3 },
                    { item: "pumpkin", weight: 12, min: 1, max: 2 },
                { item: "stick", weight: 12, min: 1, max: 3 },
                { item: "diamond", weight: 4, min: 1, max: 1 },
                { item: "coal", weight: 10, min: 1, max: 3 },
                { item: "arrow", weight: 10, min: 2, max: 6 },
                { item: "rotten_flesh", weight: 8, min: 1, max: 3 },
                { item: "flower", weight: 6, min: 1, max: 2 },
                { item: "mushroom", weight: 6, min: 1, max: 2 },
                { item: "hp", weight: 8, min: 1, max: 1 },
                { item: "armor_leather", weight: 5, min: 1, max: 1 },
                { item: "score", weight: 7, min: 10, max: 25 }
            ],
            rare: [
                { item: "diamond", weight: 6, min: 1, max: 1 },
                { item: "stone_sword", weight: 7, min: 1, max: 1 },
                { item: "iron_pickaxe", weight: 5, min: 1, max: 1 },
                { item: "bow", weight: 4, min: 1, max: 1 },
                { item: "ender_pearl", weight: 4, min: 1, max: 1 },
                { item: "iron", weight: 8, min: 2, max: 4 },
                { item: "arrow", weight: 8, min: 4, max: 8 },
                { item: "hp", weight: 8, min: 1, max: 1 },
                { item: "armor_chainmail", weight: 4, min: 1, max: 1 },
                { item: "armor_iron", weight: 3, min: 1, max: 1 },
                { item: "score", weight: 8, min: 20, max: 40 }
            ],
            epic: [
                { item: "max_hp", weight: 6, min: 1, max: 1 },
                { item: "diamond", weight: 6, min: 1, max: 2 },
                { item: "ender_pearl", weight: 5, min: 1, max: 2 },
                { item: "iron_pickaxe", weight: 6, min: 1, max: 1 },
                { item: "bow", weight: 6, min: 1, max: 1 },
                { item: "armor_gold", weight: 3, min: 1, max: 1 },
                { item: "armor_diamond", weight: 2, min: 1, max: 1 },
                { item: "score", weight: 8, min: 40, max: 80 }
            ],
            legendary: [
                { item: "max_hp", weight: 8, min: 1, max: 2 },
                { item: "diamond", weight: 8, min: 2, max: 3 },
                { item: "dragon_egg", weight: 4, min: 1, max: 1 },
                { item: "ender_pearl", weight: 6, min: 2, max: 3 },
                { item: "armor_netherite", weight: 3, min: 1, max: 1 },
                { item: "score", weight: 10, min: 80, max: 150 }
            ]
            },
            chestRolls: {
                twoDropChance: 0.45,
                threeDropChance: 0.15
            }
        },
        golems: {
            maxCount: 3,
            ironGolem: { hp: 100, damage: 20, speed: 1.5 },
            snowGolem: { hp: 50, damage: 10, speed: 2.0 }
        }
    },
    controls: {
        left: "ArrowLeft",
        right: "ArrowRight",
        jump: "Space",
        attack: "KeyJ",
        interact: "KeyY",
        switch: "KeyK",
        useDiamond: "KeyZ"
    },
    levels: [
        { name: "è‰åŸ", bg: "#87CEEB", ground: "grass", treeType: "oak" },
        { name: "é›ªåœ°", bg: "#E0F7FA", ground: "snow", treeType: "spruce" },
        { name: "çŸ¿æ´", bg: "#2F2F2F", ground: "stone", treeType: "mushroom" },
        { name: "æ£®æ—", bg: "#228B22", ground: "forest", treeType: "big_oak" },
        { name: "æ²™æ¼ ", bg: "#FFECB3", ground: "sand", treeType: "cactus" }
    ],
    words: [
        { en: "cat", zh: "çŒ«" },
        { en: "dog", zh: "ç‹—" },
        { en: "pig", zh: "çŒª" },
        { en: "duck", zh: "é¸­" },
        { en: "cow", zh: "ç‰›" },
        { en: "red", zh: "çº¢è‰²" },
        { en: "blue", zh: "è“è‰²" },
        { en: "green", zh: "ç»¿è‰²" },
        { en: "yellow", zh: "é»„è‰²" },
        { en: "one", zh: "ä¸€" },
        { en: "two", zh: "äºŒ" },
        { en: "three", zh: "ä¸‰" },
        { en: "apple", zh: "è‹¹æœ" },
        { en: "tree", zh: "æ ‘" },
        { en: "flower", zh: "èŠ±" },
        { en: "grass", zh: "è‰" },
        { en: "sky", zh: "å¤©ç©º" }
    ],
    settings: {
        learningMode: true,
        challengeEnabled: true,
        challengeFrequency: 0.3,
        chestLearningEnabled: true,        // å®ç®±å­¦ä¹ ï¼šå¼€ç®±å‰ç­”é¢˜ (v1.6.1)
        showEnvironmentWords: true,        // ç¯å¢ƒå•è¯æ ‡ç­¾ï¼šæ˜¾ç¤ºå®ä½“è‹±æ–‡å (v1.6.2)
        wordGateEnabled: true,
        wordMatchEnabled: true,
        speechEnabled: true,
        speechZhEnabled: false,
        speechEnRate: 1.2,
        speechZhRate: 1.1,
        musicEnabled: true,
        deviceMode: "phone",
        orientationLock: "auto",
        uiScale: 1.0,
        motionScale: 1.25,
        touchControls: true,
        avoidWordRepeats: true,
        showWordImage: true,
        showEnvironmentLabels: true,
        biomeSwitchStepScore: 200,
        villageEnabled: true,                 // æ‘åº„ç³»ç»Ÿå¼€å…³ (v1.8.0)
        gameDifficulty: "medium",
        vocabStage: "auto",
        vocabSelection: "vocab.kindergarten",
        vocabDifficulty: "auto",
        movementSpeedLevel: "normal",
        keyCodes: "Space,KeyJ,KeyY,KeyK,KeyZ"
    }
};

</script>
<script>
const ACCOUNT_SCHEMA = {
    id: "",
    username: "",
    avatar: "default",
    createdAt: 0,
    lastLoginAt: 0,
    totalPlayTime: 0,
    progress: {
        currentLevel: 1,
        highScore: 0,
        totalScore: 0,
        totalCoins: 0,
        currentCoins: 0,
        currentDiamonds: 0
    },
    vocabulary: {
        learnedWords: [],
        masteredWords: [],
        wordStats: {},
        completedPacks: [],
        currentPack: "",
        packProgress: {}
    },
    achievements: {
        unlocked: [],
        progress: {}
    },
    inventory: {
        items: {},
        equipment: {
            armor: null,
            armorDurability: 0
        },
        armorCollection: []
    },
    stats: {
        gamesPlayed: 0,
        enemiesKilled: 0,
        chestsOpened: 0,
        wordsCollected: 0,
        deathCount: 0,
        maxCombo: 0,
        longestRun: 0
    }
};

function clone(value) {
    try {
        return JSON.parse(JSON.stringify(value));
    } catch {
        return value;
    }
}

window.MMWG_STORAGE = {
    loadJson(key, fallback) {
        try {
            const raw = window.localStorage.getItem(key);
            if (!raw) return clone(fallback);
            return JSON.parse(raw);
        } catch {
            return clone(fallback);
        }
    },
    saveJson(key, value) {
        try {
            window.localStorage.setItem(key, JSON.stringify(value));
        } catch {
            console.warn("Storage save failed:", key);
        }
    },
    getAccountList() {
        return this.loadJson("mmwg_accounts", []);
    },
    saveAccountList(accounts) {
        this.saveJson("mmwg_accounts", accounts);
    },
    getCurrentAccountId() {
        return window.localStorage.getItem("mmwg_current_account") || null;
    },
    setCurrentAccountId(id) {
        if (id) {
            window.localStorage.setItem("mmwg_current_account", id);
        } else {
            window.localStorage.removeItem("mmwg_current_account");
        }
    },
    getAccount(id) {
        const list = this.getAccountList();
        return list.find(a => a.id === id) || null;
    },
    saveAccount(account) {
        const accounts = this.getAccountList();
        const idx = accounts.findIndex(a => a.id === account.id);
        if (idx >= 0) {
            accounts[idx] = clone(account);
        } else {
            accounts.push(clone(account));
        }
        this.saveAccountList(accounts);
    },
    deleteAccount(id) {
        let accounts = this.getAccountList();
        accounts = accounts.filter(a => a.id !== id);
        this.saveAccountList(accounts);
        if (this.getCurrentAccountId() === id) {
            this.setCurrentAccountId(null);
        }
    },
    createAccount(username) {
        const id = `account_${Date.now()}`;
        const account = {
            ...clone(ACCOUNT_SCHEMA),
            id,
            username,
            createdAt: Date.now(),
            lastLoginAt: Date.now()
        };
        this.saveAccount(account);
        return account;
    }
};

</script>
<script>
(() => {
  const packs = [
    {
      id: "vocab.kindergarten.basic",
      title: "å¹¼å„¿å›­ - åˆçº§",
      stage: "kindergarten",
      difficulty: "basic",
      level: "basic",
      weight: 1,
      files: [
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_01.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_02.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_03.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_KINDERGARTEN_PART01 !== "undefined" ? STAGE_KINDERGARTEN_PART01 : []),
          ...(typeof STAGE_KINDERGARTEN_PART02 !== "undefined" ? STAGE_KINDERGARTEN_PART02 : []),
          ...(typeof STAGE_KINDERGARTEN_PART03 !== "undefined" ? STAGE_KINDERGARTEN_PART03 : []),
        ];
      }
    },
    {
      id: "vocab.kindergarten.intermediate",
      title: "å¹¼å„¿å›­ - ä¸­çº§",
      stage: "kindergarten",
      difficulty: "basic",
      level: "intermediate",
      weight: 1,
      files: [
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_04.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_05.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_06.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_07.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_KINDERGARTEN_PART04 !== "undefined" ? STAGE_KINDERGARTEN_PART04 : []),
          ...(typeof STAGE_KINDERGARTEN_PART05 !== "undefined" ? STAGE_KINDERGARTEN_PART05 : []),
          ...(typeof STAGE_KINDERGARTEN_PART06 !== "undefined" ? STAGE_KINDERGARTEN_PART06 : []),
          ...(typeof STAGE_KINDERGARTEN_PART07 !== "undefined" ? STAGE_KINDERGARTEN_PART07 : []),
        ];
      }
    },
    {
      id: "vocab.kindergarten.advanced",
      title: "å¹¼å„¿å›­ - é«˜çº§",
      stage: "kindergarten",
      difficulty: "basic",
      level: "advanced",
      weight: 1,
      files: [
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_08.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_09.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_10.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_KINDERGARTEN_PART08 !== "undefined" ? STAGE_KINDERGARTEN_PART08 : []),
          ...(typeof STAGE_KINDERGARTEN_PART09 !== "undefined" ? STAGE_KINDERGARTEN_PART09 : []),
          ...(typeof STAGE_KINDERGARTEN_PART10 !== "undefined" ? STAGE_KINDERGARTEN_PART10 : []),
        ];
      }
    },
    {
      id: "vocab.kindergarten",
      title: "å¹¼å„¿å›­ - å®Œæ•´",
      stage: "kindergarten",
      difficulty: "basic",
      level: "full",
      weight: 1,
      files: [
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_1_åŸºç¡€.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_2_å­¦ä¹ .js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_3_è‡ªç„¶.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_4_æ²Ÿé€š.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_5_æ—¥å¸¸.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_6_é€šç”¨.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_01.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_02.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_03.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_04.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_05.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_06.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_07.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_08.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_09.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­_åˆ†å·_10.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­åŸºç¡€.js",
        "words/vocabs/01_å¹¼å„¿å›­/å¹¼å„¿å›­å®Œæ•´è¯åº“.js",
      ],
      getRaw() {
        return [
          ...(typeof VOCAB_1__________ !== "undefined" ? VOCAB_1__________ : []),
          ...(typeof VOCAB_2__________ !== "undefined" ? VOCAB_2__________ : []),
          ...(typeof VOCAB_3__________ !== "undefined" ? VOCAB_3__________ : []),
          ...(typeof VOCAB_4_____ !== "undefined" ? VOCAB_4_____ : []),
          ...(typeof VOCAB_5_____ !== "undefined" ? VOCAB_5_____ : []),
          ...(typeof VOCAB_6______ !== "undefined" ? VOCAB_6______ : []),
          ...(typeof STAGE_KINDERGARTEN_PART01 !== "undefined" ? STAGE_KINDERGARTEN_PART01 : []),
          ...(typeof STAGE_KINDERGARTEN_PART02 !== "undefined" ? STAGE_KINDERGARTEN_PART02 : []),
          ...(typeof STAGE_KINDERGARTEN_PART03 !== "undefined" ? STAGE_KINDERGARTEN_PART03 : []),
          ...(typeof STAGE_KINDERGARTEN_PART04 !== "undefined" ? STAGE_KINDERGARTEN_PART04 : []),
          ...(typeof STAGE_KINDERGARTEN_PART05 !== "undefined" ? STAGE_KINDERGARTEN_PART05 : []),
          ...(typeof STAGE_KINDERGARTEN_PART06 !== "undefined" ? STAGE_KINDERGARTEN_PART06 : []),
          ...(typeof STAGE_KINDERGARTEN_PART07 !== "undefined" ? STAGE_KINDERGARTEN_PART07 : []),
          ...(typeof STAGE_KINDERGARTEN_PART08 !== "undefined" ? STAGE_KINDERGARTEN_PART08 : []),
          ...(typeof STAGE_KINDERGARTEN_PART09 !== "undefined" ? STAGE_KINDERGARTEN_PART09 : []),
          ...(typeof STAGE_KINDERGARTEN_PART10 !== "undefined" ? STAGE_KINDERGARTEN_PART10 : []),
          ...(typeof STAGE_KINDERGARTEN !== "undefined" ? STAGE_KINDERGARTEN : []),
          ...(typeof MERGED_KINDERGARTEN_VOCAB !== "undefined" ? MERGED_KINDERGARTEN_VOCAB : []),
        ];
      }
    },
    {
      id: "vocab.elementary_lower.basic",
      title: "å°å­¦ä½å¹´çº§ - åˆçº§",
      stage: "elementary_lower",
      difficulty: "basic",
      level: "basic",
      weight: 1,
      files: [
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_01.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_02.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_03.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER_PART01 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART01 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART02 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART02 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART03 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART03 : []),
        ];
      }
    },
    {
      id: "vocab.elementary_lower.intermediate",
      title: "å°å­¦ä½å¹´çº§ - ä¸­çº§",
      stage: "elementary_lower",
      difficulty: "basic",
      level: "intermediate",
      weight: 1,
      files: [
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_04.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_05.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_06.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_07.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER_PART04 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART04 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART05 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART05 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART06 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART06 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART07 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART07 : []),
        ];
      }
    },
    {
      id: "vocab.elementary_lower.advanced",
      title: "å°å­¦ä½å¹´çº§ - é«˜çº§",
      stage: "elementary_lower",
      difficulty: "basic",
      level: "advanced",
      weight: 1,
      files: [
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_08.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_09.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_10.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER_PART08 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART08 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART09 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART09 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART10 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART10 : []),
        ];
      }
    },
    {
      id: "vocab.elementary_lower",
      title: "å°å­¦ä½å¹´çº§ - å®Œæ•´",
      stage: "elementary_lower",
      difficulty: "basic",
      level: "full",
      weight: 1,
      files: [
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_01.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_02.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_03.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_04.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_05.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_06.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_07.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_08.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_09.js",
        "words/vocabs/02_å°å­¦_ä½å¹´çº§/å°å­¦ä½å¹´çº§_åˆ†å·_10.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER_PART01 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART01 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART02 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART02 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART03 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART03 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART04 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART04 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART05 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART05 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART06 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART06 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART07 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART07 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART08 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART08 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART09 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART09 : []),
          ...(typeof STAGE_ELEMENTARY_LOWER_PART10 !== "undefined" ? STAGE_ELEMENTARY_LOWER_PART10 : []),
        ];
      }
    },
    {
      id: "vocab.elementary_upper.basic",
      title: "å°å­¦é«˜å¹´çº§ - åˆçº§",
      stage: "elementary_upper",
      difficulty: "intermediate",
      level: "basic",
      weight: 1,
      files: [
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦ä½å¹´çº§åŸºç¡€.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER !== "undefined" ? STAGE_ELEMENTARY_LOWER : []),
        ];
      }
    },
    {
      id: "vocab.elementary_upper.intermediate",
      title: "å°å­¦é«˜å¹´çº§ - ä¸­çº§",
      stage: "elementary_upper",
      difficulty: "intermediate",
      level: "intermediate",
      weight: 1,
      files: [
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦é«˜å¹´çº§åŸºç¡€.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_UPPER !== "undefined" ? STAGE_ELEMENTARY_UPPER : []),
        ];
      }
    },
    {
      id: "vocab.elementary_upper.advanced",
      title: "å°å­¦é«˜å¹´çº§ - é«˜çº§",
      stage: "elementary_upper",
      difficulty: "intermediate",
      level: "advanced",
      weight: 1,
      files: [
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦å…¨é˜¶æ®µåˆå¹¶è¯åº“.js",
      ],
      getRaw() {
        return [
          ...(typeof MERGED_VOCABULARY !== "undefined" ? MERGED_VOCABULARY : []),
        ];
      }
    },
    {
      id: "vocab.elementary_upper",
      title: "å°å­¦é«˜å¹´çº§ - å®Œæ•´",
      stage: "elementary_upper",
      difficulty: "intermediate",
      level: "full",
      weight: 1,
      files: [
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦ä½å¹´çº§åŸºç¡€.js",
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦ä½å¹´çº§è¯æ±‡åº“.js",
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦å…¨é˜¶æ®µåˆå¹¶è¯åº“.js",
        "words/vocabs/03_å°å­¦_é«˜å¹´çº§/å°å­¦é«˜å¹´çº§åŸºç¡€.js",
      ],
      getRaw() {
        return [
          ...(typeof STAGE_ELEMENTARY_LOWER !== "undefined" ? STAGE_ELEMENTARY_LOWER : []),
          ...(typeof STAGE_ELEMENTARY_LOWER !== "undefined" ? STAGE_ELEMENTARY_LOWER : []),
          ...(typeof MERGED_VOCABULARY !== "undefined" ? MERGED_VOCABULARY : []),
          ...(typeof STAGE_ELEMENTARY_UPPER !== "undefined" ? STAGE_ELEMENTARY_UPPER : []),
        ];
      }
    },
    {
      id: "vocab.minecraft.basic",
      title: "æˆ‘çš„ä¸–ç•Œ - åˆçº§",
      stage: "minecraft",
      difficulty: "basic",
      level: "basic",
      weight: 1,
      files: [
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_basic.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_blocks.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_items.js",
      ],
      getRaw() {
        return [
          ...(typeof VOCAB_1_MINECRAFT____BASIC !== "undefined" ? VOCAB_1_MINECRAFT____BASIC : []),
          ...(typeof MINECRAFT_1_BLOCKS___ !== "undefined" ? MINECRAFT_1_BLOCKS___ : []),
          ...(typeof MINECRAFT_2_ITEMS___ !== "undefined" ? MINECRAFT_2_ITEMS___ : []),
        ];
      }
    },
    {
      id: "vocab.minecraft.intermediate",
      title: "æˆ‘çš„ä¸–ç•Œ - ä¸­çº§",
      stage: "minecraft",
      difficulty: "basic",
      level: "intermediate",
      weight: 1,
      files: [
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_intermediate.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_entities.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_biomes.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_environment.js",
      ],
      getRaw() {
        return [
          ...(typeof VOCAB_2_MINECRAFT____BASIC !== "undefined" ? VOCAB_2_MINECRAFT____BASIC : []),
          ...(typeof MINECRAFT_3_ENTITIES___ !== "undefined" ? MINECRAFT_3_ENTITIES___ : []),
          ...(typeof MINECRAFT_5_BIOMES_____ !== "undefined" ? MINECRAFT_5_BIOMES_____ : []),
          ...(typeof MINECRAFT_4_ENVIRONMENT___ !== "undefined" ? MINECRAFT_4_ENVIRONMENT___ : []),
        ];
      }
    },
    {
      id: "vocab.minecraft.advanced",
      title: "æˆ‘çš„ä¸–ç•Œ - é«˜çº§",
      stage: "minecraft",
      difficulty: "basic",
      level: "advanced",
      weight: 1,
      files: [
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_advanced.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_enchantments.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_advancements.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_status_effects.js",
      ],
      getRaw() {
        return [
          ...(typeof VOCAB_3_MINECRAFT____ADVANCED !== "undefined" ? VOCAB_3_MINECRAFT____ADVANCED : []),
          ...(typeof MINECRAFT_7_____ENCHANTMENTS_ !== "undefined" ? MINECRAFT_7_____ENCHANTMENTS_ : []),
          ...(typeof MINECRAFT_8_____ADVANCEMENTS_ !== "undefined" ? MINECRAFT_8_____ADVANCEMENTS_ : []),
          ...(typeof MINECRAFT_6_______STATUS_EFFECTS_ !== "undefined" ? MINECRAFT_6_______STATUS_EFFECTS_ : []),
        ];
      }
    },
    {
      id: "vocab.minecraft",
      title: "æˆ‘çš„ä¸–ç•Œ - å®Œæ•´",
      stage: "minecraft",
      difficulty: "basic",
      level: "full",
      weight: 1,
      files: [
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_advanced.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_advancements.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_basic.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_biomes.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_blocks.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_enchantments.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_entities.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_environment.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_intermediate.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_items.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_items_2.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_status_effects.js",
        "words/vocabs/04_æˆ‘çš„ä¸–ç•Œ/minecraft_words_full.js",
      ],
      getRaw() {
        return [
          ...(typeof VOCAB_3_MINECRAFT____ADVANCED !== "undefined" ? VOCAB_3_MINECRAFT____ADVANCED : []),
          ...(typeof MINECRAFT_8_____ADVANCEMENTS_ !== "undefined" ? MINECRAFT_8_____ADVANCEMENTS_ : []),
          ...(typeof VOCAB_1_MINECRAFT____BASIC !== "undefined" ? VOCAB_1_MINECRAFT____BASIC : []),
          ...(typeof MINECRAFT_5_BIOMES_____ !== "undefined" ? MINECRAFT_5_BIOMES_____ : []),
          ...(typeof MINECRAFT_1_BLOCKS___ !== "undefined" ? MINECRAFT_1_BLOCKS___ : []),
          ...(typeof MINECRAFT_7_____ENCHANTMENTS_ !== "undefined" ? MINECRAFT_7_____ENCHANTMENTS_ : []),
          ...(typeof MINECRAFT_3_ENTITIES___ !== "undefined" ? MINECRAFT_3_ENTITIES___ : []),
          ...(typeof MINECRAFT_4_ENVIRONMENT___ !== "undefined" ? MINECRAFT_4_ENVIRONMENT___ : []),
          ...(typeof VOCAB_2_MINECRAFT____BASIC !== "undefined" ? VOCAB_2_MINECRAFT____BASIC : []),
          ...(typeof MINECRAFT_2_ITEMS___ !== "undefined" ? MINECRAFT_2_ITEMS___ : []),
          ...(typeof MINECRAFT_2_ITEMS___2 !== "undefined" ? MINECRAFT_2_ITEMS___2 : []),
          ...(typeof MINECRAFT_6_______STATUS_EFFECTS_ !== "undefined" ? MINECRAFT_6_______STATUS_EFFECTS_ : []),
          ...(typeof MINECRAFT_3_____ !== "undefined" ? MINECRAFT_3_____ : []),
        ];
      }
    },
  ];

  const byId = Object.create(null);
  packs.forEach(p => { byId[p.id] = p; });

  window.MMWG_VOCAB_MANIFEST = {
    version: "2026-02-04.1",
    packs,
    byId
  };
})();

</script>

<script>
(() => {
  const data = {
  "config/game.json": {
    "canvas": {
      "width": 800,
      "height": 600
    },
    "physics": {
      "gravity": 0.2,
      "friction": 0.85,
      "jumpStrength": -7,
      "movementSpeed": 2,
      "groundY": 530
    },
    "world": {
      "blockSize": 50,
      "cameraOffsetX": 300,
      "mapBuffer": 1000,
      "removeThreshold": 200,
      "fallResetY": 800
    },
    "scoring": {
      "word": 10,
      "enemy": 5,
      "levelUp": 100,
      "hitPenaltyScale": 0.5,
      "minHitPenalty": 5,
      "maxHitPenalty": 30
    },
    "jump": {
      "bufferFrames": 12,
      "coyoteFrames": 10
    },
    "player": {
      "width": 26,
      "height": 52,
      "maxJumps": 2,
      "maxHp": 10
    },
    "spawn": {
      "floatingPlatformChance": 0.6,
      "floatingItemChance": 0.5,
      "treeChance": 0.2,
      "chestChance": 0.35,
      "itemChance": 0.55,
      "enemyChance": 0.7,
      "wordItemMinGap": 150
    },
    "platforms": {
      "gapChance": 0.16,
      "gapWeights": {
        "narrow": 0.5,
        "medium": 0.35,
        "wide": 0.15
      },
      "gapSizes": {
        "narrow": [
          1,
          2
        ],
        "medium": [
          2,
          3
        ],
        "wide": [
          3,
          4
        ]
      },
      "cloudGapChance": 0.08,
      "cloudHeightMin": 120,
      "cloudHeightMax": 200,
      "cloudPlatformMin": 2,
      "cloudPlatformMax": 4,
      "cloudSpacingMin": 1,
      "cloudSpacingMax": 2,
      "cloudFragileChance": 0.35,
      "fragileBreakDelay": 120,
      "jumpVerbMinAirFrames": 18,
      "movingPlatformChance": 0.15,
      "movingPlatformSpeedMin": 0.4,
      "movingPlatformSpeedMax": 1.1,
      "movingPlatformRangeMult": 0.4,
      "cloudTypeWeights": {
        "normal": 0.6,
        "thin": 0.25,
        "moving": 0.1,
        "bouncy": 0.05
      }
    },
    "enemies": {
      "maxOnScreen": 8,
      "spawnChance": 0.45,
      "difficultyThresholds": [
        500,
        1000,
        2000,
        3000
      ],
      "bossSpawnScore": 5000
    },
    "difficulty": {
      "damageUnit": 20,
      "invincibleFrames": 120,
      "tiers": [
        {
          "name": "æ–°æ‰‹",
          "minScore": 0,
          "maxScore": 500,
          "enemyDamage": 0.8,
          "enemyHp": 0.85,
          "enemySpawn": 0.75,
          "chestSpawn": 1.1,
          "chestRareBoost": 0.25,
          "chestRollBonus": 0.08,
          "scoreMultiplier": 1
        },
        {
          "name": "ç®€å•",
          "minScore": 500,
          "maxScore": 1500,
          "enemyDamage": 1,
          "enemyHp": 1,
          "enemySpawn": 0.95,
          "chestSpawn": 1,
          "chestRareBoost": 0.1,
          "chestRollBonus": 0.04,
          "scoreMultiplier": 1
        },
        {
          "name": "æ™®é€š",
          "minScore": 1500,
          "maxScore": 3000,
          "enemyDamage": 1.15,
          "enemyHp": 1.1,
          "enemySpawn": 1.05,
          "chestSpawn": 0.95,
          "chestRareBoost": 0,
          "chestRollBonus": 0,
          "scoreMultiplier": 1.05
        },
        {
          "name": "å›°éš¾",
          "minScore": 3000,
          "maxScore": 5000,
          "enemyDamage": 1.4,
          "enemyHp": 1.25,
          "enemySpawn": 1.2,
          "chestSpawn": 0.9,
          "chestRareBoost": -0.1,
          "chestRollBonus": -0.02,
          "scoreMultiplier": 1.1
        },
        {
          "name": "åœ°ç‹±",
          "minScore": 5000,
          "maxScore": 999999,
          "enemyDamage": 1.8,
          "enemyHp": 1.5,
          "enemySpawn": 1.35,
          "chestSpawn": 0.85,
          "chestRareBoost": -0.2,
          "chestRollBonus": -0.04,
          "scoreMultiplier": 1.2
        }
      ],
      "dda": {
        "enabled": true,
        "lowHpThreshold": 1,
        "lowHpEnemyDamage": 0.7,
        "lowHpEnemySpawn": 0.8,
        "lowHpChestBonus": 0.2,
        "noHitFramesForBoost": 720,
        "noHitEnemyDamage": 1.15,
        "noHitEnemySpawn": 1.1,
        "maxTotalEnemyDamage": 2.2,
        "maxTotalEnemySpawn": 1.6
      }
    },
    "loot": {
      "chestRarities": [
        {
          "id": "common",
          "weight": 60
        },
        {
          "id": "rare",
          "weight": 30
        },
        {
          "id": "epic",
          "weight": 8
        },
        {
          "id": "legendary",
          "weight": 2
        }
      ],
      "chestTables": {
        "common": [
          {
            "item": "iron",
            "weight": 18,
            "min": 1,
            "max": 3
          },
          {
            "item": "pumpkin",
            "weight": 12,
            "min": 1,
            "max": 2
          },
          {
            "item": "stick",
            "weight": 12,
            "min": 1,
            "max": 3
          },
          {
            "item": "diamond",
            "weight": 4,
            "min": 1,
            "max": 1
          },
          {
            "item": "coal",
            "weight": 10,
            "min": 1,
            "max": 3
          },
          {
            "item": "arrow",
            "weight": 10,
            "min": 2,
            "max": 6
          },
          {
            "item": "rotten_flesh",
            "weight": 8,
            "min": 1,
            "max": 3
          },
          {
            "item": "flower",
            "weight": 6,
            "min": 1,
            "max": 2
          },
          {
            "item": "mushroom",
            "weight": 6,
            "min": 1,
            "max": 2
          },
          {
            "item": "hp",
            "weight": 8,
            "min": 1,
            "max": 1
          },
          {
            "item": "score",
            "weight": 7,
            "min": 10,
            "max": 25
          }
        ],
        "rare": [
          {
            "item": "diamond",
            "weight": 6,
            "min": 1,
            "max": 1
          },
          {
            "item": "stone_sword",
            "weight": 7,
            "min": 1,
            "max": 1
          },
          {
            "item": "iron_pickaxe",
            "weight": 5,
            "min": 1,
            "max": 1
          },
          {
            "item": "bow",
            "weight": 4,
            "min": 1,
            "max": 1
          },
          {
            "item": "ender_pearl",
            "weight": 4,
            "min": 1,
            "max": 1
          },
          {
            "item": "iron",
            "weight": 8,
            "min": 2,
            "max": 4
          },
          {
            "item": "arrow",
            "weight": 8,
            "min": 4,
            "max": 8
          },
          {
            "item": "hp",
            "weight": 8,
            "min": 1,
            "max": 1
          },
          {
            "item": "score",
            "weight": 8,
            "min": 20,
            "max": 40
          }
        ],
        "epic": [
          {
            "item": "max_hp",
            "weight": 6,
            "min": 1,
            "max": 1
          },
          {
            "item": "diamond",
            "weight": 6,
            "min": 1,
            "max": 2
          },
          {
            "item": "ender_pearl",
            "weight": 5,
            "min": 1,
            "max": 2
          },
          {
            "item": "iron_pickaxe",
            "weight": 6,
            "min": 1,
            "max": 1
          },
          {
            "item": "bow",
            "weight": 6,
            "min": 1,
            "max": 1
          },
          {
            "item": "score",
            "weight": 8,
            "min": 40,
            "max": 80
          }
        ],
        "legendary": [
          {
            "item": "max_hp",
            "weight": 8,
            "min": 1,
            "max": 2
          },
          {
            "item": "diamond",
            "weight": 8,
            "min": 2,
            "max": 3
          },
          {
            "item": "dragon_egg",
            "weight": 4,
            "min": 1,
            "max": 1
          },
          {
            "item": "ender_pearl",
            "weight": 6,
            "min": 2,
            "max": 3
          },
          {
            "item": "score",
            "weight": 10,
            "min": 80,
            "max": 150
          }
        ]
      },
      "chestRolls": {
        "twoDropChance": 0.45,
        "threeDropChance": 0.15
      }
    },
    "golems": {
      "maxCount": 3,
      "ironGolem": {
        "hp": 100,
        "damage": 20,
        "speed": 1.5
      },
      "snowGolem": {
        "hp": 50,
        "damage": 10,
        "speed": 2
      }
    }
  },
  "config/controls.json": {
    "left": "ArrowLeft",
    "right": "ArrowRight",
    "jump": "Space",
    "attack": "KeyJ",
    "interact": "KeyY",
    "switch": "KeyK",
    "useDiamond": "KeyZ"
  },
  "config/levels.json": [
    {
      "name": "è‰åŸ",
      "bg": "#87CEEB",
      "ground": "grass",
      "treeType": "oak"
    },
    {
      "name": "é›ªåœ°",
      "bg": "#E0F7FA",
      "ground": "snow",
      "treeType": "spruce"
    },
    {
      "name": "çŸ¿æ´",
      "bg": "#2F2F2F",
      "ground": "stone",
      "treeType": "mushroom"
    },
    {
      "name": "æ£®æ—",
      "bg": "#228B22",
      "ground": "forest",
      "treeType": "big_oak"
    },
    {
      "name": "æ²™æ¼ ",
      "bg": "#FFECB3",
      "ground": "sand",
      "treeType": "cactus"
    }
  ],
  "config/biomes.json": {
    "switch": {
      "stepScore": 200,
      "order": [
        "forest",
        "snow",
        "desert",
        "mountain",
        "ocean",
        "nether"
      ],
      "unlockScore": {
        "forest": 0,
        "snow": 200,
        "desert": 400,
        "mountain": 600,
        "ocean": 800,
        "nether": 2000
      }
    },
    "biomes": {
      "forest": {
        "id": "forest",
        "name": "æ£®æ—",
        "color": "#4CAF50",
        "groundType": "grass",
        "decorations": {
          "tree": 0.3,
          "bush": 0.2,
          "flower": 0.25,
          "mushroom": 0.1,
          "vine": 0.15,
          "cave_entrance": 0.04,
          "vine_ladder": 0.02
        },
        "treeTypes": {
          "oak": 0.5,
          "birch": 0.3,
          "dark_oak": 0.2
        },
        "effects": {
          "particles": "leaves",
          "ambient": "#88CC88",
          "weather": [
            "clear",
            "rain",
            "fog"
          ]
        },
        "spawnWeight": {
          "min": 0,
          "max": 1000
        },
        "platform": {
          "floatingChanceMult": 1.1,
          "floatingGroundTypes": [
            "grass"
          ],
          "floatingMinOffset": 80,
          "floatingMaxExtra": 50,
          "microPlatformChance": 0.22,
          "microPlatformPeriod": 2,
          "microPattern": "stair",
          "microPlatformType": "grass",
          "microPlatformMaxCount": 3,
          "microMaxRiseBlocks": 3,
          "microItemChance": 0.12
        }
      },
      "snow": {
        "id": "snow",
        "name": "é›ªåœ°",
        "color": "#FFFFFF",
        "groundType": "snow",
        "decorations": {
          "spruce": 0.25,
          "ice_spike": 0.1,
          "snow_pile": 0.3,
          "ice_block": 0.15
        },
        "treeTypes": {
          "spruce": 0.7,
          "pine": 0.3
        },
        "effects": {
          "particles": "snowflakes",
          "ambient": "#CCE6FF",
          "speedMultiplier": 1.2,
          "weather": [
            "snow"
          ]
        },
        "spawnWeight": {
          "min": 500,
          "max": 1500
        },
        "platform": {
          "floatingChanceMult": 1,
          "floatingGroundTypes": [
            "snow",
            "grass"
          ]
        }
      },
      "desert": {
        "id": "desert",
        "name": "æ²™æ¼ ",
        "color": "#FDD835",
        "groundType": "sand",
        "decorations": {
          "cactus": 0.2,
          "dead_bush": 0.15,
          "rock": 0.1,
          "bones": 0.05
        },
        "treeTypes": {
          "cactus": 1
        },
        "effects": {
          "particles": "dust",
          "ambient": "#FFEECC",
          "speedMultiplier": 0.85,
          "heatWave": true,
          "weather": [
            "clear",
            "sandstorm"
          ]
        },
        "spawnWeight": {
          "min": 1000,
          "max": 2000
        },
        "platform": {
          "floatingChanceMult": 0.9,
          "floatingGroundTypes": [
            "sand",
            "stone"
          ]
        }
      },
      "mountain": {
        "id": "mountain",
        "name": "å±±åœ°",
        "color": "#757575",
        "groundType": "stone",
        "decorations": {
          "ore_coal": 0.15,
          "ore_iron": 0.1,
          "ore_gold": 0.05,
          "ore_diamond": 0.02,
          "stalactite": 0.12,
          "crystal": 0.08,
          "lava_pool": 0.05,
          "cave_entrance": 0.03
        },
        "effects": {
          "particles": "sparkle",
          "ambient": "#666688",
          "darkness": 0.3,
          "weather": [
            "fog"
          ]
        },
        "spawnWeight": {
          "min": 1500,
          "max": 3000
        },
        "platform": {
          "floatingChanceMult": 1.1,
          "floatingGroundTypes": [
            "stone",
            "grass"
          ]
        }
      },
      "cave": {
        "id": "cave",
        "name": "çŸ¿æ´",
        "color": "#3B3B4F",
        "groundType": "stone",
        "decorations": {
          "ore_coal": 0.25,
          "ore_iron": 0.18,
          "ore_gold": 0.08,
          "ore_diamond": 0.05,
          "stalactite": 0.2,
          "crystal": 0.1,
          "lava_pool": 0.08,
          "cave_exit": 0.08
        },
        "effects": {
          "particles": "sparkle",
          "ambient": "#3B3B4F",
          "darkness": 0.45,
          "weather": [
            "fog"
          ]
        },
        "spawnWeight": {
          "min": 0,
          "max": 99999
        },
        "platform": {
          "floatingChanceMult": 0.6,
          "floatingGroundTypes": [
            "stone"
          ],
          "microPlatformChance": 0.25,
          "microPlatformPeriod": 2,
          "microPattern": "stair",
          "microPlatformType": "stone",
          "microPlatformMaxCount": 3,
          "microMaxRiseBlocks": 3,
          "microItemChance": 0.15,
          "fragileChance": 0.2,
          "fragileBreakDelay": 100
        }
      },
      "ocean": {
        "id": "ocean",
        "name": "æµ·æ»¨",
        "color": "#2196F3",
        "groundType": "sand",
        "decorations": {
          "palm_tree": 0.15,
          "shell": 0.2,
          "starfish": 0.15,
          "seaweed": 0.25,
          "boat": 0.05
        },
        "treeTypes": {
          "palm": 1
        },
        "effects": {
          "particles": "bubbles",
          "ambient": "#AAD4F5",
          "waterLevel": 150
        },
        "spawnWeight": {
          "min": 2000,
          "max": 4000
        },
        "platform": {
          "floatingChanceMult": 0.8,
          "floatingGroundTypes": [
            "sand",
            "grass"
          ]
        }
      },
      "nether": {
        "id": "nether",
        "name": "åœ°ç‹±",
        "color": "#8B0000",
        "groundType": "netherrack",
        "decorations": {
          "lava_pool": 0.15,
          "fire": 0.2,
          "soul_sand": 0.1,
          "nether_wart": 0.12,
          "basalt": 0.18,
          "lava_fall": 0.08
        },
        "effects": {
          "particles": "flames",
          "ambient": "#CC3333",
          "damage": 1,
          "speedMultiplier": 0.7
        },
        "spawnWeight": {
          "min": 3500,
          "max": 5000
        },
        "platform": {
          "floatingChanceMult": 1,
          "floatingGroundTypes": [
            "netherrack",
            "stone"
          ]
        }
      },
      "sky": {
        "id": "sky",
        "name": "äº‘ç«¯",
        "color": "#87CEEB",
        "groundType": "cloud",
        "decorations": {},
        "effects": {
          "particles": "sparkle",
          "ambient": "#9BD4FF",
          "weather": [
            "clear",
            "fog"
          ]
        },
        "spawnWeight": {
          "min": 0,
          "max": 99999
        }
      }
    }
  },
  "words/words-base.json": [
    {
      "en": "cat",
      "zh": "çŒ«"
    },
    {
      "en": "dog",
      "zh": "ç‹—"
    },
    {
      "en": "pig",
      "zh": "çŒª"
    },
    {
      "en": "duck",
      "zh": "é¸­"
    },
    {
      "en": "cow",
      "zh": "ç‰›"
    },
    {
      "en": "red",
      "zh": "çº¢è‰²"
    },
    {
      "en": "blue",
      "zh": "è“è‰²"
    },
    {
      "en": "green",
      "zh": "ç»¿è‰²"
    },
    {
      "en": "yellow",
      "zh": "é»„è‰²"
    },
    {
      "en": "one",
      "zh": "ä¸€"
    },
    {
      "en": "two",
      "zh": "äºŒ"
    },
    {
      "en": "three",
      "zh": "ä¸‰"
    },
    {
      "en": "apple",
      "zh": "è‹¹æœ"
    },
    {
      "en": "tree",
      "zh": "æ ‘"
    },
    {
      "en": "flower",
      "zh": "èŠ±"
    },
    {
      "en": "grass",
      "zh": "è‰"
    },
    {
      "en": "sky",
      "zh": "å¤©ç©º"
    }
  ]
};
  const originalFetch = window.fetch ? window.fetch.bind(window) : null;
  window.fetch = function(input, init){
    const url = typeof input === 'string' ? input : (input && input.url ? input.url : '');
    const key = url.replace(/^(\.\.\/)+/, '');
    if (data && Object.prototype.hasOwnProperty.call(data, key)) {
      const body = JSON.stringify(data[key]);
      return Promise.resolve(new Response(body, { status: 200, headers: { 'Content-Type': 'application/json' } }));
    }
    return originalFetch ? originalFetch(input, init) : Promise.reject(new Error('offline fetch blocked: ' + url));
  };

  const head = document.head;
  const originalAppend = head.appendChild.bind(head);
  head.appendChild = function(node){
    try {
      if (node && node.tagName === 'SCRIPT' && node.src && node.src.indexOf('words/vocabs/') !== -1) {
        setTimeout(() => { if (typeof node.onload === 'function') node.onload(); }, 0);
        return node;
      }
    } catch {}
    return originalAppend(node);
  };
})();
</script>
<!-- main.js æ¨¡å—åŒ–æ‹†åˆ† (åŸ main.js æŒ‰åŠŸèƒ½æ‹†åˆ†ä¸ºä»¥ä¸‹æ¨¡å—) -->
<script>
/**
 * 01-config.js - å…¨å±€çŠ¶æ€ã€å¸¸é‡ã€æ¨¡æ¿å®šä¹‰
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 1-578)
 */
const defaults = window.MMWG_DEFAULTS || {};
const storage = window.MMWG_STORAGE;
// start() finishes wiring input/UI handlers before gameplay loop can begin.
// This prevents "login shown but game loop already running" and avoids races on auto-login.
let bootReady = false;
const defaultGameConfig = defaults.gameConfig || {};
const defaultControls = defaults.controls || {};
const defaultLevels = defaults.levels || [];
const defaultWords = defaults.words || [];
const defaultSettings = defaults.settings || {};

async function loadJsonWithFallback(path, fallback) {
    try {
        const response = await fetch(path, { cache: "no-store" });
        if (!response.ok) {
            throw new Error("load failed");
        }
        return await response.json();
    } catch {
        return JSON.parse(JSON.stringify(fallback));
    }
}

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let gameConfig = JSON.parse(JSON.stringify(defaultGameConfig));
let keyBindings = { ...defaultControls };
let levels = [...defaultLevels];
let wordDatabase = [...defaultWords];
let settings = storage ? storage.loadJson("mmwg:settings", defaultSettings) : JSON.parse(JSON.stringify(defaultSettings));
let vocabState = storage ? storage.loadJson("mmwg:vocabState", { runCounts: {}, lastPackId: null }) : { runCounts: {}, lastPackId: null };
let progress = storage ? storage.loadJson("mmwg:progress", { vocab: {} }) : { vocab: {} };
let lastWord = null;
let wordPicker = null;
let paused = false;
let pausedByModal = false;
let startedOnce = false;
let vocabManifest = window.MMWG_VOCAB_MANIFEST || null;
let vocabPackOrder = [];
let vocabPacks = Object.create(null);
let vocabEngine = null;
let activeVocabPackId = null;
let loadedVocabFiles = Object.create(null);
let sessionWordCounts = Object.create(null);
let sessionCollectedWords = [];
let wordGates = [];
let wordMatchActive = false;
let wordMatchTimer = null;
let currentLearningChallenge = null;
let challengeTimerId = null;
let challengeDeadline = 0;
let challengeOrigin = null;
let challengePausedBefore = false;
let challengeModalEl = null;
let challengeQuestionEl = null;
let challengeOptionsEl = null;
let challengeInputWrapperEl = null;
let challengeInputEl = null;
let challengeTimerEl = null;
let challengeRepeatBtn = null;
let wordMatchScreenEl = null;
let matchLeftEl = null;
let matchRightEl = null;
let matchLinesEl = null;
let matchCountEl = null;
let matchTotalEl = null;
let matchSubmitBtn = null;
let matchResultEl = null;
let matchSubtitleEl = null;
let matchTimerEl = null;
let activeWordMatch = null;
let inventoryModalEl = null;
let inventoryContentEl = null;
let inventoryTabButtons = null;
let inventoryTab = "items";
let inventoryDropMode = false;
let profileModalEl = null;
let profileUsernameEl = null;
let profilePlaytimeEl = null;
let profileHighscoreEl = null;
let profileWordsEl = null;
let profileGamesEl = null;
let achievementsContainerEl = null;
let chestHintSeen = storage ? storage.loadJson("mmwg:hintChestSeen", false) : false;
let chestHintFramesLeft = 0;
const CHEST_HINT_FRAMES = 180;
let chestHintPos = null;
let audioCtx = null;
let audioUnlocked = false;
let speechReady = false;
let speechVoicesReady = false;
let speechPendingWord = null;
let speechPendingUnlockWord = null;
let speechPendingTimer = null;
let speechPendingAttempts = 0;
let ttsAudio = null;
let ttsSeqId = 0;
let bgmAudio = null;
let bgmReady = false;
let bgmPausedByVisibility = false;
const BGM_SOURCES = ["audio/minecraft-theme.mp3"];

let score = 0;
let levelScore = 0;
let runBestScore = 0;
let cameraX = 0;
let gameFrame = 0;
let currentLevelIdx = 0;
let playerHp = 3;
let playerMaxHp = 3;
let lastWordItemX = -Infinity;

const INVENTORY_TEMPLATE = {
    diamond: 0,
    pumpkin: 0,
    iron: 0,
    stick: 0,
    stone_sword: 1,
    iron_pickaxe: 0,
    bow: 1,
    arrow: 5,
    gunpowder: 0,
    rotten_flesh: 0,
    string: 0,
    ender_pearl: 0,
    dragon_egg: 0,
    flower: 0,
    mushroom: 0,
    coal: 0,
    gold: 0,
    shell: 0,
    starfish: 0
};
let inventory = { ...INVENTORY_TEMPLATE };
let selectedSlot = 0;
const HOTBAR_ITEMS = ["diamond", "pumpkin", "iron", "stick", "stone_sword", "iron_pickaxe", "bow", "arrow"];
const ITEM_LABELS = {
    diamond: "é’»çŸ³",
    pumpkin: "å—ç“œ",
    iron: "é“å—",
    stick: "æœ¨æ£",
    stone_sword: "çŸ³å‰‘",
    iron_pickaxe: "é“é•",
    bow: "å¼“",
    arrow: "ç®­çŸ¢",
    gunpowder: "ç«è¯",
    rotten_flesh: "è…è‚‰",
    string: "èœ˜è››ä¸",
    ender_pearl: "æœ«å½±çç ",
    dragon_egg: "é¾™è›‹",
    flower: "èŠ±æœµ",
    mushroom: "è˜‘è‡",
    coal: "ç…¤çŸ¿",
    gold: "é»„é‡‘",
    shell: "è´å£³",
    starfish: "æµ·æ˜Ÿ"
};
const ITEM_ICONS = {
    diamond: "ğŸ’",
    pumpkin: "ğŸƒ",
    iron: "ğŸ§±",
    stick: "ğŸ¥¢",
    stone_sword: "âš”ï¸",
    iron_pickaxe: "â›ï¸",
    bow: "ğŸ¹",
    arrow: "ğŸ¹",
    gunpowder: "ğŸ’¥",
    rotten_flesh: "ğŸ¥©",
    string: "ğŸ•¸ï¸",
    ender_pearl: "ğŸŸ£",
    dragon_egg: "ğŸ‰",
    flower: "ğŸŒ¸",
    mushroom: "ğŸ„",
    coal: "ğŸª¨",
    gold: "ğŸª™",
    shell: "ğŸš",
    starfish: "â­",
    hp: "â¤ï¸",
    max_hp: "ğŸ’–",
    score: "ğŸª™"
};
const INVENTORY_CATEGORIES = {
    items: ["diamond", "pumpkin", "stone_sword", "iron_pickaxe", "bow", "arrow"],
    materials: ["iron", "stick", "coal", "gold", "shell", "starfish", "gunpowder", "rotten_flesh", "string", "ender_pearl", "dragon_egg", "flower", "mushroom"],
    equipment: []
};
const SPEED_LEVELS = {
    slow: 0.8,
    normal: 1.0,
    fast: 1.3
};
const ACHIEVEMENTS = {
    first_word: { id: "first_word", name: "åˆè¯†è¯è¯­", desc: "å­¦ä¹ ç¬¬ä¸€ä¸ªè¯", icon: "ğŸ‰", target: 1 },
    words_10: { id: "words_10", name: "åè¯å…¥é—¨", desc: "å­¦ä¹  10 ä¸ªè¯", icon: "ğŸ“˜", target: 10 },
    words_50: { id: "words_50", name: "è¯è¯­è¿›é˜¶", desc: "å­¦ä¹  50 ä¸ªè¯", icon: "ğŸ“—", target: 50 },
    words_100: { id: "words_100", name: "è¯æµ·æ¢é™©", desc: "å­¦ä¹  100 ä¸ªè¯", icon: "ğŸ“™", target: 100 },
    words_500: { id: "words_500", name: "è¯è¯­å¤§å¸ˆ", desc: "å­¦ä¹  500 ä¸ªè¯", icon: "ğŸ…", target: 500 },
    pack_complete: { id: "pack_complete", name: "è¯åº“é€šå…³", desc: "å®Œæˆä¸€ä¸ªè¯åº“", icon: "ğŸ—‚ï¸", target: 1 },
    first_game: { id: "first_game", name: "é¦–æ¬¡å‡ºèˆª", desc: "å®Œæˆç¬¬ä¸€åœºæ¸¸æˆ", icon: "ğŸš€", target: 1 },
    score_1000: { id: "score_1000", name: "åƒåˆ†è¿›å‡»", desc: "ç´¯ç§¯ 1000 åˆ†", icon: "â­", target: 1000 },
    score_5000: { id: "score_5000", name: "çªç ´ 5000", desc: "ç´¯ç§¯ 5000 åˆ†", icon: "ğŸ†", target: 5000 },
    enemies_100: { id: "enemies_100", name: "æ–©å¦– 100", desc: "å‡»è´¥ 100 ä¸ªæ•Œäºº", icon: "âš”ï¸", target: 100 },
    chests_50: { id: "chests_50", name: "å¼€å® 50", desc: "æ‰“å¼€ 50 ä¸ªå®ç®±", icon: "ğŸ“¦", target: 50 },
    diamond_collector: { id: "diamond_collector", name: "é’»çŸ³æ”¶è—å®¶", desc: "æ”¶é›† 100 é¢—é’»çŸ³", icon: "ğŸ’", target: 100 },
    armor_collector: { id: "armor_collector", name: "ç›”ç”²æ”¶è—å®¶", desc: "æ”¶é›†å…¨éƒ¨ ç›”ç”²", icon: "ğŸ›¡ï¸", target: 6 }
};
const ACHIEVEMENT_MAP = {
    words: ["first_word", "words_10", "words_50", "words_100", "words_500"],
    enemies: ["enemies_100"],
    chests: ["chests_50"],
    score: ["score_1000", "score_5000"]
};
let currentAccount = null;
let autoSaveInterval = null;
let lastSaveTime = Date.now();
const TOOL_STATS = {
    stone_sword: { damage: 8 },
    iron_pickaxe: { damage: 6 }
};
const WEAPONS = {
    sword: {
        id: "sword",
        name: "çŸ³å‰‘",
        damage: 14,
        range: 55,
        cooldown: 18,
        knockback: 8,
        type: "melee",
        emoji: "âš”ï¸"
    },
    axe: {
        id: "axe",
        name: "æœ¨æ–§",
        damage: 20,
        range: 70,
        cooldown: 30,
        knockback: 12,
        type: "melee",
        emoji: "ğŸª“"
    },
    pickaxe: {
        id: "pickaxe",
        name: "é“é•",
        damage: 8,
        range: 40,
        cooldown: 180,
        knockback: 0,
        type: "dig",
        emoji: "â›ï¸",
        digHits: 3
    },
    bow: {
        id: "bow",
        name: "å¼“",
        damage: 12,
        range: 380,
        cooldown: 26,
        knockback: 5,
        type: "ranged",
        emoji: "ğŸ¹",
        chargeMax: 40
    }
};
const ARMOR_TYPES = {
    leather: {
        id: "leather",
        name: "çš®é©æŠ¤ç”²",
        defense: 1,
        rarity: "common",
        color: "#8B4513",
        description: "è½»ä¾¿æŠ¤å«"
    },
    chainmail: {
        id: "chainmail",
        name: "é“¾ç”²æŠ¤ç”²",
        defense: 2,
        rarity: "rare",
        color: "#A9A9A9",
        description: "åšå›ºçš„ç¯å½¢é‡‘å±"
    },
    iron: {
        id: "iron",
        name: "é“æŠ¤ç”²",
        defense: 3,
        rarity: "rare",
        color: "#C0C0C0",
        description: "æ ‡å‡†é˜²æŠ¤"
    },
    gold: {
        id: "gold",
        name: "é‡‘æŠ¤ç”²",
        defense: 2,
        rarity: "epic",
        color: "#FFD700",
        description: "åä¸½é˜²å¾¡"
    },
    diamond: {
        id: "diamond",
        name: "é’»çŸ³æŠ¤ç”²",
        defense: 4,
        rarity: "epic",
        color: "#00CED1",
        description: "å¼ºåŠ›å®ˆå«"
    },
    netherite: {
        id: "netherite",
        name: "ä¸‹ç•Œåˆé‡‘æŠ¤ç”²",
        defense: 5,
        rarity: "legendary",
        color: "#4A4A4A",
        description: "ä¼ è¯´åŠ æŠ¤"
    }
};
let playerEquipment = { armor: null, armorDurability: 0 };
let armorInventory = [];

const playerWeapons = {
    current: "sword",
    unlocked: ["sword", "bow", "pickaxe", "axe"],
    attackCooldown: 0,
    isCharging: false,
    chargeTime: 0,
    lastPressTs: 0,
    doublePressWindow: 220
};
const keys = { right: false, left: false };

let jumpBuffer = 0;
let coyoteTimer = 0;

let groundY = 530;
let blockSize = 50;
let canvasHeight = 600;
let cameraOffsetX = 300;
let mapBuffer = 1000;
let removeThreshold = 200;
let fallResetY = 800;

let player = null;
let platforms = [];
let trees = [];
let chests = [];
let items = [];
let enemies = [];
let golems = [];
const MAX_GOLEMS = 3;
let playerPositionHistory = [];
let projectiles = [];
let digHits = new Map();
let bossSpawned = false;
let bossArena = null;
let villageConfig = {};
let activeVillages = [];
let villageSpawnedForScore = {};
let playerInVillage = false;
let currentVillage = null;
let playerInvincibleTimer = 0;
let overlayMode = "start";
const START_OVERLAY_INTRO_MS = 1600;
const START_OVERLAY_HINT_HTML = "â¬…ï¸â¡ï¸ ç§»åŠ¨  â¬†ï¸ è·³(å¯äºŒæ®µè·³)<br>âš”ï¸ æ”»å‡»  ğŸ”„ åˆ‡æ¢æ­¦å™¨  ğŸ’ ä½¿ç”¨é’»çŸ³<br>ğŸ“¦ æ‰“å¼€å®ç®±  â›ï¸ é‡‡é›†";
let startOverlayTimer = 0;
let startOverlayReady = false;
let startOverlayActive = false;
let enemyKillStats = { total: 0 };
let repeatPauseState = "repeat";
const projectilePool = {
    arrows: [],
    snowballs: [],
    fireballs: [],
    getArrow(x, y, tx, ty) {
        let arrow = this.arrows.find(p => p.remove);
        if (arrow) {
            arrow.reset(x, y, tx, ty, 4);
        } else {
            arrow = new Arrow(x, y, tx, ty);
            this.arrows.push(arrow);
        }
        return arrow;
    },
    getSnowball(x, y, tx, ty) {
        let snowball = this.snowballs.find(p => p.remove);
        if (snowball) {
            snowball.reset(x, y, tx, ty, 3);
        } else {
            snowball = new Snowball(x, y, tx, ty);
            this.snowballs.push(snowball);
        }
        return snowball;
    },
    getFireball(x, y, tx, ty) {
        let fireball = this.fireballs.find(p => p.remove);
        if (fireball) {
            fireball.reset(x, y, tx, ty, 2);
        } else {
            fireball = new DragonFireball(x, y, tx, ty);
            this.fireballs.push(fireball);
        }
        return fireball;
    }
};

const DEFAULT_BIOME_CONFIGS = {
    forest: {
        id: "forest",
        name: "æ£®æ—",
        color: "#4CAF50",
        groundType: "grass",
        decorations: { tree: 0.3, bush: 0.2, flower: 0.25, mushroom: 0.1, vine: 0.15 },
        treeTypes: { oak: 0.5, birch: 0.3, dark_oak: 0.2 },
        effects: { particles: "leaves", ambient: "#88CC88", weather: ["clear", "rain", "fog"] },
        spawnWeight: { min: 0, max: 1000 }
    },
    snow: {
        id: "snow",
        name: "é›ªåœ°",
        color: "#FFFFFF",
        groundType: "snow",
        decorations: { spruce: 0.25, ice_spike: 0.1, snow_pile: 0.3, ice_block: 0.15 },
        treeTypes: { spruce: 0.7, pine: 0.3 },
        effects: { particles: "snowflakes", ambient: "#CCE6FF", speedMultiplier: 1.2, weather: ["snow"] },
        spawnWeight: { min: 500, max: 1500 }
    },
    desert: {
        id: "desert",
        name: "æ²™æ¼ ",
        color: "#FDD835",
        groundType: "sand",
        decorations: { cactus: 0.2, dead_bush: 0.15, rock: 0.1, bones: 0.05 },
        treeTypes: { cactus: 1.0 },
        effects: { particles: "dust", ambient: "#FFEECC", speedMultiplier: 0.85, heatWave: true, weather: ["clear", "sandstorm"] },
        spawnWeight: { min: 1000, max: 2000 }
    },
    mountain: {
        id: "mountain",
        name: "å±±åœ°",
        color: "#757575",
        groundType: "stone",
        decorations: { ore_coal: 0.15, ore_iron: 0.1, ore_gold: 0.05, ore_diamond: 0.02, stalactite: 0.12, crystal: 0.08, lava_pool: 0.05 },
        effects: { particles: "sparkle", ambient: "#666688", darkness: 0.3, weather: ["fog"] },
        spawnWeight: { min: 1500, max: 3000 }
    },
    ocean: {
        id: "ocean",
        name: "æµ·æ»¨",
        color: "#2196F3",
        groundType: "sand",
        decorations: { shell: 0.2, starfish: 0.15, seaweed: 0.35, boat: 0.05 },
        treeTypes: {},
        effects: { particles: "bubbles", ambient: "#AAD4F5", waterLevel: 150 },
        spawnWeight: { min: 2000, max: 4000 }
    },
    nether: {
        id: "nether",
        name: "åœ°ç‹±",
        color: "#8B0000",
        groundType: "netherrack",
        decorations: { lava_pool: 0.15, fire: 0.2, soul_sand: 0.1, nether_wart: 0.12, basalt: 0.18, lava_fall: 0.08 },
        effects: { particles: "flames", ambient: "#CC3333", damage: 1, onEnterOnly: true, speedMultiplier: 0.7 },
        spawnWeight: { min: 3500, max: 5000 }
    }
};

let biomeConfigs = JSON.parse(JSON.stringify(DEFAULT_BIOME_CONFIGS));
let currentBiome = "forest";
let biomeTransitionX = 0;
let decorations = [];
let particles = [];
let weatherState = { type: "clear", timer: 0 };
let netherEntryPenaltyArmed = true;
const MAX_DECORATIONS_ONSCREEN = 60;
const DEFAULT_BIOME_SWITCH = {
    stepScore: 200,
    order: ["forest", "snow", "desert", "mountain", "ocean", "nether"],
    unlockScore: {
        forest: 0,
        snow: 200,
        desert: 400,
        mountain: 600,
        ocean: 800,
        nether: 2000
    }
};
let biomeSwitchConfig = JSON.parse(JSON.stringify(DEFAULT_BIOME_SWITCH));
const DEFAULT_DIFFICULTY_CONFIG = {
    damageUnit: 20,
    invincibleFrames: 120,
    tiers: [
        { name: "æ–°æ‰‹", minScore: 0, maxScore: 500, enemyDamage: 0.8, enemyHp: 0.85, enemySpawn: 0.75, chestSpawn: 1.1, chestRareBoost: 0.25, chestRollBonus: 0.08, scoreMultiplier: 1.0 },
        { name: "ç®€å•", minScore: 500, maxScore: 1500, enemyDamage: 1.0, enemyHp: 1.0, enemySpawn: 0.95, chestSpawn: 1.0, chestRareBoost: 0.1, chestRollBonus: 0.04, scoreMultiplier: 1.0 },
        { name: "æ™®é€š", minScore: 1500, maxScore: 3000, enemyDamage: 1.15, enemyHp: 1.1, enemySpawn: 1.05, chestSpawn: 0.95, chestRareBoost: 0.0, chestRollBonus: 0.0, scoreMultiplier: 1.05 },
        { name: "å›°éš¾", minScore: 3000, maxScore: 5000, enemyDamage: 1.4, enemyHp: 1.25, enemySpawn: 1.2, chestSpawn: 0.9, chestRareBoost: -0.1, chestRollBonus: -0.02, scoreMultiplier: 1.1 },
        { name: "åœ°ç‹±", minScore: 5000, maxScore: 999999, enemyDamage: 1.8, enemyHp: 1.5, enemySpawn: 1.35, chestSpawn: 0.85, chestRareBoost: -0.2, chestRollBonus: -0.04, scoreMultiplier: 1.2 }
    ],
    dda: {
        enabled: true,
        lowHpThreshold: 1,
        lowHpEnemyDamage: 0.7,
        lowHpEnemySpawn: 0.8,
        lowHpChestBonus: 0.2,
        noHitFramesForBoost: 720,
        noHitEnemyDamage: 1.15,
        noHitEnemySpawn: 1.1,
        maxTotalEnemyDamage: 2.2,
        maxTotalEnemySpawn: 1.6
    }
};
const DEFAULT_CHEST_RARITIES = [
    { id: "common", weight: 60 },
    { id: "rare", weight: 30 },
    { id: "epic", weight: 8 },
    { id: "legendary", weight: 2 }
];
const DEFAULT_CHEST_TABLES = {
    common: [
        { item: "iron", weight: 18, min: 1, max: 3 },
        { item: "pumpkin", weight: 12, min: 1, max: 2 },
        { item: "stick", weight: 12, min: 1, max: 3 },
        { item: "diamond", weight: 4, min: 1, max: 1 },
        { item: "coal", weight: 10, min: 1, max: 3 },
        { item: "arrow", weight: 10, min: 2, max: 6 },
        { item: "rotten_flesh", weight: 8, min: 1, max: 3 },
        { item: "flower", weight: 6, min: 1, max: 2 },
        { item: "mushroom", weight: 6, min: 1, max: 2 },
        { item: "hp", weight: 8, min: 1, max: 1 },
        { item: "score", weight: 7, min: 10, max: 25 }
    ],
    rare: [
        { item: "diamond", weight: 6, min: 1, max: 1 },
        { item: "stone_sword", weight: 7, min: 1, max: 1 },
        { item: "iron_pickaxe", weight: 5, min: 1, max: 1 },
        { item: "ender_pearl", weight: 4, min: 1, max: 1 },
        { item: "iron", weight: 8, min: 2, max: 4 },
        { item: "arrow", weight: 8, min: 4, max: 8 },
        { item: "hp", weight: 8, min: 1, max: 1 },
        { item: "score", weight: 8, min: 20, max: 40 }
    ],
    epic: [
        { item: "max_hp", weight: 6, min: 1, max: 1 },
        { item: "diamond", weight: 6, min: 1, max: 2 },
        { item: "ender_pearl", weight: 5, min: 1, max: 2 },
        { item: "iron_pickaxe", weight: 6, min: 1, max: 1 },
        { item: "score", weight: 8, min: 40, max: 80 }
    ],
    legendary: [
        { item: "max_hp", weight: 8, min: 1, max: 2 },
        { item: "diamond", weight: 8, min: 2, max: 3 },
        { item: "dragon_egg", weight: 4, min: 1, max: 1 },
        { item: "ender_pearl", weight: 6, min: 2, max: 3 },
        { item: "score", weight: 10, min: 80, max: 150 }
    ]
};
const DEFAULT_CHEST_ROLLS = {
    twoDropChance: 0.45,
    threeDropChance: 0.15
};

const LEARNING_CONFIG = {
    challenge: {
        timeLimit: 15000,
        baseOptions: 3,
        rewards: {
            correct: { score: 20, diamond: 1 },
            wrong: { scorePenalty: 8 }
        }
    },
    wordGate: {
        spawnChance: 0.08,
        minScore: 500
    },
    wordMatch: {
        wordCount: 5,
        timeLimit: 30000,
        minCorrectToRevive: 4,
        reviveHp: 3,
        bonusPerMatch: 10
    }
};
let floatingTexts = [];
let lastGenX = 0;
let difficultyState = null;
let difficultyConfigCache = null;
let lootConfigCache = null;
let lastDamageFrame = 0;

</script>
<script>
/**
 * 02-utils.js - é€šç”¨å·¥å…·å‡½æ•°
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 580-597)
 */
function mergeDeep(target, source) {
    const output = Array.isArray(target) ? [...target] : { ...target };
    if (source && typeof source === "object" && !Array.isArray(source)) {
        Object.keys(source).forEach(key => {
            const srcValue = source[key];
            if (srcValue && typeof srcValue === "object" && !Array.isArray(srcValue)) {
                output[key] = mergeDeep(output[key] || {}, srcValue);
            } else {
                output[key] = srcValue;
            }
        });
    }
    return output;
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function parseKeyCodes(raw) {
    if (!raw) return null;
    const parts = String(raw).split(",").map(s => s.trim()).filter(Boolean);
    if (parts.length !== 5) return null;
    return parts;
}

</script>
<script>
/**
 * 03-audio.js - éŸ³é¢‘ç³»ç»Ÿ (BGMã€TTSã€éŸ³æ•ˆ)
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 599-824)
 */
function ensureAudioContext() {
    if (audioCtx) return audioCtx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return null;
    audioCtx = new Ctx();
    return audioCtx;
}

function ensureSpeechReady() {
    if (!("speechSynthesis" in window)) return false;
    try {
        if (window.speechSynthesis.getVoices) {
            window.speechSynthesis.getVoices();
        }
        window.speechSynthesis.resume();
        speechReady = true;
        return true;
    } catch {
        return false;
    }
}

function ensureSpeechVoices() {
    if (!("speechSynthesis" in window)) return false;
    const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
    if (voices && voices.length) {
        speechVoicesReady = true;
        return true;
    }
    if (!ensureSpeechVoices.bound && window.speechSynthesis.addEventListener) {
        ensureSpeechVoices.bound = true;
        window.speechSynthesis.addEventListener("voiceschanged", () => {
            const updated = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
            if (updated && updated.length) {
                speechVoicesReady = true;
                if (speechPendingWord) {
                    const pending = speechPendingWord;
                    speechPendingWord = null;
                    setTimeout(() => {
                        speakWord(pending);
                    }, 0);
                }
            }
        });
    }
    return false;
}

function pickVoice(langPrefix) {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
    if (!voices || !voices.length) return null;
    const lang = String(langPrefix || "").toLowerCase();
    return voices.find(v => String(v.lang || "").toLowerCase().startsWith(lang)) || null;
}

function getNativeTts() {
    try {
        const Cap = window.Capacitor;
        if (!Cap || typeof Cap.isNativePlatform !== "function") return null;
        if (!Cap.isNativePlatform()) return null;
        if (typeof Cap.isPluginAvailable === "function" && !Cap.isPluginAvailable("TextToSpeech")) return null;

        const plugins = Cap.Plugins || {};
        const existing = plugins.TextToSpeech;
        if (existing && typeof existing.speak === "function") return existing;

        if (typeof Cap.registerPlugin === "function") {
            const registered = Cap.registerPlugin("TextToSpeech");
            if (registered && typeof registered.speak === "function") return registered;
        }

        return null;
    } catch {
        return null;
    }
}

function speakNativeTts(tts, text, lang, rate, queueStrategy) {
    if (!tts || typeof tts.speak !== "function") return false;
    if (!text) return false;
    try {
        const result = tts.speak({
            text: String(text),
            lang: String(lang || ""),
            rate: typeof rate === "number" ? rate : 1.0,
            pitch: 1.0,
            volume: 1.0,
            category: "ambient",
            // Ensure EN->ZH does not cancel EN on Android (default may flush).
            // Capacitor TextToSpeech expects string strategies like QUEUE_ADD/QUEUE_FLUSH.
            queueStrategy: queueStrategy || "QUEUE_ADD"
        });
        // Some implementations return a Promise.
        if (result && typeof result.catch === "function") {
            result.catch(() => {});
        }
        return true;
    } catch {
        return false;
    }
}

function normalizeSpeechText(primary, fallback) {
    const main = primary == null ? "" : String(primary);
    const alt = fallback == null ? "" : String(fallback);
    const trimmed = main.trim();
    if (trimmed) return trimmed;
    const altTrimmed = alt.trim();
    return altTrimmed || "";
}

function buildOnlineTtsUrl(text, lang) {
    const safeLang = String(lang || "").toLowerCase().startsWith("zh") ? "zh-CN" : "en";
    return `https://translate.googleapis.com/translate_tts?ie=UTF-8&client=tw-ob&tl=${encodeURIComponent(safeLang)}&q=${encodeURIComponent(text)}`;
}

function playOnlineTtsSequence(sequence) {
    const items = Array.isArray(sequence) ? sequence.filter(it => it && it.text) : [];
    if (!items.length) return false;

    ttsSeqId += 1;
    const seq = ttsSeqId;

    if (!ttsAudio) {
        ttsAudio = new Audio();
        ttsAudio.preload = "auto";
        ttsAudio.volume = 1;
    }

    const playAt = idx => {
        if (seq !== ttsSeqId) return;
        const item = items[idx];
        if (!item) return;

        const url = buildOnlineTtsUrl(item.text, item.lang);
        try {
            ttsAudio.onended = () => playAt(idx + 1);
            ttsAudio.onerror = () => playAt(idx + 1);
            try { ttsAudio.pause(); } catch {}
            try { ttsAudio.currentTime = 0; } catch {}
            ttsAudio.src = url;
            const playPromise = ttsAudio.play();
            if (playPromise && typeof playPromise.catch === "function") {
                playPromise.catch(() => {});
            }
        } catch {
        }
    };

    playAt(0);
    return true;
}

function setupBgm() {
    if (bgmAudio) return bgmAudio;
    const audio = new Audio();
    audio.loop = true;
    audio.preload = "auto";
    audio.volume = 0.35;
    const src = BGM_SOURCES.find(Boolean);
    if (src) audio.src = src;
    bgmAudio = audio;
    bgmReady = !!src;
    return bgmAudio;
}

function applyBgmSetting() {
    setupBgm();
    if (!bgmAudio) return;
    const enabled = !!settings.musicEnabled;
    if (!enabled) {
        try { bgmAudio.pause(); } catch {}
        return;
    }
    if (!audioUnlocked) return;
    const playPromise = bgmAudio.play();
    if (playPromise && typeof playPromise.catch === "function") {
        playPromise.catch(() => {});
    }
}

function unlockAudio() {
    audioUnlocked = true;
    const ctx = ensureAudioContext();
    if (ctx && ctx.state === "suspended") {
        try { ctx.resume(); } catch {}
    }
    ensureSpeechReady();

    // Some browsers/WebViews block TTS until the first user gesture.
    // If a word was queued before unlock, speak it once unlock happens.
    if (settings.speechEnabled && speechPendingUnlockWord) {
        const pending = speechPendingUnlockWord;
        speechPendingUnlockWord = null;
        setTimeout(() => {
            if (pending && settings.speechEnabled) speakWord(pending);
        }, 0);
    }
    applyBgmSetting();
}

function wireAudioUnlock() {
    if (wireAudioUnlock.bound) return;
    wireAudioUnlock.bound = true;
    document.addEventListener("pointerdown", unlockAudio, { passive: true });
    document.addEventListener("touchstart", unlockAudio, { passive: true });
    document.addEventListener("keydown", unlockAudio);
}

function playHitSfx(intensity = 1) {
    const ctx = ensureAudioContext();
    if (!ctx) return;
    const now = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const freq = 180 + Math.min(1, Math.max(0, intensity)) * 180;
    osc.type = "square";
    osc.frequency.setValueAtTime(freq, now);
    gain.gain.setValueAtTime(0.001, now);
    gain.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now);
    osc.stop(now + 0.16);
}

</script>
<script>
/**
 * 04-weapons.js - æ­¦å™¨ä¸æˆ˜æ–—ç³»ç»Ÿ
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 826-965)
 */
function getArrowCount() {
    return Number(inventory.arrow) || 0;
}

function unlockWeapon(id) {
    if (!WEAPONS[id]) return false;
    if (playerWeapons.unlocked.includes(id)) return false;
    playerWeapons.unlocked.push(id);
    showToast(`ğŸ‰ è§£é”æ­¦å™¨: ${WEAPONS[id].emoji} ${WEAPONS[id].name}`);
    updateWeaponUI();
    return true;
}

function syncWeaponsFromInventory() {
    if ((inventory.stone_sword || 0) > 0) unlockWeapon("sword");
    if ((inventory.iron_pickaxe || 0) > 0) unlockWeapon("axe");
    if ((inventory.iron_pickaxe || 0) > 0) unlockWeapon("pickaxe");
    if ((inventory.bow || 0) > 0) unlockWeapon("bow");
}

function switchWeapon() {
    const list = playerWeapons.unlocked;
    if (!list.length) return;
    if (list.length === 1) {
        showToast("âš ï¸ åªæœ‰ä¸€ç§æ­¦å™¨");
        return;
    }
    const idx = list.indexOf(playerWeapons.current);
    const nextIdx = idx >= 0 ? (idx + 1) % list.length : 0;
    playerWeapons.current = list[nextIdx];
    playerWeapons.attackCooldown = 0;
    playerWeapons.isCharging = false;
    playerWeapons.chargeTime = 0;
    const weapon = WEAPONS[playerWeapons.current];
    showToast(`âš”ï¸ ${weapon.emoji} ${weapon.name}`);
    updateWeaponUI();
}

function updateWeaponUI() {
    const el = document.getElementById("weapon-info");
    if (!el) return;
    const weapon = WEAPONS[playerWeapons.current] || WEAPONS.sword;
    const arrows = getArrowCount();
    const arrowText = weapon.type === "ranged" ? ` | ğŸ¹ ${arrows}` : "";
    el.innerText = `æ­¦å™¨: ${weapon.emoji} ${weapon.name}${arrowText}`;
}

function startBowCharge() {
    const weapon = WEAPONS.bow;
    if (playerWeapons.attackCooldown > 0) return;
    if (getArrowCount() <= 0) {
        showToast("âŒ æ²¡æœ‰ç®­ï¼");
        return;
    }
    playerWeapons.isCharging = true;
    playerWeapons.chargeTime = 0;
}

function releaseBowShot(forceCharge = null) {
    const weapon = WEAPONS.bow;
    if (playerWeapons.attackCooldown > 0) return;
    if (getArrowCount() <= 0) {
        showToast("âŒ æ²¡æœ‰ç®­ï¼");
        return;
    }
    const ratio = forceCharge != null ? forceCharge : Math.min(1, playerWeapons.chargeTime / weapon.chargeMax);
    const charge = clamp(ratio, 0.2, 1);
    const dir = player.facingRight ? 1 : -1;
    const startX = player.facingRight ? player.x + player.width : player.x;
    const startY = player.y + player.height * 0.4;
    const targetX = startX + dir * weapon.range;
    const targetY = startY - 20 * charge;
    const speed = 4 + charge * 4;
    const damage = Math.round(weapon.damage * (0.6 + charge * 0.9));
    const arrow = new Arrow(startX, startY, targetX, targetY, "player", speed, damage);
    projectiles.push(arrow);
    inventory.arrow = Math.max(0, (inventory.arrow || 0) - 1);
    updateInventoryUI();
    playerWeapons.attackCooldown = weapon.cooldown;
    playerWeapons.isCharging = false;
    playerWeapons.chargeTime = 0;
}

function digGroundBlock() {
    const weapon = WEAPONS.pickaxe;
    const dir = player.facingRight ? 1 : -1;
    const targetX = player.x + (dir > 0 ? player.width + 6 : -6);
    const blockX = Math.floor(targetX / blockSize) * blockSize;
    const key = `${blockX}`;
    const hit = (digHits.get(key) || 0) + 1;
    digHits.set(key, hit);
    showFloatingText(`â›ï¸ ${hit}/${weapon.digHits}`, blockX + blockSize / 2, groundY - 40);

    if (hit < weapon.digHits) {
        playerWeapons.attackCooldown = weapon.cooldown;
        return;
    }

    const idx = platforms.findIndex(p => p.y === groundY && blockX >= p.x && blockX < p.x + p.width);
    if (idx === -1) {
        playerWeapons.attackCooldown = weapon.cooldown;
        return;
    }
    const p = platforms[idx];
    const leftWidth = blockX - p.x;
    const rightStart = blockX + blockSize;
    const rightWidth = (p.x + p.width) - rightStart;
    platforms.splice(idx, 1);
    if (leftWidth > 0) platforms.push(new Platform(p.x, p.y, leftWidth, p.height, p.type));
    if (rightWidth > 0) platforms.push(new Platform(rightStart, p.y, rightWidth, p.height, p.type));
    digHits.delete(key);
    showFloatingText("ğŸ•³ï¸ æ·±å‘", blockX + blockSize / 2, groundY - 50);
    playerWeapons.attackCooldown = weapon.cooldown;
}

function performMeleeAttack(weapon) {
    if (player.isAttacking) return;
    player.isAttacking = true;
    player.attackTimer = Math.max(12, Math.floor(weapon.cooldown * 0.6));
    const range = weapon.range;
    const ax = player.facingRight ? player.x + player.width : player.x - range;
    const ay = player.y;
    const dmg = weapon.damage;

    trees.forEach(t => {
        if (rectIntersect(ax, ay, range, player.height, t.x, t.y, t.width, t.height)) {
            t.hit();
        }
    });

    enemies.forEach(e => {
        if (rectIntersect(ax, ay, range, player.height, e.x, e.y, e.width, e.height)) {
            if (e.takeDamage) e.takeDamage(dmg);
            else e.hp -= dmg;
            showFloatingText(`-${dmg}`, e.x, e.y);
        }
    });

    playerWeapons.attackCooldown = weapon.cooldown;
}

</script>
<script>
/**
 * 05-difficulty.js - éš¾åº¦ç³»ç»Ÿä¸åŠ¨æ€è°ƒæ•´
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 967-1100)
 */
function getProgressScore() {
    return runBestScore;
}

function getDifficultyConfig() {
    if (difficultyConfigCache) return difficultyConfigCache;
    const cfg = gameConfig?.difficulty || {};
    difficultyConfigCache = mergeDeep(DEFAULT_DIFFICULTY_CONFIG, cfg);
    return difficultyConfigCache;
}

function getDifficultyTier(scoreValue) {
    const cfg = getDifficultyConfig();
    const tiers = Array.isArray(cfg.tiers) ? cfg.tiers : [];
    if (!tiers.length) return { name: "æ™®é€š", minScore: 0, maxScore: 999999, enemyDamage: 1, enemyHp: 1, enemySpawn: 1, chestSpawn: 1, chestRareBoost: 0, chestRollBonus: 0, scoreMultiplier: 1 };
    // Allow selecting a fixed difficulty tier from settings (otherwise follow score tiers).
    const selected = String(settings?.difficultySelection || "auto");
    if (selected && selected !== "auto") {
        const fixed = tiers.find(t => String(t?.name || "") === selected);
        if (fixed) return fixed;
    }
    const s = Number(scoreValue) || 0;
    const found = tiers.find(t => s >= (t.minScore ?? 0) && s < (t.maxScore ?? Number.MAX_SAFE_INTEGER));
    return found || tiers[tiers.length - 1];
}

function computeDifficultyState() {
    const cfg = getDifficultyConfig();
    const tiers = Array.isArray(cfg.tiers) ? cfg.tiers : [];
    const score = getProgressScore();
    const tier = getDifficultyTier(score);
    const dda = cfg.dda || {};
    let enemyDamageMult;
    let enemyHpMult;
    let enemySpawnMult;
    let chestSpawnMult;
    let chestRareBoost = Number(tier.chestRareBoost) || 0;
    let chestRollBonus = Number(tier.chestRollBonus) || 0;
    const scoreMultiplier = Number(tier.scoreMultiplier) || 1;
    const selected = String(settings?.difficultySelection || "auto");
    const tierIdx = tiers.indexOf(tier);
    const nextTier = tierIdx >= 0 ? tiers[tierIdx + 1] : null;

    if (selected === "auto" && nextTier && (tier.maxScore ?? 999999) < 999999) {
        const minScore = Number(tier.minScore ?? 0);
        const maxScore = Number(tier.maxScore ?? 999999);
        const range = maxScore - minScore;
        const t = range > 0 ? clamp((score - minScore) / range, 0, 1) : 0;
        enemyDamageMult = (Number(tier.enemyDamage) || 1) +
            ((Number(nextTier.enemyDamage) || 1) - (Number(tier.enemyDamage) || 1)) * t;
        enemyHpMult = (Number(tier.enemyHp) || 1) +
            ((Number(nextTier.enemyHp) || 1) - (Number(tier.enemyHp) || 1)) * t;
        enemySpawnMult = (Number(tier.enemySpawn) || 1) +
            ((Number(nextTier.enemySpawn) || 1) - (Number(tier.enemySpawn) || 1)) * t;
        chestSpawnMult = (Number(tier.chestSpawn) || 1) +
            ((Number(nextTier.chestSpawn) || 1) - (Number(tier.chestSpawn) || 1)) * t;
    } else {
        enemyDamageMult = Number(tier.enemyDamage) || 1;
        enemyHpMult = Number(tier.enemyHp) || 1;
        enemySpawnMult = Number(tier.enemySpawn) || 1;
        chestSpawnMult = Number(tier.chestSpawn) || 1;
    }

    if (settings.learningMode) {
        enemyDamageMult *= 0.85;
    }

    if (dda.enabled) {
        const lowHpThreshold = Number(dda.lowHpThreshold ?? 1);
        if (playerHp <= lowHpThreshold) {
            enemyDamageMult *= Number(dda.lowHpEnemyDamage ?? 0.7);
            enemySpawnMult *= Number(dda.lowHpEnemySpawn ?? 0.8);
            chestRareBoost += Number(dda.lowHpChestBonus ?? 0.2);
            chestSpawnMult *= 1.08;
            chestRollBonus += 0.05;
        }
        const noHitFrames = Number(dda.noHitFramesForBoost ?? 720);
        if (gameFrame - lastDamageFrame > noHitFrames) {
            enemyDamageMult *= Number(dda.noHitEnemyDamage ?? 1.15);
            enemySpawnMult *= Number(dda.noHitEnemySpawn ?? 1.1);
        }
        const maxDamage = Number(dda.maxTotalEnemyDamage ?? 2.2);
        const maxSpawn = Number(dda.maxTotalEnemySpawn ?? 1.6);
        enemyDamageMult = clamp(enemyDamageMult, 0.4, maxDamage);
        enemySpawnMult = clamp(enemySpawnMult, 0.4, maxSpawn);
    }

    return {
        name: tier.name || "æ™®é€š",
        minScore: tier.minScore ?? 0,
        maxScore: tier.maxScore ?? 999999,
        enemyDamageMult,
        enemyHpMult,
        enemySpawnMult,
        chestSpawnMult,
        chestRareBoost,
        chestRollBonus,
        scoreMultiplier
    };
}

function updateDifficultyState(force = false) {
    const next = computeDifficultyState();
    const changed = !difficultyState || difficultyState.name !== next.name;
    difficultyState = next;
    if (changed || force) {
        const el = document.getElementById("difficulty-info");
        if (el) el.innerText = `éš¾åº¦: ${next.name}`;
        if (changed && !force) showToast(`âš”ï¸ éš¾åº¦è°ƒæ•´ï¼š${next.name}`);
    }
}

function getDifficultyState() {
    if (!difficultyState) updateDifficultyState(true);
    return difficultyState;
}

function getLootConfig() {
    if (lootConfigCache) return lootConfigCache;
    const cfg = gameConfig?.loot || {};
    const chestTables = mergeDeep(DEFAULT_CHEST_TABLES, cfg.chestTables || {});
    const chestRarities = Array.isArray(cfg.chestRarities) && cfg.chestRarities.length ? cfg.chestRarities : DEFAULT_CHEST_RARITIES;
    const chestRolls = mergeDeep(DEFAULT_CHEST_ROLLS, cfg.chestRolls || {});
    lootConfigCache = { chestTables, chestRarities, chestRolls };
    return lootConfigCache;
}

function resetInventory() {
    inventory = { ...INVENTORY_TEMPLATE };
    playerEquipment = { armor: null, armorDurability: 0 };
    armorInventory = [];
    updateArmorUI();
}

function resetProjectiles() {
    projectiles = [];
    projectilePool.arrows.forEach(p => { p.remove = true; });
    projectilePool.snowballs.forEach(p => { p.remove = true; });
    projectilePool.fireballs.forEach(p => { p.remove = true; });
}

function getEnemyConfig() {
    const base = {
        maxOnScreen: 8,
        spawnChance: 0.3,
        difficultyThresholds: [500, 1000, 2000, 3000],
        bossSpawnScore: 5000
    };
    return mergeDeep(base, gameConfig.enemies || {});
}

function getGolemConfig() {
    const base = {
        maxCount: MAX_GOLEMS,
        ironGolem: { hp: 100, damage: 20, speed: 1.5 },
        snowGolem: { hp: 50, damage: 10, speed: 2.0 }
    };
    return mergeDeep(base, gameConfig.golems || {});
}

</script>
<script>
/**
 * 06-biome.js - ç”Ÿç‰©ç¾¤ç³»ä¸å¤©æ°”ç³»ç»Ÿ
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 1102-1243)
 */
function normalizeBiomeBundle(raw) {
    const out = raw && typeof raw === "object" ? raw : {};
    const switchCfg = out.switch && typeof out.switch === "object" ? out.switch : (out._switch && typeof out._switch === "object" ? out._switch : {});
    let biomes = out.biomes && typeof out.biomes === "object" ? out.biomes : out;
    if (biomes.switch) {
        const { switch: _ignored, ...rest } = biomes;
        biomes = rest;
    }
    if (!biomes || typeof biomes !== "object" || !biomes.forest) {
        return { biomes: JSON.parse(JSON.stringify(DEFAULT_BIOME_CONFIGS)), switch: JSON.parse(JSON.stringify(DEFAULT_BIOME_SWITCH)) };
    }
    return { biomes, switch: mergeDeep(DEFAULT_BIOME_SWITCH, switchCfg) };
}

function getBiomeById(id) {
    return biomeConfigs[id] || biomeConfigs.forest;
}

function getBiomeSwitchConfig() {
    const cfg = biomeSwitchConfig && typeof biomeSwitchConfig === "object" ? biomeSwitchConfig : DEFAULT_BIOME_SWITCH;
    const stepFromSettings = Number(settings?.biomeSwitchStepScore);
    const stepScore = isFinite(stepFromSettings) && stepFromSettings >= 50 ? stepFromSettings : (Number(cfg.stepScore) || 200);
    return { ...cfg, stepScore };
}

function getBiomeIdForScore(scoreValue) {
    const cfg = getBiomeSwitchConfig();
    const step = Math.max(1, Number(cfg.stepScore) || 200);
    const cycle = Math.floor((Number(scoreValue) || 0) / step);
    const order = (cfg.order || []).filter(id => biomeConfigs[id]);
    const baseOrder = order.length ? order : Object.keys(biomeConfigs);
    if (!baseOrder.length) return "forest";
    const unlock = cfg.unlockScore || {};
    const unlocked = baseOrder.filter(id => (Number(scoreValue) || 0) >= (Number(unlock[id]) || 0));
    const eligible = unlocked.length ? unlocked : [baseOrder[0]];
    return eligible[cycle % eligible.length];
}

function selectBiome(x, scoreValue) {
    let available = Object.values(biomeConfigs).filter(b => scoreValue >= b.spawnWeight.min && scoreValue <= b.spawnWeight.max);
    if (available.length < 2) {
        available = Object.values(biomeConfigs);
    }
    if (!available.length) return biomeConfigs.forest;
    const biomeLength = 2000 * worldScale.x;
    const idx = Math.floor(x / biomeLength) % available.length;
    return available[idx];
}

function updateCurrentBiome() {
    const nextBiome = getBiomeById(getBiomeIdForScore(getProgressScore()));
    if (nextBiome.id !== currentBiome) {
        currentBiome = nextBiome.id;
        biomeTransitionX = player.x;
        showToast(`ğŸŒ è¿›å…¥${nextBiome.name}ç¾¤ç³»`);
        updateWeatherForBiome(nextBiome);
        const info = document.getElementById("level-info");
        if (info) info.innerText = `ç”Ÿæ€: ${nextBiome.name}`;

        // === v1.6.3 æ–°å¢ï¼šå»¶è¿Ÿè§¦å‘å¤ä¹  ===
        if (settings.reviewOnBiomeSwitch) {
            // å»¶è¿Ÿ1.5ç§’ï¼Œè®© biome åˆ‡æ¢åŠ¨ç”»å®Œæˆ
            setTimeout(() => maybeShowReview(), 1500);
        }

        if (currentBiome === "nether" && netherEntryPenaltyArmed) {
            playerHp = Math.max(0, playerHp - 1);
            updateHpUI();
            showFloatingText("ğŸ”¥ -1â¤ï¸", player.x, player.y - 20);
            netherEntryPenaltyArmed = false;
            if (playerHp <= 0) {
                paused = true;
                showToast("ğŸ’€ ç”Ÿå‘½è€—å°½");
                setOverlay(true, "pause");
            }
        }
        if (currentBiome !== "nether") {
            netherEntryPenaltyArmed = true;
        }
    }
}

function updateWeatherForBiome(biome) {
    const options = biome.effects?.weather || ["clear"];
    weatherState.type = options[Math.floor(Math.random() * options.length)];
    weatherState.timer = 600 + Math.floor(Math.random() * 600);
}

function applyBiomeEffectsToPlayer() {
    const biome = getBiomeById(currentBiome);
    const speedMult = biome.effects?.speedMultiplier || 1;
    let nextSpeed = player.baseSpeed * speedMult;
    if (biome.effects?.waterLevel && player.y + player.height > biome.effects.waterLevel) {
        nextSpeed *= 0.65;
    }
    player.speed = nextSpeed;
    if (biome.effects?.damage && !biome.effects.onEnterOnly) {
        if (gameFrame % 90 === 0) {
            damagePlayer(biome.effects.damage, player.x, 30);
        }
    }
}

function tickWeather() {
    weatherState.timer--;
    if (weatherState.timer <= 0) {
        updateWeatherForBiome(getBiomeById(currentBiome));
    }
}

function spawnBiomeParticles() {
    const biome = getBiomeById(currentBiome);
    const baseX = cameraX + Math.random() * canvas.width;
    if (biome.effects?.particles === "snowflakes" && Math.random() < 0.2) {
        particles.push(typeof snowflakePool !== "undefined" ? snowflakePool.acquire(baseX, -10) : new Snowflake(baseX, -10));
    } else if (biome.effects?.particles === "leaves" && Math.random() < 0.15) {
        particles.push(typeof leafPool !== "undefined" ? leafPool.acquire(baseX, -10) : new LeafParticle(baseX, -10));
    } else if (biome.effects?.particles === "dust" && Math.random() < 0.2) {
        const py = Math.random() * canvas.height;
        particles.push(typeof dustPool !== "undefined" ? dustPool.acquire(baseX, py) : new DustParticle(baseX, py));
    } else if (biome.effects?.particles === "flames" && Math.random() < 0.2) {
        particles.push(new EmberParticle(baseX, canvas.height - 50));
    } else if (biome.effects?.particles === "bubbles" && Math.random() < 0.2) {
        particles.push(new BubbleParticle(baseX, canvas.height - 20));
    } else if (biome.effects?.particles === "sparkle" && Math.random() < 0.15) {
        particles.push(new SparkleParticle(baseX, Math.random() * canvas.height));
    }

    if (weatherState.type === "rain" && Math.random() < 0.4) {
        particles.push(new RainParticle(baseX, -10));
    }
    if (weatherState.type === "snow" && Math.random() < 0.3) {
        particles.push(typeof snowflakePool !== "undefined" ? snowflakePool.acquire(baseX, -10) : new Snowflake(baseX, -10));
    }
    if (weatherState.type === "sandstorm" && Math.random() < 0.35) {
        const py = Math.random() * canvas.height;
        particles.push(typeof dustPool !== "undefined" ? dustPool.acquire(baseX, py) : new DustParticle(baseX, py));
    }
}

let baseCanvasSize = null;
let baseGameConfig = null;
let baseEnemyStats = null;
let baseWeapons = null;
let baseBiomeConfigs = null;
let baseCloudPlatformConfig = null;
let worldScale = { x: 1, y: 1, unit: 1 };
let lastViewport = { width: 0, height: 0 };
// Mobile browsers often change the visual viewport (URL bar show/hide) right after first interaction.
// If we pause+reset immediately, the start overlay can appear "unclickable". We ignore viewport changes briefly.
let viewportIgnoreUntilMs = 0;

</script>
<script>
/**
 * 07-viewport.js - è§†å£ç¼©æ”¾ä¸é…ç½®åº”ç”¨
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 1245-1620)
 */
function nowMs() {
    return (typeof performance !== "undefined" && performance && typeof performance.now === "function")
        ? performance.now()
        : Date.now();
}

function getViewportSize() {
    // Prefer visual viewport for more accurate sizing on mobile (URL bar / keyboard / zoom).
    const vv = typeof window !== "undefined" ? window.visualViewport : null;
    const w = Math.max(1, (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0));
    const h = Math.max(1, (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0));
    return { width: w, height: h };
}

function getSafeInsetsPx() {
    const cs = getComputedStyle(document.documentElement);
    const toPx = (v) => {
        const n = Number(String(v || "").trim().replace("px", ""));
        return Number.isFinite(n) ? n : 0;
    };
    return {
        top: toPx(cs.getPropertyValue("--safe-top")),
        right: toPx(cs.getPropertyValue("--safe-right")),
        bottom: toPx(cs.getPropertyValue("--safe-bottom")),
        left: toPx(cs.getPropertyValue("--safe-left"))
    };
}

function getGameAreaSize() {
    const vv = getViewportSize();
    const insets = getSafeInsetsPx();
    // Body already applies safe-area padding, so the usable game area is the visible viewport minus insets.
    const w = Math.max(1, Math.floor(vv.width - insets.left - insets.right));
    const h = Math.max(1, Math.floor(vv.height - insets.top - insets.bottom));
    return { width: w, height: h };
}

function computeWorldScale(viewport) {
    if (!baseCanvasSize) {
        baseCanvasSize = { width: gameConfig.canvas.width, height: gameConfig.canvas.height };
    }
    const vw = Math.max(1, Number(viewport?.width) || 0);
    const vh = Math.max(1, Number(viewport?.height) || 0);
    const scaleX = vw / baseCanvasSize.width;
    const scaleY = vh / baseCanvasSize.height;
    const unit = Math.min(scaleX, scaleY);
    worldScale = { x: scaleX, y: scaleY, unit };
    return worldScale;
}

function scaleGameConfig(viewport) {
    if (!baseGameConfig) {
        baseGameConfig = JSON.parse(JSON.stringify(gameConfig));
        baseCanvasSize = { width: baseGameConfig.canvas.width, height: baseGameConfig.canvas.height };
    }
    const vp = viewport || getViewportSize();
    const scale = computeWorldScale(vp);
    const cfg = JSON.parse(JSON.stringify(baseGameConfig));

    cfg.canvas.width = Math.max(1, Math.floor(vp.width));
    cfg.canvas.height = Math.max(1, Math.floor(vp.height));

    if (cfg.physics) {
        cfg.physics.gravity = (baseGameConfig.physics?.gravity || 0) * scale.unit;
        cfg.physics.jumpStrength = (baseGameConfig.physics?.jumpStrength || 0) * scale.unit;
        cfg.physics.movementSpeed = (baseGameConfig.physics?.movementSpeed || 0) * scale.unit;
        const inventoryHeight = 48 * scale.unit;
        cfg.physics.groundY = cfg.canvas.height - inventoryHeight;
    }

    if (cfg.world) {
        cfg.world.blockSize = (baseGameConfig.world?.blockSize || 0) * scale.unit;
        cfg.world.cameraOffsetX = (baseGameConfig.world?.cameraOffsetX || 0) * scale.x;
        cfg.world.mapBuffer = (baseGameConfig.world?.mapBuffer || 0) * scale.x;
        cfg.world.removeThreshold = (baseGameConfig.world?.removeThreshold || 0) * scale.x;
        cfg.world.fallResetY = (baseGameConfig.world?.fallResetY || 0) * scale.y;
    }

    if (cfg.player) {
        cfg.player.width = (baseGameConfig.player?.width || 0) * scale.unit;
        cfg.player.height = (baseGameConfig.player?.height || 0) * scale.unit;
    }

    if (cfg.spawn && baseGameConfig.spawn) {
        if (typeof baseGameConfig.spawn.wordItemMinGap === "number") {
            cfg.spawn.wordItemMinGap = baseGameConfig.spawn.wordItemMinGap * scale.x;
        }
    }

    if (cfg.platforms && baseGameConfig.platforms) {
        if (typeof baseGameConfig.platforms.cloudHeightMin === "number") {
            cfg.platforms.cloudHeightMin = baseGameConfig.platforms.cloudHeightMin * scale.y;
        }
        if (typeof baseGameConfig.platforms.cloudHeightMax === "number") {
            cfg.platforms.cloudHeightMax = baseGameConfig.platforms.cloudHeightMax * scale.y;
        }
        if (typeof baseGameConfig.platforms.movingPlatformSpeedMin === "number") {
            cfg.platforms.movingPlatformSpeedMin = baseGameConfig.platforms.movingPlatformSpeedMin * scale.unit;
        }
        if (typeof baseGameConfig.platforms.movingPlatformSpeedMax === "number") {
            cfg.platforms.movingPlatformSpeedMax = baseGameConfig.platforms.movingPlatformSpeedMax * scale.unit;
        }
    }

    if (cfg.golems && baseGameConfig.golems) {
        if (baseGameConfig.golems.ironGolem) {
            cfg.golems.ironGolem.speed = baseGameConfig.golems.ironGolem.speed * scale.unit;
        }
        if (baseGameConfig.golems.snowGolem) {
            cfg.golems.snowGolem.speed = baseGameConfig.golems.snowGolem.speed * scale.unit;
        }
    }

    return cfg;
}

function scaleEnemyStats() {
    if (!baseEnemyStats) baseEnemyStats = JSON.parse(JSON.stringify(ENEMY_STATS));
    Object.keys(baseEnemyStats).forEach(key => {
        const base = baseEnemyStats[key];
        const target = ENEMY_STATS[key];
        if (!target) return;
        if (base.size) {
            target.size = {
                w: base.size.w * worldScale.unit,
                h: base.size.h * worldScale.unit
            };
        }
        if (typeof base.speed === "number") {
            target.speed = base.speed * worldScale.unit;
        }
    });
}

function scaleWeapons() {
    if (!baseWeapons) baseWeapons = JSON.parse(JSON.stringify(WEAPONS));
    Object.keys(baseWeapons).forEach(key => {
        const base = baseWeapons[key];
        const target = WEAPONS[key];
        if (!target) return;
        if (typeof base.range === "number") target.range = base.range * worldScale.x;
        if (typeof base.knockback === "number") target.knockback = base.knockback * worldScale.unit;
    });
}

function scaleBiomeConfigs() {
    if (!biomeConfigs || typeof biomeConfigs !== "object") return;
    if (!baseBiomeConfigs) baseBiomeConfigs = JSON.parse(JSON.stringify(biomeConfigs));
    Object.keys(biomeConfigs).forEach(key => {
        const base = baseBiomeConfigs[key];
        const target = biomeConfigs[key];
        if (!base || !target) return;
        if (base.effects && typeof base.effects.waterLevel === "number") {
            if (!target.effects) target.effects = {};
            target.effects.waterLevel = base.effects.waterLevel * worldScale.y;
        }
    });
}

function scaleCloudPlatformConfig() {
    // Cloud platforms are an optional feature. Some builds/scripts may not include the
    // config (and related entities). Guard to avoid crashing the whole game.
    if (typeof CLOUD_PLATFORM_CONFIG === "undefined") return;
    if (!baseCloudPlatformConfig) baseCloudPlatformConfig = JSON.parse(JSON.stringify(CLOUD_PLATFORM_CONFIG));
    Object.keys(CLOUD_PLATFORM_CONFIG).forEach(key => {
        const base = baseCloudPlatformConfig[key];
        const target = CLOUD_PLATFORM_CONFIG[key];
        if (!base || !target) return;
        if (typeof base.bounceForce === "number") target.bounceForce = base.bounceForce * worldScale.unit;
        if (typeof base.moveSpeed === "number") target.moveSpeed = base.moveSpeed * worldScale.unit;
        if (typeof base.moveRange === "number") target.moveRange = base.moveRange * worldScale.unit;
    });
}

function applyConfig(viewport = null) {
    const vp = viewport || getGameAreaSize();
    const oldScale = worldScale ? { ...worldScale } : null;
    const oldGroundY = groundY;

    gameConfig = scaleGameConfig(vp);
    canvas.width = gameConfig.canvas.width;
    canvas.height = gameConfig.canvas.height;
    canvasHeight = gameConfig.canvas.height;
    groundY = gameConfig.physics.groundY;
    blockSize = gameConfig.world.blockSize;
    cameraOffsetX = gameConfig.world.cameraOffsetX;
    mapBuffer = gameConfig.world.mapBuffer;
    removeThreshold = gameConfig.world.removeThreshold;
    fallResetY = gameConfig.world.fallResetY;
    scaleCloudPlatformConfig();
    scaleEnemyStats();
    scaleWeapons();
    scaleBiomeConfigs();
    applySpeedSetting();

    // å¦‚æœç¼©æ”¾æ¯”ä¾‹å˜åŒ–ï¼Œé‡æ˜ å°„ä¸–ç•Œåæ ‡
    if (oldScale && startedOnce) {
        remapWorldCoordinates(oldScale, oldGroundY);
    }
}

// è§†å£å˜åŒ–åé‡æ˜ å°„æ‰€æœ‰ä¸–ç•Œå®ä½“åæ ‡
function remapWorldCoordinates(oldScale, oldGroundY) {
    if (!oldScale || !worldScale) return;

    const scaleRatioX = worldScale.x / oldScale.x;
    const scaleRatioUnit = worldScale.unit / oldScale.unit;

    // é‡æ˜ å°„ç©å®¶ä½ç½®
    if (player) {
        player.x *= scaleRatioX;
        // ç©å®¶ y åæ ‡ç›¸å¯¹äºåœ°é¢é‡æ˜ å°„
        const oldDistFromGround = oldGroundY - player.y;
        player.y = groundY - oldDistFromGround * scaleRatioUnit;
        player.width = gameConfig.player.width;
        player.height = gameConfig.player.height;
        // é€Ÿåº¦ä¼šç”± applyMotionToPlayer é‡æ–°è®¡ç®—ï¼Œä¸éœ€è¦æ‰‹åŠ¨ç¼©æ”¾
        applyMotionToPlayer(player);
    }

    // é‡æ˜ å°„å¹³å°ä½ç½®
    platforms.forEach(p => {
        p.x *= scaleRatioX;
        // åœ°é¢å¹³å°é”šå®šåˆ°æ–°çš„ groundY
        if (Math.abs(p.y - oldGroundY) < 5) {
            p.y = groundY;
        } else {
            const oldDistFromGround = oldGroundY - p.y;
            p.y = groundY - oldDistFromGround * scaleRatioUnit;
        }
        p.width *= scaleRatioX;
        p.height = blockSize;
    });

    // é‡æ˜ å°„æ ‘æœ¨ä½ç½®
    trees.forEach(t => {
        t.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - (t.y + t.height);
        t.y = groundY - t.height - oldDistFromGround * scaleRatioUnit;
        t.width *= scaleRatioUnit;
        t.height *= scaleRatioUnit;
    });

    // é‡æ˜ å°„å®ç®±ä½ç½®
    chests.forEach(c => {
        c.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - c.y;
        c.y = groundY - oldDistFromGround * scaleRatioUnit;
    });

    // é‡æ˜ å°„ç‰©å“ä½ç½®
    items.forEach(i => {
        i.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - i.y;
        i.y = groundY - oldDistFromGround * scaleRatioUnit;
    });

    // é‡æ˜ å°„æ•Œäººä½ç½®
    enemies.forEach(e => {
        e.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - e.y;
        e.y = groundY - oldDistFromGround * scaleRatioUnit;
        e.width *= scaleRatioUnit;
        e.height *= scaleRatioUnit;
    });

    // é‡æ˜ å°„å‚€å„¡ä½ç½®
    golems.forEach(g => {
        g.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - g.y;
        g.y = groundY - oldDistFromGround * scaleRatioUnit;
    });

    // é‡æ˜ å°„è£…é¥°ç‰©ä½ç½®
    decorations.forEach(d => {
        d.x *= scaleRatioX;
        const oldDistFromGround = oldGroundY - d.y;
        d.y = groundY - oldDistFromGround * scaleRatioUnit;
    });

    // é‡æ˜ å°„ç›¸æœºä½ç½®
    cameraX *= scaleRatioX;
    lastGenX *= scaleRatioX;
}

function transformWorldEntityForViewport(entity, scaleX, scaleY, scaleUnit) {
    if (!entity || typeof entity !== "object") return;

    const posXKeys = ["x", "originX", "baseX", "minX", "maxX", "leftBound", "rightBound", "startX", "endX", "targetX", "lastX"];
    const posYKeys = ["y", "originY", "baseY", "minY", "maxY", "topBound", "bottomBound", "startY", "endY", "targetY", "lastY"];
    const sizeXKeys = ["width", "w", "radiusX"];
    const sizeYKeys = ["height", "h", "radiusY"];
    const speedXKeys = ["velX", "speedX", "dx"];
    const speedYKeys = ["velY", "speedY", "dy"];
    const unitKeys = ["radius", "size", "range", "attackRange", "detectRange", "jumpStrength", "speed", "moveSpeed", "knockback"];

    posXKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleX;
    });
    posYKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleY;
    });
    sizeXKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleX;
    });
    sizeYKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleY;
    });
    speedXKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleX;
    });
    speedYKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleY;
    });
    unitKeys.forEach(key => {
        if (typeof entity[key] === "number" && isFinite(entity[key])) entity[key] *= scaleUnit;
    });
}

function realignWorldForViewport(previousLayout) {
    if (!previousLayout || !startedOnce) return;

    const oldWidth = Math.max(1, Number(previousLayout.canvasWidth) || 1);
    const oldHeight = Math.max(1, Number(previousLayout.canvasHeight) || 1);
    const newWidth = Math.max(1, Number(canvas.width) || 1);
    const newHeight = Math.max(1, Number(canvas.height) || 1);

    const scaleX = newWidth / oldWidth;
    const scaleY = newHeight / oldHeight;
    const scaleUnit = Math.min(scaleX, scaleY);

    if (!isFinite(scaleX) || !isFinite(scaleY) || !isFinite(scaleUnit)) return;

    const collections = [platforms, trees, chests, items, enemies, golems, projectiles, decorations, particles, floatingTexts, wordGates];
    collections.forEach(list => {
        if (!Array.isArray(list)) return;
        list.forEach(entry => transformWorldEntityForViewport(entry, scaleX, scaleY, scaleUnit));
    });

    if (player) {
        transformWorldEntityForViewport(player, scaleX, scaleY, scaleUnit);
        applyMotionToPlayer(player);
        if (typeof player.height === "number" && isFinite(player.height)) {
            player.y = Math.min(player.y, groundY - player.height);
        }
    }

    if (Array.isArray(playerPositionHistory) && playerPositionHistory.length) {
        playerPositionHistory = playerPositionHistory.map(point => {
            if (!point || typeof point !== "object") return point;
            return {
                ...point,
                x: typeof point.x === "number" ? point.x * scaleX : point.x,
                y: typeof point.y === "number" ? point.y * scaleY : point.y
            };
        });
    }

    if (typeof cameraX === "number" && isFinite(cameraX)) cameraX *= scaleX;
    if (typeof lastGenX === "number" && isFinite(lastGenX)) lastGenX *= scaleX;
    if (typeof lastWordItemX === "number" && isFinite(lastWordItemX)) lastWordItemX *= scaleX;
}

function applySpeedSetting() {
    if (!gameConfig?.physics || !baseGameConfig?.physics) return;
    const level = String(settings.movementSpeedLevel || "normal").toLowerCase();
    const multiplier = SPEED_LEVELS[level] ?? SPEED_LEVELS.normal;
    const unit = worldScale?.unit || 1;
    const baseSpeed = (baseGameConfig.physics?.movementSpeed || 1.2) * unit;
    gameConfig.physics.movementSpeed = baseSpeed * multiplier;
    if (player) {
        applyMotionToPlayer(player);
    }
    saveSettings();
}

</script>
<script>
/**
 * 08-account.js - è´¦å·ç³»ç»Ÿã€ç™»å½•ã€æˆå°±
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 1621-2101)
 */
function clearStartOverlayTimer() {
    if (startOverlayTimer) {
        clearTimeout(startOverlayTimer);
        startOverlayTimer = 0;
    }
}

function setStartOverlayPage(page) {
    const root = document.getElementById("overlay-start");
    if (!root) return;
    root.querySelectorAll(".overlay-page").forEach(el => {
        const active = el.dataset.page === page;
        el.classList.toggle("active", active);
    });
    const title = document.getElementById("overlay-title");
    if (title) title.innerText = page === "intro" ? "Minecraft å•è¯æ¸¸æˆ" : "é€‰æ‹©æ¡£æ¡ˆ";
}

function ensureStartOverlayContent() {
    const text = document.getElementById("overlay-text");
    if (!text) return;
    if (document.getElementById("overlay-start")) return;
    text.innerHTML = `
        <div class="overlay-start" id="overlay-start">
            <div class="overlay-page overlay-page-intro active" data-page="intro">
                <div class="overlay-intro-title">Minecraft å•è¯æ¸¸æˆ</div>
                <div class="overlay-intro-sub">åœ¨å†’é™©ä¸­å­¦ä¹ å•è¯ï¼Œé—¯å…³è§£é”æ›´å¤šè¯åº“ä¸è£…å¤‡ã€‚</div>
            </div>
            <div class="overlay-page overlay-page-setup" data-page="setup">
                <div class="overlay-account">
                    <div class="overlay-account-title">è¾“å…¥æ¡£æ¡ˆ</div>
                    <div class="overlay-account-row">
                        <input class="overlay-input" id="overlay-username-input" type="text" placeholder="è¾“å…¥æ˜µç§°/æ¡£æ¡ˆå" maxlength="20">
                        <button class="game-btn game-btn-small" id="btn-overlay-create">åˆ›å»º/è¿›å…¥</button>
                    </div>
                    <div class="overlay-account-hint">å·²æœ‰æ¡£æ¡ˆï¼šé€‰æ‹©ç»§ç»­/é‡ç©/åˆ é™¤</div>
                    <div id="overlay-accounts-container" class="account-list"></div>
                </div>
                <div class="overlay-hints-title">æ“ä½œè¯´æ˜</div>
                <div class="overlay-hints-text">${START_OVERLAY_HINT_HTML}</div>
            </div>
        </div>
    `;
}

function renderStartOverlayAccounts() {
    const container = document.getElementById("overlay-accounts-container");
    if (!container) return;
    const storedId = storage.getCurrentAccountId();
    const accounts = storage.getAccountList();
    const sortedAccounts = [...accounts].sort((a, b) => {
        if (a.id === storedId) return -1;
        if (b.id === storedId) return 1;
        return 0;
    });
    renderAccountList(container, sortedAccounts, storedId);
}

function wireStartOverlayAccountActions() {
    const input = document.getElementById("overlay-username-input");
    const btn = document.getElementById("btn-overlay-create");
    if (btn) {
        btn.addEventListener("click", () => {
            const username = (input?.value || "").trim();
            if (!username) {
                showToast("è¯·è¾“å…¥ç”¨æˆ·å");
                input?.focus();
                return;
            }
            const existing = storage.getAccountList().find(a => a.username === username);
            const account = existing || storage.createAccount(username);
            loginWithAccount(account, { mode: "continue" });
            renderStartOverlayAccounts();
        });
    }
    if (input) {
        input.addEventListener("keydown", e => {
            if (e.key !== "Enter") return;
            e.preventDefault();
            btn?.click();
        });
    }
}

function updateStartOverlayActionState() {
    const btn = document.getElementById("btn-overlay-action");
    startOverlayReady = !!currentAccount;
    if (!btn) return;
    btn.disabled = !startOverlayReady;
    btn.innerText = startOverlayReady ? "å¼€å§‹æ¸¸æˆ" : "è¯·å…ˆé€‰æ‹©æ¡£æ¡ˆ";
}

function isStartOverlayVisible() {
    const overlay = document.getElementById("screen-overlay");
    return !!overlay && overlay.classList.contains("visible") && overlayMode === "start";
}

async function initLoginScreen() {
    const screen = document.getElementById("login-screen");
    if (!screen) return;
    const loginForm = document.getElementById("login-form");
    const accountList = document.getElementById("account-list");
    const accountsContainer = document.getElementById("accounts-container");
    const usernameInput = document.getElementById("username-input");
    const btnLogin = document.getElementById("btn-login");
    const btnNewAccount = document.getElementById("btn-new-account");
    const storedId = storage.getCurrentAccountId();
    const accounts = storage.getAccountList();
    const sortedAccounts = [...accounts].sort((a, b) => {
        if (a.id === storedId) return -1;
        if (b.id === storedId) return 1;
        return 0;
    });

    renderAccountList(accountsContainer, sortedAccounts, storedId);
    if (accounts.length) {
        loginForm.style.display = "none";
        accountList.style.display = "block";
    } else {
        loginForm.style.display = "block";
        accountList.style.display = "none";
    }

    ensureStartOverlayContent();
    renderStartOverlayAccounts();
    wireStartOverlayAccountActions();
    screen.classList.remove("visible");
    paused = true;
    pausedByModal = true;
    setOverlay(true, "start");

    if (btnLogin) {
        btnLogin.addEventListener("click", () => {
            const username = (usernameInput?.value || "").trim();
            if (!username) {
                showToast("è¯·è¾“å…¥ç”¨æˆ·å");
                return;
            }
            const existing = storage.getAccountList().find(a => a.username === username);
            const account = existing || storage.createAccount(username);
            loginWithAccount(account, { mode: "continue" });
        });
    }

    if (btnNewAccount) {
        btnNewAccount.addEventListener("click", () => {
            loginForm.style.display = "block";
            accountList.style.display = "none";
        });
    }
}

function renderAccountList(container, accounts, storedId) {
    if (!container) return;
    container.innerHTML = "";
    if (!accounts.length) {
        container.innerHTML = "<div class=\"account-empty\">æš‚æ— è´¦å·</div>";
        return;
    }
    accounts.forEach(account => {
        const div = document.createElement("div");
        div.className = "account-item";
        div.innerHTML = `
            <div class="account-avatar">ç”¨æˆ·</div>
            <div class="account-info">
                <div class="account-name">${account.username}${storedId && account.id === storedId ? ' <span style="opacity:.7;font-weight:700;">(ä¸Šæ¬¡)</span>' : ""}</div>
                <div class="account-stats">
                    æœ€é«˜åˆ†: ${account.progress?.highScore || 0} Â· å·²å­¦: ${account.vocabulary?.learnedWords?.length || 0}
                </div>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
                <button class="game-btn game-btn-small btn-account-continue" data-id="${account.id}">ç»§ç»­</button>
                <button class="game-btn game-btn-small game-btn-danger btn-account-restart" data-id="${account.id}">é‡ç©</button>
                <button class="game-btn game-btn-small btn-delete-account" data-id="${account.id}">åˆ é™¤</button>
            </div>
        `;

        div.querySelector(".account-info")?.addEventListener("click", () => loginWithAccount(account, { mode: "continue" }));
        div.querySelector(".btn-account-continue")?.addEventListener("click", e => {
            e.stopPropagation();
            loginWithAccount(account, { mode: "continue" });
        });
        div.querySelector(".btn-account-restart")?.addEventListener("click", e => {
            e.stopPropagation();
            if (!confirm(`ç¡®å®šé‡ç© "${account.username}" å—ï¼Ÿ\nå°†æ¸…ç©ºæœ¬è´¦å·çš„é‡‘å¸/èƒŒåŒ…/è£…å¤‡ï¼Œä½†ä¿ç•™å·²å­¦å•è¯ä¸æˆå°±ã€‚`)) return;
            loginWithAccount(account, { mode: "restart" });
        });

        const del = div.querySelector(".btn-delete-account");
        del?.addEventListener("click", e => {
            e.stopPropagation();
            if (confirm(`ç¡®å®šåˆ é™¤è´¦å· "${account.username}" å—ï¼Ÿ`)) {
                storage.deleteAccount(account.id);
                renderAccountList(container, storage.getAccountList(), storage.getCurrentAccountId());
            }
        });

        container.appendChild(div);
    });
}

function resetAccountRunState(account) {
    if (!account) return;
    account.progress = account.progress || {};
    account.progress.currentCoins = 0;
    account.progress.currentDiamonds = 0;

    account.inventory = account.inventory || {};
    account.inventory.items = { ...INVENTORY_TEMPLATE };
    account.inventory.equipment = { armor: null, armorDurability: 0 };
    account.inventory.armorCollection = [];
}

async function loginWithAccount(account, options) {
    if (!account) return;
    const mode = options && options.mode ? options.mode : "continue";
    if (mode === "restart") {
        resetAccountRunState(account);
        storage.saveAccount(account);
    }
    stopAutoSave();
    currentAccount = account;
    currentAccount.lastLoginAt = Date.now();
    storage.setCurrentAccountId(account.id);
    storage.saveAccount(currentAccount);
    loadAccountData(account);
    const startOverlayVisible = isStartOverlayVisible();
    const screen = document.getElementById("login-screen");
    if (screen) {
        screen.classList.remove("visible");
    }
    if (startOverlayVisible) {
        paused = true;
        pausedByModal = true;
    } else {
        paused = false;
        pausedByModal = false;
    }
    showToast(`æ¬¢è¿å›æ¥ ${account.username}`);
    startAutoSave();
    await setActiveVocabPack(settings.vocabSelection || "auto");
    clearOldWordItems();

    updateStartOverlayActionState();
    // If start() already finished wiring handlers, boot the game loop on first successful login.
    if (bootReady && !startOverlayVisible) bootGameLoopIfNeeded();
}

function bootGameLoopIfNeeded() {
    if (startedOnce) return;
    initGame();
    updateWordUI(null);
    paused = false;
    startedOnce = true;
    setOverlay(false);
    showToast("å†’é™©å¼€å§‹ï¼");
    update();
    draw();
}

function loadAccountData(account) {
    score = account?.progress?.currentCoins || 0;
    levelScore = 0;
    progress = normalizeProgress({
        vocab: (account.vocabulary && account.vocabulary.packProgress) ? account.vocabulary.packProgress : {}
    });
    if (account.vocabulary?.currentPack) {
        settings.vocabSelection = account.vocabulary.currentPack;
    }
    inventory = { ...INVENTORY_TEMPLATE, ...(account.inventory?.items || {}) };
    playerEquipment = account.inventory?.equipment ? { ...account.inventory.equipment } : { armor: null, armorDurability: 0 };
    armorInventory = Array.isArray(account.inventory?.armorCollection) ? [...account.inventory.armorCollection] : [];
    updateInventoryUI();
    updateArmorUI();
    const scoreEl = document.getElementById("score");
    if (scoreEl) scoreEl.innerText = score;
    updateVocabProgressUI();
    updateVocabPreview(settings.vocabSelection);
    if (player) {
        applyMotionToPlayer(player);
    }
}

function startAutoSave() {
    stopAutoSave();
    lastSaveTime = Date.now();
    autoSaveInterval = setInterval(() => {
        saveCurrentProgress();
    }, 30000);
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

function saveCurrentProgress() {
    if (!currentAccount) return;
    const now = Date.now();
    const delta = Math.max(0, Math.floor((now - lastSaveTime) / 1000));
    lastSaveTime = now;
    currentAccount.totalPlayTime += delta;
    currentAccount.lastLoginAt = now;
    currentAccount.progress = currentAccount.progress || {};
    currentAccount.progress.currentCoins = score;
    currentAccount.progress.currentDiamonds = inventory.diamond || 0;
    currentAccount.vocabulary = currentAccount.vocabulary || {};
    currentAccount.vocabulary.packProgress = progress.vocab || {};
    currentAccount.vocabulary.currentPack = settings.vocabSelection || "";
    currentAccount.inventory = currentAccount.inventory || {};
    currentAccount.inventory.items = { ...inventory };
    currentAccount.inventory.equipment = { ...playerEquipment };
    currentAccount.inventory.armorCollection = [...armorInventory];
    storage.saveAccount(currentAccount);
}

function onWordCollected(wordObj) {
    if (!currentAccount || !wordObj?.en) return;
    if (!currentAccount.vocabulary) currentAccount.vocabulary = { learnedWords: [], packProgress: {}, currentPack: "" };
    const known = currentAccount.vocabulary.learnedWords || [];
    if (!known.includes(wordObj.en)) {
        known.push(wordObj.en);
        currentAccount.vocabulary.learnedWords = known;
        checkAchievement("words", known.length);
    }
    currentAccount.stats = currentAccount.stats || {};
    currentAccount.stats.wordsCollected = (currentAccount.stats.wordsCollected || 0) + 1;
    checkAchievement("score", score);
    saveCurrentProgress();
}

function onEnemyKilled() {
    if (!currentAccount) return;
    currentAccount.stats = currentAccount.stats || {};
    currentAccount.stats.enemiesKilled = (currentAccount.stats.enemiesKilled || 0) + 1;
    checkAchievement("enemies", currentAccount.stats.enemiesKilled);
    saveCurrentProgress();
}

function onChestOpened() {
    if (!currentAccount) return;
    currentAccount.stats = currentAccount.stats || {};
    currentAccount.stats.chestsOpened = (currentAccount.stats.chestsOpened || 0) + 1;
    checkAchievement("chests", currentAccount.stats.chestsOpened);
    saveCurrentProgress();
}

function onGameOver() {
    if (!currentAccount) return;
    currentAccount.stats = currentAccount.stats || {};
    currentAccount.stats.gamesPlayed = (currentAccount.stats.gamesPlayed || 0) + 1;
    currentAccount.stats.deathCount = (currentAccount.stats.deathCount || 0) + 1;
    currentAccount.progress = currentAccount.progress || {};
    currentAccount.progress.totalScore = (currentAccount.progress.totalScore || 0) + score;
    if (score > (currentAccount.progress.highScore || 0)) {
        currentAccount.progress.highScore = score;
        showToast(`æ–°çºªå½•ï¼å½“å‰ç§¯åˆ† ${score}`);
    }
    checkAchievement("score", score);
    saveCurrentProgress();
}

function checkAchievement(type, value) {
    if (!currentAccount) return;
    const relevant = ACHIEVEMENT_MAP[type] || [];
    relevant.forEach(id => {
        if (currentAccount.achievements?.unlocked?.includes(id)) return;
        const achievement = ACHIEVEMENTS[id];
        if (!achievement) return;
        if (value >= (achievement.target || 0)) {
            unlockAchievement(id);
        }
    });
}

function unlockAchievement(id) {
    if (!currentAccount) return;
    if (!currentAccount.achievements) {
        currentAccount.achievements = { unlocked: [], progress: {} };
    }
    if (currentAccount.achievements.unlocked.includes(id)) return;
    const achievement = ACHIEVEMENTS[id];
    if (!achievement) return;
    currentAccount.achievements.unlocked.push(id);
    storage.saveAccount(currentAccount);
    showAchievementUnlock(achievement);
}

function showAchievementUnlock(achievement) {
    const popup = document.createElement("div");
    popup.className = "achievement-popup";
    popup.innerHTML = `
        <div class="achievement-icon">${achievement.icon || "â­"}</div>
        <div class="achievement-info">
            <div class="achievement-title">æˆå°±è§£é”</div>
            <div class="achievement-name">${achievement.name}</div>
            <div class="achievement-desc">${achievement.desc}</div>
        </div>
    `;
    document.body.appendChild(popup);
    setTimeout(() => popup.classList.add("show"), 100);
    setTimeout(() => {
        popup.classList.remove("show");
        setTimeout(() => popup.remove(), 400);
    }, 3200);
}

function showProfileModal() {
    if (!currentAccount) return;
    const modal = document.getElementById("profile-modal");
    if (!modal) return;
    profileModalEl = modal;
    profileUsernameEl = document.getElementById("profile-username");
    profilePlaytimeEl = document.getElementById("profile-playtime");
    profileHighscoreEl = document.getElementById("profile-highscore");
    profileWordsEl = document.getElementById("profile-words");
    profileGamesEl = document.getElementById("profile-games");
    achievementsContainerEl = document.getElementById("achievements-container");
    if (profileUsernameEl) profileUsernameEl.innerText = currentAccount.username;
    if (profilePlaytimeEl) profilePlaytimeEl.innerText = formatPlayTime(currentAccount.totalPlayTime || 0);
    if (profileHighscoreEl) profileHighscoreEl.innerText = currentAccount.progress?.highScore || 0;
    if (profileWordsEl) profileWordsEl.innerText = currentAccount.vocabulary?.learnedWords?.length || 0;
    if (profileGamesEl) profileGamesEl.innerText = currentAccount.stats?.gamesPlayed || 0;

    // === v1.6.4 æ–°å¢ï¼šç­”é¢˜ç»Ÿè®¡ ===
    const challengeStatsEl = document.getElementById("profile-challenge-stats");
    if (challengeStatsEl) {
        const cs = getChallengeStats();

        if (cs.totalCorrect + cs.totalWrong > 0) {
            challengeStatsEl.innerHTML =
                `ç­”é¢˜ ${cs.totalCorrect + cs.totalWrong} æ¬¡ï¼Œ` +
                `æ­£ç¡®ç‡ <strong>${cs.accuracy}%</strong>ï¼Œ` +
                `æ¶‰åŠ ${cs.wordCount} ä¸ªå•è¯`;
        } else {
            challengeStatsEl.innerHTML = 'è¿˜æ²¡æœ‰ç­”é¢˜è®°å½•';
            challengeStatsEl.style.color = '#888';
        }
    }

    renderAchievements();
    modal.classList.add("visible");
    modal.setAttribute("aria-hidden", "false");
    pausedByModal = true;
    paused = true;
}

function hideProfileModal() {
    if (!profileModalEl) return;
    profileModalEl.classList.remove("visible");
    profileModalEl.setAttribute("aria-hidden", "true");
    if (pausedByModal) {
        pausedByModal = false;
        paused = false;
    }
}

function renderAchievements() {
    if (!achievementsContainerEl) return;
    achievementsContainerEl.innerHTML = "";
    const unlocked = new Set(currentAccount?.achievements?.unlocked || []);
    Object.values(ACHIEVEMENTS).forEach(achievement => {
        const div = document.createElement("div");
        const isUnlocked = unlocked.has(achievement.id);
        div.className = `achievement-item ${isUnlocked ? "unlocked" : "locked"}`;
        div.innerHTML = `
            <div class="achievement-icon">${isUnlocked ? achievement.icon : "ğŸ”’"}</div>
            <div class="achievement-content">
                <div class="achievement-name">${achievement.name}</div>
                <div class="achievement-desc">${achievement.desc}</div>
            </div>
        `;
        achievementsContainerEl.appendChild(div);
    });
}

function formatPlayTime(seconds) {
    const totalMinutes = Math.floor(seconds / 60);
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    if (hours > 0) {
        return `${hours}å°æ—¶ ${minutes} åˆ†é’Ÿ`;
    }
    return `${minutes} åˆ†é’Ÿ`;
}

// ==================== v1.6.4 å•è¯æœ¬åŠŸèƒ½ ====================

/**
 * æ˜¾ç¤ºå•è¯æœ¬
 */
function showVocabBook() {
    const modal = document.getElementById("vocab-book-modal");
    const list = document.getElementById("vocab-book-list");
    if (!modal || !list) return;

    const stats = progress.challengeStats || {};
    const words = Object.keys(stats);

    if (words.length === 0) {
        list.innerHTML = `
            <div style="text-align:center;padding:40px;color:#888;">
                <p style="font-size:48px;margin:0;">ğŸ“š</p>
                <p style="margin:10px 0;">è¿˜æ²¡æœ‰ç­”é¢˜è®°å½•</p>
                <p style="font-size:12px;margin-top:10px;color:#666;">
                    æ”¶é›†å•è¯æˆ–å¼€å®ç®±åä¼šæœ‰ç­”é¢˜æœºä¼š
                </p>
            </div>
        `;
    } else {
        // æŒ‰æŒæ¡ç¨‹åº¦æ’åºï¼šéœ€å¤ä¹ çš„åœ¨å‰
        words.sort((a, b) => {
            const aS = stats[a];
            const bS = stats[b];
            const aTotal = (aS.correct || 0) + (aS.wrong || 0) || 1;
            const bTotal = (bS.correct || 0) + (bS.wrong || 0) || 1;
            const aRate = (aS.correct || 0) / aTotal;
            const bRate = (bS.correct || 0) / bTotal;
            return aRate - bRate;  // æ­£ç¡®ç‡ä½çš„åœ¨å‰
        });

        list.innerHTML = words.map(word => {
            const s = stats[word];
            const total = (s.correct || 0) + (s.wrong || 0);
            const rate = total > 0 ? Math.round((s.correct || 0) / total * 100) : 0;

            // æ‰¾ä¸­æ–‡ç¿»è¯‘
            const found = wordDatabase && wordDatabase.find ? wordDatabase.find(w => w.en === word) : null;
            const zh = found?.zh || "";

            // æŒæ¡ç¨‹åº¦é¢œè‰²
            let color, status;
            if (rate >= 80) {
                color = "#4CAF50";  // ç»¿è‰² = å·²æŒæ¡
                status = "âœ“";
            } else if (rate >= 50) {
                color = "#FFC107";  // é»„è‰² = å­¦ä¹ ä¸­
                status = "â—";
            } else {
                color = "#F44336";  // çº¢è‰² = éœ€å¤ä¹ 
                status = "âœ—";
            }

            return `
                <div class="vocab-book-item">
                    <span class="vocab-status" style="color:${color}">${status}</span>
                    <span class="vocab-word">${word.toUpperCase()}</span>
                    <span class="vocab-zh">${zh}</span>
                    <span class="vocab-rate" style="color:${color}">${rate}%</span>
                    <span class="vocab-count">âœ“${s.correct || 0} âœ—${s.wrong || 0}</span>
                </div>
            `;
        }).join("");
    }

    // æ˜¾ç¤ºæ¨¡æ€æ¡†
    modal.classList.add("visible");
    modal.setAttribute("aria-hidden", "false");
    pausedByModal = true;
    paused = true;
}

/**
 * éšè—å•è¯æœ¬
 */
function hideVocabBook() {
    const modal = document.getElementById("vocab-book-modal");
    if (modal) {
        modal.classList.remove("visible");
        modal.setAttribute("aria-hidden", "true");
        if (pausedByModal) {
            pausedByModal = false;
            paused = false;
        }
    }
}


function wireProfileModal() {
    const modal = document.getElementById("profile-modal");
    const btnClose = document.getElementById("btn-profile-close");
    if (btnClose) btnClose.addEventListener("click", hideProfileModal);
    if (modal) {
        modal.addEventListener("click", e => {
            if (e.target === modal) hideProfileModal();
        });
    }
}

</script>
<script>
/**
 * 09-vocab.js - è¯æ±‡ç³»ç»Ÿä¸è¯åº“ç®¡ç†
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 2103-2495)
 */
function normalizeSettings(raw) {
    const merged = mergeDeep(defaultSettings, raw || {});
    if (typeof merged.challengeEnabled !== "boolean") merged.challengeEnabled = defaultSettings.challengeEnabled ?? true;
    if (typeof merged.challengeFrequency !== "number") merged.challengeFrequency = defaultSettings.challengeFrequency ?? 0.3;
    if (typeof merged.wordCardDuration !== "number") merged.wordCardDuration = defaultSettings.wordCardDuration ?? 900;
    if (typeof merged.speechEnRate !== "number") merged.speechEnRate = defaultSettings.speechEnRate ?? 0.8;
    if (typeof merged.speechZhRate !== "number") merged.speechZhRate = defaultSettings.speechZhRate ?? 0.9;
    if (typeof merged.speechZhEnabled !== "boolean") merged.speechZhEnabled = defaultSettings.speechZhEnabled ?? false;
    if (typeof merged.musicEnabled !== "boolean") merged.musicEnabled = defaultSettings.musicEnabled ?? true;
    if (typeof merged.uiScale !== "number") merged.uiScale = defaultSettings.uiScale ?? 1.0;
    if (typeof merged.motionScale !== "number") merged.motionScale = defaultSettings.motionScale ?? 1.25;
    if (typeof merged.biomeSwitchStepScore !== "number") merged.biomeSwitchStepScore = defaultSettings.biomeSwitchStepScore ?? 200;
    if (typeof merged.wordGateEnabled !== "boolean") merged.wordGateEnabled = defaultSettings.wordGateEnabled ?? true;
    if (typeof merged.wordMatchEnabled !== "boolean") merged.wordMatchEnabled = defaultSettings.wordMatchEnabled ?? true;
    if (typeof merged.villageEnabled !== "boolean") merged.villageEnabled = defaultSettings.villageEnabled ?? true;
    if (typeof merged.villageFrequency !== "number") merged.villageFrequency = defaultSettings.villageFrequency ?? 500;
    if (typeof merged.villageAutoSave !== "boolean") merged.villageAutoSave = defaultSettings.villageAutoSave ?? true;
    if (typeof merged.movementSpeedLevel !== "string" || !(merged.movementSpeedLevel in SPEED_LEVELS)) merged.movementSpeedLevel = "normal";
    if (typeof merged.difficultySelection !== "string" || !merged.difficultySelection) merged.difficultySelection = "auto";
    merged.biomeSwitchStepScore = Math.max(50, Math.min(2000, Number(merged.biomeSwitchStepScore) || 200));
    merged.challengeFrequency = clamp(Number(merged.challengeFrequency) || 0.3, 0.05, 0.9);
    merged.wordCardDuration = Math.max(300, Math.min(3000, Number(merged.wordCardDuration) || 900));
    if (!merged.keyCodes) {
        merged.keyCodes = [defaultControls.jump, defaultControls.attack, defaultControls.interact, defaultControls.switch, defaultControls.useDiamond]
            .filter(Boolean)
            .join(",");
    } else {
        const parsed = parseKeyCodes(merged.keyCodes);
        if (!parsed) {
            merged.keyCodes = [defaultControls.jump, defaultControls.attack, defaultControls.interact, defaultControls.switch, defaultControls.useDiamond]
                .filter(Boolean)
                .join(",");
        }
    }
    return merged;
}

settings = normalizeSettings(settings);

function saveSettings() {
    if (storage) storage.saveJson("mmwg:settings", settings);
}

function saveProgress() {
    if (storage) storage.saveJson("mmwg:progress", progress);
}

function saveVocabState() {
    if (storage) storage.saveJson("mmwg:vocabState", vocabState);
}

function normalizeProgress(raw) {
    const p = raw && typeof raw === "object" ? raw : {};
    if (!p.vocab || typeof p.vocab !== "object") p.vocab = {};
    return p;
}

progress = normalizeProgress(progress);

function placeholderImageDataUrl(text) {
    const label = String(text || "").slice(0, 24);
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="520" height="320" viewBox="0 0 520 320"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop stop-color="#1b1f2a" offset="0"/><stop stop-color="#2b3550" offset="1"/></linearGradient></defs><rect width="520" height="320" rx="22" ry="22" fill="url(#g)"/><rect x="18" y="18" width="484" height="284" rx="18" ry="18" fill="rgba(255,255,255,0.06)" stroke="rgba(255,255,255,0.18)" stroke-width="3"/><text x="260" y="175" text-anchor="middle" font-family="Verdana,Arial" font-size="46" font-weight="900" fill="rgba(255,255,255,0.92)">${label}</text><text x="260" y="220" text-anchor="middle" font-family="Verdana,Arial" font-size="20" font-weight="700" fill="rgba(255,255,255,0.65)">image unavailable</text></svg>`;
    return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
}

let _wordImageVersion = 0;
function updateWordImage(wordObj) {
    const img = document.getElementById("word-card-image");
    if (!img) return;
    if (!settings.showWordImage) {
        img.style.display = "none";
        img.removeAttribute("src");
        img.alt = "";
        return;
    }
    const list = wordObj && (wordObj.imageURLs || wordObj.images || wordObj.imageUrl || wordObj.imageURL) ? (wordObj.imageURLs || wordObj.images || []) : [];
    const url = Array.isArray(list) && list.length ? (list[0] && list[0].url ? list[0].url : null) : (wordObj && typeof wordObj.imageUrl === "string" ? wordObj.imageUrl : null);
    if (!url) {
        img.style.display = "none";
        img.removeAttribute("src");
        img.alt = "";
        return;
    }
    const ver = ++_wordImageVersion;
    img.alt = wordObj && wordObj.en ? String(wordObj.en) : "";
    // Preload image to avoid showing stale/previous image
    const preload = new Image();
    preload.onload = () => {
        if (ver !== _wordImageVersion) return; // outdated, skip
        img.src = preload.src;
        img.style.display = "block";
    };
    preload.onerror = () => {
        if (ver !== _wordImageVersion) return;
        img.src = placeholderImageDataUrl(wordObj && wordObj.en ? wordObj.en : "");
        img.style.display = "block";
    };
    // Hide until correct image is loaded
    img.style.display = "none";
    preload.src = url;
}

function ensureVocabEngine() {
    if (vocabEngine) return vocabEngine;
    if (!vocabManifest || !vocabManifest.packs) return null;
    vocabPackOrder = vocabManifest.packs.map(p => p.id);
    if (vocabManifest.byId) {
        vocabPacks = vocabManifest.byId;
    } else {
        vocabPacks = Object.create(null);
        vocabManifest.packs.forEach(p => { vocabPacks[p.id] = p; });
    }
    vocabEngine = { version: vocabManifest.version, packIds: vocabPackOrder };
    return vocabEngine;
}

function renderVocabSelect() {
    const sel = document.getElementById("opt-vocab");
    if (!sel) return;
    sel.innerHTML = "";
    const add = (value, text, isOptgroup = false) => {
        if (isOptgroup) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = text;
            sel.appendChild(optgroup);
            return optgroup;
        }
        const opt = document.createElement("option");
        opt.value = value;
        opt.innerText = text;
        sel.appendChild(opt);
    };
    const addToGroup = (group, value, text) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.innerText = text;
        group.appendChild(opt);
    };

    add("auto", "éšæœºè¯åº“ï¼ˆæŒ‰ç±»åˆ«è½®æ¢ï¼‰");
    const engine = ensureVocabEngine();
    if (!engine) return;

    // Group packs by stage
    const grouped = {};
    vocabManifest.packs.forEach(p => {
        const stage = p.stage || "other";
        if (!grouped[stage]) grouped[stage] = [];
        grouped[stage].push(p);
    });

    // Define stage order and labels
    const stageOrder = ["kindergarten", "elementary_lower", "elementary_upper", "minecraft"];
    const stageLabels = {
        "kindergarten": "å¹¼å„¿å›­",
        "elementary_lower": "å°å­¦ä½å¹´çº§",
        "elementary_upper": "å°å­¦é«˜å¹´çº§",
        "minecraft": "æˆ‘çš„ä¸–ç•Œ"
    };

    // Define level order
    const levelOrder = ["basic", "intermediate", "advanced", "full"];
    const levelLabels = {
        "basic": "åˆçº§",
        "intermediate": "ä¸­çº§",
        "advanced": "é«˜çº§",
        "full": "å®Œæ•´"
    };

    // Render grouped options
    stageOrder.forEach(stage => {
        if (!grouped[stage]) return;
        const group = add(null, stageLabels[stage] || stage, true);

        // Sort packs by level
        const packs = grouped[stage].sort((a, b) => {
            const aLevel = a.level || "full";
            const bLevel = b.level || "full";
            return levelOrder.indexOf(aLevel) - levelOrder.indexOf(bLevel);
        });

        packs.forEach(p => {
            const levelLabel = levelLabels[p.level] || p.level || "";
            const title = levelLabel ? `${levelLabel}` : p.title;
            addToGroup(group, p.id, title);
        });
    });

    sel.value = settings.vocabSelection || "auto";
    updateVocabPreview(sel.value);
}

function getActivePackTitle() {
    if (!activeVocabPackId) return "è‡ªåŠ¨è¯åº“";
    const pack = vocabPacks[activeVocabPackId];
    return pack ? pack.title : activeVocabPackId;
}

function updateVocabPreview(selection) {
    const preview = document.getElementById("vocab-preview");
    if (!preview) return;
    const key = selection || settings.vocabSelection || "auto";
    if (key === "auto") {
        preview.innerHTML = `<strong>è‡ªåŠ¨è½®æ¢</strong><br>æ ¹æ®é˜¶æ®µä¸éš¾åº¦æ™ºèƒ½åŒ¹é…`;
        return;
    }
    const pack = vocabPacks[key];
    if (!pack) {
        preview.innerText = "è¯åº“æ•°æ®æœªå°±ç»ª";
        return;
    }
    const details = [];
    if (pack.stage) {
        const stageLabel = (typeof STAGE_LABELS !== "undefined" && STAGE_LABELS && STAGE_LABELS[pack.stage])
            ? STAGE_LABELS[pack.stage]
            : pack.stage;
        details.push(stageLabel);
    }
    if (pack.difficulty) details.push(pack.difficulty);
    preview.innerHTML = `<strong>${pack.title}</strong>${details.length ? `<br>${details.join(" Â· ")}` : ""}`;
}

function showVocabSwitchEffect() {
    const title = getActivePackTitle();
    const px = player ? player.x : cameraX;
    const py = player ? player.y - 60 : canvas.height / 2;
    showFloatingText(`åˆ‡æ¢è¯åº“ï¼š${title}`, px, py);
    showToast(`å·²åˆ‡æ¢è‡³ ${title}`);
}

function getPackProgress(packId) {
    if (!packId) return null;
    const v = progress.vocab;
    if (!v[packId]) v[packId] = { unique: {}, uniqueCount: 0, total: 0, completed: false };
    const entry = v[packId];
    if (!entry.unique || typeof entry.unique !== "object") entry.unique = {};
    if (typeof entry.uniqueCount !== "number") entry.uniqueCount = Object.keys(entry.unique).length;
    if (typeof entry.total !== "number") entry.total = 0;
    if (typeof entry.completed !== "boolean") entry.completed = false;
    return entry;
}

function updateVocabProgressUI() {
    const el = document.getElementById("progress-vocab");
    if (!el) return;
    const engine = ensureVocabEngine();
    if (!engine || !activeVocabPackId) {
        el.innerText = "æœªåŠ è½½";
        return;
    }
    const pack = vocabPacks[activeVocabPackId];
    const pr = getPackProgress(activeVocabPackId);
    const total = pr.total || 0;
    const done = pr.uniqueCount || 0;
    const pct = total ? Math.min(100, Math.floor((done / total) * 100)) : 0;
    const title = pack && pack.title ? pack.title : activeVocabPackId;
    el.innerText = `${title}  ${done}/${total}  (${pct}%)`;
}

function resetVocabRotationAndProgress() {
    vocabState = { runCounts: {}, lastPackId: null };
    progress = normalizeProgress({ vocab: {} });
    saveVocabState();
    saveProgress();
    updateVocabProgressUI();
}

function isPackCompleted(packId) {
    const pr = getPackProgress(packId);
    return !!pr?.completed;
}

function pickPackAuto() {
    const engine = ensureVocabEngine();
    if (!engine) return null;
    let candidates = vocabManifest.packs.filter(p => !isPackCompleted(p.id));
    if (!candidates.length) {
        progress.vocab = {};
        saveProgress();
        candidates = [...vocabManifest.packs];
    }
    const last = vocabState.lastPackId;
    const scored = candidates.map(p => {
        const baseW = Math.max(0.05, Number(p.weight) || 1);
        const count = vocabState.runCounts && typeof vocabState.runCounts[p.id] === "number" ? vocabState.runCounts[p.id] : 0;
        let w = baseW / (1 + count * 0.75);
        if (last && p.id === last) w *= 0.2;
        if (!isFinite(w) || w <= 0) w = 0.05;
        return { id: p.id, w };
    });
    const total = scored.reduce((s, x) => s + x.w, 0);
    let r = Math.random() * (total || 1);
    for (const x of scored) {
        r -= x.w;
        if (r <= 0) return x.id;
    }
    return scored.length ? scored[scored.length - 1].id : null;
}

function loadVocabPackFile(file) {
    if (!file) return Promise.reject(new Error("missing vocab file"));
    if (loadedVocabFiles[file]) return loadedVocabFiles[file];
    loadedVocabFiles[file] = new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = file;
        script.async = true;
        script.onload = () => resolve(true);
        script.onerror = () => reject(new Error(`load failed: ${file}`));
        document.head.appendChild(script);
    });
    return loadedVocabFiles[file];
}

function loadVocabPackFiles(files) {
    const list = Array.isArray(files) ? files.filter(Boolean) : (files ? [files] : []);
    if (!list.length) return Promise.resolve();
    return list.reduce((chain, file) => chain.then(() => loadVocabPackFile(file)), Promise.resolve());
}

function normalizeRawWord(raw) {
    if (!raw || typeof raw !== "object") return null;
    const en = String(raw.standardized || raw.word || "").trim();
    const zh = String(raw.chinese || raw.zh || raw.translation || "").trim();
    if (!en) return null;
    return {
        en,
        zh: zh || "",
        phrase: String(raw.phrase || "").trim() || null,
        phraseZh: String(raw.phraseTranslation || "").trim() || null,
        imageURLs: Array.isArray(raw.imageURLs) ? raw.imageURLs : []
    };
}

async function setActiveVocabPack(selection) {
    const engine = ensureVocabEngine();
    if (!engine) return false;
    const pickId = selection === "auto" || !selection ? pickPackAuto() : selection;
    const pack = pickId ? vocabPacks[pickId] : null;
    if (!pack) return false;

    activeVocabPackId = pack.id;
    vocabState.lastPackId = pack.id;
    if (!vocabState.runCounts) vocabState.runCounts = {};
    vocabState.runCounts[pack.id] = (vocabState.runCounts[pack.id] || 0) + 1;
    saveVocabState();

    try {
        if (pack.files && Array.isArray(pack.files)) {
            await loadVocabPackFiles(pack.files);
        } else if (pack.file) {
            await loadVocabPackFile(pack.file);
        }
        let rawList = [];
        if (typeof pack.getRaw === "function") {
            rawList = pack.getRaw();
        } else if (Array.isArray(pack.globals)) {
            rawList = pack.globals.flatMap(name => {
                const value = window[name];
                return Array.isArray(value) ? value : [];
            });
        }
        const mapped = [];
        const seen = new Set();
        (Array.isArray(rawList) ? rawList : []).forEach(r => {
            const w = normalizeRawWord(r);
            if (!w) return;
            if (seen.has(w.en)) return;
            seen.add(w.en);
            mapped.push(w);
        });
        const fallbackSource = Array.isArray(defaultWords) ? defaultWords : [];
        const fallbackWords = fallbackSource.map(w => normalizeRawWord(w)).filter(Boolean);
        const target = mapped.length ? mapped : fallbackWords;
        if (!target.length) {
            console.warn(`[Vocab] Pack ${pack.id} produced no words and no fallback data`);
        }
        if (target.length) {
            wordDatabase = target;
            wordPicker = null;
            const pr = getPackProgress(pack.id);
            pr.total = target.length;
            saveProgress();
        }
    } catch {
    }

        renderVocabSelect();
        updateVocabProgressUI();
        updateVocabPreview(activeVocabPackId || settings.vocabSelection);
    return true;
}

function switchToNextPackInOrder() {
    const engine = ensureVocabEngine();
    if (!engine) return false;
    const ids = vocabPackOrder.length ? vocabPackOrder : vocabManifest.packs.map(p => p.id);
    const idx = activeVocabPackId ? ids.indexOf(activeVocabPackId) : -1;
    const keepAuto = (settings.vocabSelection || "auto") === "auto";
    for (let step = 1; step <= ids.length; step++) {
        const nextId = ids[(idx + step + ids.length) % ids.length];
        if (!isPackCompleted(nextId)) {
            if (!keepAuto) {
                settings.vocabSelection = nextId;
                saveSettings();
            }
            setActiveVocabPack(nextId);
            return true;
        }
    }
    progress.vocab = {};
    saveProgress();
    const first = ids[0] || "auto";
    if (!keepAuto) {
        settings.vocabSelection = first;
        saveSettings();
    }
    setActiveVocabPack(first);
    return true;
}

function applySettingsToUI() {
    const visualViewport = getViewportSize();
    // Use the safe-area-adjusted game area for canvas + physics scaling.
    const gameArea = getGameAreaSize();
    applyConfig(gameArea);
    const viewportChanged = gameArea.width !== lastViewport.width || gameArea.height !== lastViewport.height;
    lastViewport = { width: gameArea.width, height: gameArea.height };

    const baseScale = Number(settings.uiScale) || 1.0;
    const uiScale = clamp(worldScale.unit * baseScale, 0.6, 2.2);
    document.documentElement.style.setProperty("--ui-scale", uiScale.toFixed(3));
    document.documentElement.style.setProperty("--vvw", `${Math.floor(visualViewport.width)}px`);
    document.documentElement.style.setProperty("--vvh", `${Math.floor(visualViewport.height)}px`);

    const container = document.getElementById("game-container");
    if (container) {
        container.style.transform = "none";
    }

    const touch = document.getElementById("touch-controls");
    if (touch) {
        const enabled = !!settings.touchControls;
        touch.classList.toggle("visible", enabled);
        touch.setAttribute("aria-hidden", enabled ? "false" : "true");
    }

    if (viewportChanged && startedOnce) {
        if (nowMs() < viewportIgnoreUntilMs) return;
        if (startOverlayActive || pausedByModal) return;
        paused = true;
        pausedByModal = true;
        setOverlay(true, "pause");
        showToast("å·²é€‚é…å±å¹•ï¼Œå·²æš‚åœæ¸¸æˆ");
    }
}

let applySettingsRaf = 0;
function scheduleApplySettingsToUI() {
    if (applySettingsRaf) return;
    applySettingsRaf = requestAnimationFrame(() => {
        applySettingsRaf = 0;
        applySettingsToUI();
    });
}

</script>
<script>
/**
 * 10-ui.js - UIè¦†ç›–å±‚ã€æ¸¸æˆç»“æŸã€å¤æ´»
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 2497-2836)
 */
function setOverlay(visible, mode) {
    const overlay = document.getElementById("screen-overlay");
    if (!overlay) return;
    const title = document.getElementById("overlay-title");
    const text = document.getElementById("overlay-text");
    const btn = document.getElementById("btn-overlay-action");
    const btnScoreRevive = document.getElementById("btn-overlay-score-revive");
    if (visible) {
        overlay.classList.add("visible");
        overlay.setAttribute("aria-hidden", "false");
        overlayMode = mode || "pause";
        if (mode === "start") {
            startOverlayActive = true;
            ensureStartOverlayContent();
            renderStartOverlayAccounts();
            updateStartOverlayActionState();
            setStartOverlayPage("intro");
            clearStartOverlayTimer();
            startOverlayTimer = setTimeout(() => setStartOverlayPage("setup"), START_OVERLAY_INTRO_MS);
            if (title) title.innerText = "Minecraft å•è¯æ¸¸æˆ";
            if (btnScoreRevive) btnScoreRevive.style.display = "none";
        } else if (mode === "pause") {
            if (title) title.innerText = "å·²æš‚åœ";
            if (text) text.innerHTML = START_OVERLAY_HINT_HTML;
            if (btn) btn.innerText = "ç»§ç»­";
            if (btnScoreRevive) btnScoreRevive.style.display = "none";
        } else if (mode === "gameover") {
            const diamonds = getDiamondCount();
            if (title) title.innerText = "ğŸ’€ æ¸¸æˆç»“æŸ";
            if (text) {
                const level = Math.max(1, Math.floor(score / 1000) + 1);
                const uniqueWords = getUniqueSessionWords();
                const wordListHtml = uniqueWords.length
                    ? uniqueWords.slice(0, 8).map(w =>
                        `<span style="display:inline-block;background:rgba(255,255,255,0.1);padding:2px 6px;margin:2px;border-radius:4px;font-size:12px;">${w.en}</span>`
                    ).join("")
                    : "æ— ";
                const moreText = uniqueWords.length > 8
                    ? `<span style="color:#888;font-size:11px;"> +${uniqueWords.length - 8}ä¸ª</span>`
                    : "";
                text.innerHTML =
                    `ğŸ“š å­¦ä¹ å•è¯: ${getLearnedWordCount()}<br>` +
                    `ğŸ’ é’»çŸ³: ${diamonds}<br>` +
                    `â­ å½“å‰ç§¯åˆ†: ${score}<br>` +
                    `âš”ï¸ å‡»æ€æ•Œäºº: ${enemyKillStats.total || 0}<br>` +
                    `ğŸ… ç©å®¶ç­‰çº§: ${level}<br>` +
                    `<div style="margin-top:8px;font-size:13px;color:#FFD54F;">æœ¬å±€å•è¯: ${wordListHtml}${moreText}</div>`;
            }
            if (btn) {
                const cfg = getReviveConfig();
                const diamondCost = Number(cfg.diamondCost) || 10;
                btn.innerText = diamonds >= diamondCost ? `ğŸ’${diamondCost} å¤æ´»` : "é‡æ–°å¼€å§‹";
            }
            if (btnScoreRevive) {
                const cfg = getReviveConfig();
                const scoreCost = Number(cfg.scoreCost) || 500;
                const enoughScore = score >= scoreCost;
                btnScoreRevive.style.display = "block";
                btnScoreRevive.disabled = !enoughScore;
                btnScoreRevive.innerText = enoughScore
                    ? `ç§¯åˆ†å¤æ´» (${scoreCost}åˆ†)`
                    : `ç§¯åˆ†å¤æ´» (éœ€è¦${scoreCost}åˆ†)`;
            }
        } else {
            if (title) title.innerText = "å‡†å¤‡å¼€å§‹";
            if (text) text.innerHTML = START_OVERLAY_HINT_HTML;
            if (btn) btn.innerText = "å¼€å§‹æ¸¸æˆ";
            if (btnScoreRevive) btnScoreRevive.style.display = "none";
        }
    } else {
        overlay.classList.remove("visible");
        overlay.setAttribute("aria-hidden", "true");
        if (overlayMode === "start") {
            clearStartOverlayTimer();
            startOverlayActive = false;
        }
        overlayMode = "start";
        if (btnScoreRevive) btnScoreRevive.style.display = "none";
    }
}
function triggerGameOver() {
    paused = true;
    showToast("ğŸ’€ ç”Ÿå‘½è€—å°½");
    onGameOver();
    if (maybeLaunchWordMatchRevive()) {
        return;
    }
    setOverlay(true, "gameover");
}
function maybeLaunchWordMatchRevive() {
    if (!settings.wordMatchEnabled || wordMatchActive || !matchLeftEl || !matchRightEl) return false;
    const words = getUniqueSessionWords();
    if (words.length < (LEARNING_CONFIG.wordMatch.wordCount || 5)) return false;
    activeWordMatch = new WordMatchGame(words);
    activeWordMatch.start();
    return true;
}

class WordMatchGame {
    constructor(words) {
        this.words = shuffle(words).slice(0, Math.max(1, LEARNING_CONFIG.wordMatch.wordCount || 5));
        this.leftItems = shuffle(this.words.map(w => ({ id: w.en, text: w.en, word: w })));
        this.rightItems = shuffle(this.words.map(w => ({ id: w.en, text: w.zh || w.en, word: w })));
        this.connections = [];
        this.selectedLeftId = null;
        this.timerMs = LEARNING_CONFIG.wordMatch.timeLimit || 30000;
        this.timerEndAt = 0;
        this.finished = false;
        this.attempts = 0;
        this.maxAttempts = 1;
    }

    start() {
        if (!wordMatchScreenEl) return;
        if (this.attempts >= this.maxAttempts) {
            showToast("å¤æ´»æœºä¼šå·²ç”¨å®Œ");
            setOverlay(true, "gameover");
            return;
        }
        this.attempts++;
        wordMatchActive = true;
        wordMatchScreenEl.classList.add("visible");
        this.render();
        this.startTimer();
    }

    render() {
        if (!matchLeftEl || !matchRightEl || !matchTotalEl) return;
        if (matchResultEl) {
            matchResultEl.classList.remove("visible");
            matchResultEl.innerText = "";
        }
        if (matchSubtitleEl) matchSubtitleEl.innerText = "å°†è‹±æ–‡ä¸ä¸­æ–‡æ‹‰çº¿è¿å¯¹ï¼Œåªæœ‰1æ¬¡æœºä¼š";
        matchLeftEl.innerHTML = this.leftItems.map(item => `<div class="match-item" data-id="${item.id}" data-type="en">${item.text}</div>`).join("");
        matchRightEl.innerHTML = this.rightItems.map(item => `<div class="match-item" data-id="${item.id}" data-type="zh">${item.text}</div>`).join("");
        matchTotalEl.innerText = String(this.words.length);
        this.bindEvents();
        this.updateMatchCount();
        this.drawLines();
        if (matchSubmitBtn) matchSubmitBtn.disabled = false;
    }

    bindEvents() {
        if (matchLeftEl) {
            matchLeftEl.querySelectorAll(".match-item").forEach(el => {
                el.addEventListener("click", () => this.selectLeft(el));
            });
        }
        if (matchRightEl) {
            matchRightEl.querySelectorAll(".match-item").forEach(el => {
                el.addEventListener("click", () => this.selectRight(el));
            });
        }
    }

    selectLeft(el) {
        if (!el) return;
        this.selectedLeftId = el.dataset.id;
        matchLeftEl.querySelectorAll(".match-item").forEach(item => item.classList.remove("selected"));
        el.classList.add("selected");
    }

    selectRight(el) {
        if (!el || !this.selectedLeftId) return;
        const leftId = this.selectedLeftId;
        const rightId = el.dataset.id;
        const existingIndex = this.connections.findIndex(conn => conn.left === leftId || conn.right === rightId);
        if (existingIndex >= 0) this.connections.splice(existingIndex, 1);
        this.connections.push({ left: leftId, right: rightId });
        this.selectedLeftId = null;
        matchLeftEl.querySelectorAll(".match-item").forEach(item => item.classList.remove("selected"));
        this.drawLines();
        this.updateMatchCount();
    }

    drawLines() {
        if (!matchLinesEl || !matchLeftEl || !matchRightEl) return;
        const container = document.querySelector(".match-container");
        if (!container) return;
        const containerRect = container.getBoundingClientRect();
        const lines = this.connections.map(conn => {
            const leftEl = matchLeftEl.querySelector(`[data-id="${conn.left}"]`);
            const rightEl = matchRightEl.querySelector(`[data-id="${conn.right}"]`);
            if (!leftEl || !rightEl) return "";
            const leftRect = leftEl.getBoundingClientRect();
            const rightRect = rightEl.getBoundingClientRect();
            const x1 = leftRect.right - containerRect.left;
            const y1 = leftRect.top + leftRect.height / 2 - containerRect.top;
            const x2 = rightRect.left - containerRect.left;
            const y2 = rightRect.top + rightRect.height / 2 - containerRect.top;
            const isCorrect = conn.left === conn.right;
            return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${isCorrect ? "#4CAF50" : "#FFCA28"}" stroke-width="3"/>`;
        }).join("");
        matchLinesEl.innerHTML = lines;
    }

    updateMatchCount() {
        if (matchCountEl) matchCountEl.innerText = String(this.connections.length);
    }

    startTimer() {
        this.stopTimer();
        this.timerEndAt = Date.now() + this.timerMs;
        if (matchTimerEl) matchTimerEl.innerText = String(Math.ceil(this.timerMs / 1000));
        wordMatchTimer = setInterval(() => {
            const remaining = this.timerEndAt - Date.now();
            if (matchTimerEl) matchTimerEl.innerText = String(Math.max(0, Math.ceil(remaining / 1000)));
            if (remaining <= 0) {
                this.submit();
            }
        }, 100);
    }

    stopTimer() {
        if (wordMatchTimer) {
            clearInterval(wordMatchTimer);
            wordMatchTimer = null;
        }
    }

    submit() {
        if (this.finished) return;
        this.finished = true;
        this.stopTimer();
        if (matchSubmitBtn) matchSubmitBtn.disabled = true;
        const correct = this.connections.filter(conn => conn.left === conn.right).length;
        const success = correct >= (LEARNING_CONFIG.wordMatch.minCorrectToRevive || 4);
        this.showResult(success, correct);
    }

    showResult(success, correctCount) {
        if (matchResultEl) {
            matchResultEl.classList.add("visible");
            matchResultEl.innerText = success
                ? `âœ… æ­£ç¡® ${correctCount} é“ï¼Œç¥ä½ å¤æ´»ï¼`
                : `âŒ æ­£ç¡® ${correctCount} é“ï¼Œå¤æ´»å¤±è´¥`;
        }
        if (matchSubtitleEl) {
            matchSubtitleEl.innerText = success ? "ç»§ç»­å‰è¡Œï¼" : "é‡æ•´æ——é¼“å†æ¥ä¸€æ¬¡";
        }
        if (success) {
            playerHp = Math.min(playerMaxHp, LEARNING_CONFIG.wordMatch.reviveHp || 3);
            addScore(correctCount * (LEARNING_CONFIG.wordMatch.bonusPerMatch || 10));
            updateHpUI();
            showToast("âœ¨ è¯è¯­åŒ¹é…å¤æ´»æˆåŠŸï¼");
            setTimeout(() => this.cleanup(true), 1200);
        } else {
            setTimeout(() => {
                this.cleanup(false);
                setOverlay(true, "gameover");
            }, 1400);
        }
    }

    cleanup(success) {
        this.stopTimer();
        wordMatchActive = false;
        activeWordMatch = null;
        if (matchResultEl) matchResultEl.classList.remove("visible");
        if (wordMatchScreenEl) wordMatchScreenEl.classList.remove("visible");
        if (success) {
            paused = false;
            setOverlay(false);
        }
    }
}
function resumeGameFromOverlay() {
    // Prevent an immediate mobile viewport change from reopening the start overlay.
    viewportIgnoreUntilMs = nowMs() + 2000;
    if (overlayMode === "start") {
        if (!currentAccount) {
            showToast("è¯·å…ˆé€‰æ‹©æˆ–åˆ›å»ºæ¡£æ¡ˆ");
            setStartOverlayPage("setup");
            const input = document.getElementById("overlay-username-input");
            input?.focus();
            return;
        }
        if (!startedOnce) {
            bootGameLoopIfNeeded();
        } else {
            paused = false;
            setOverlay(false);
        }
    } else if (overlayMode === "gameover") {
        if (getDiamondCount() >= 10) {
            inventory.diamond -= 10;
            playerHp = playerMaxHp;
            updateHpUI();
            updateDiamondUI();
            paused = false;
            startedOnce = true;
            setOverlay(false);
        } else {
            initGame();
            paused = false;
            startedOnce = true;
            setOverlay(false);
        }
    } else {
        paused = false;
        startedOnce = true;
        setOverlay(false);
    }
    const btnMix = document.getElementById("btn-repeat-pause");
    if (btnMix) btnMix.innerText = "ğŸ”Š é‡è¯»";
    repeatPauseState = "repeat";
}

function getReviveConfig() {
    const revive = (gameConfig && gameConfig.revive) || {};
    return {
        diamondCost: revive.diamondCost ?? 10,
        scoreCost: revive.scoreCost ?? 500,
        scoreReviveHpPercent: revive.scoreReviveHpPercent ?? 0.5,
        invincibleFrames: revive.invincibleFrames ?? 180
    };
}

function reviveWithScore() {
    const cfg = getReviveConfig();
    const cost = Number(cfg.scoreCost) || 500;
    if (score < cost) {
        showToast(`ç§¯åˆ†ä¸è¶³ï¼ˆéœ€è¦ ${cost} åˆ†ï¼‰`);
        return;
    }
    score -= cost;
    if (score < 0) score = 0;
    const scoreEl = document.getElementById("score");
    if (scoreEl) scoreEl.innerText = score;
    const hpPercent = Math.max(0, Math.min(1, Number(cfg.scoreReviveHpPercent) || 0.5));
    playerHp = Math.max(1, Math.floor(playerMaxHp * hpPercent));
    updateHpUI();
    playerInvincibleTimer = Number(cfg.invincibleFrames) || 180;
    paused = false;
    startedOnce = true;
    setOverlay(false);
    const px = player ? player.x : cameraX;
    const py = player ? player.y - 50 : canvas.height / 2;
    showFloatingText("ç§¯åˆ†å¤æ´»", px, py);
    showToast("ç§¯åˆ†å¤æ´»æˆåŠŸ");
}

function keyLabel(code) {
    if (!code) return "";
    if (code === "Space") return "ç©ºæ ¼";
    if (code.startsWith("Key") && code.length === 4) return code.slice(3);
    if (code.startsWith("Arrow")) return code.replace("Arrow", "æ–¹å‘");
    return code;
}

</script>
<script>
/**
 * 11-game-init.js - æ¸¸æˆåˆå§‹åŒ–ã€å…³å¡ç”Ÿæˆ
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 2837-3400)
 */
function applyMotionToPlayer(p) {
    if (!p) return;
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const scale = clamp(Number(settings.motionScale) || 1.0, 0.6, 2.0);
    p.baseSpeed = (Number(gameConfig.physics.movementSpeed) || 2.0) * scale;
    p.baseJumpStrength = (Number(gameConfig.physics.jumpStrength) || -7.0) * scale;
    p.speed = p.baseSpeed;
    p.jumpStrength = p.baseJumpStrength;
}

function createPlayer() {
    const p = {
        x: 100,
        y: 300,
        width: gameConfig.player.width,
        height: gameConfig.player.height,
        velX: 0,
        velY: 0,
        speed: gameConfig.physics.movementSpeed,
        jumpStrength: gameConfig.physics.jumpStrength,
        grounded: false,
        facingRight: true,
        jumpCount: 0,
        maxJumps: gameConfig.player.maxJumps,
        isAttacking: false,
        attackTimer: 0
    };
    applyMotionToPlayer(p);
    return p;
}

function initGame() {
    score = 0;
    levelScore = 0;
    runBestScore = 0;
    lastWordItemX = -Infinity;
    currentLevelIdx = 0;
    playerMaxHp = Number(gameConfig?.player?.maxHp) || 3;
    playerHp = playerMaxHp;
    lastDamageFrame = 0;
    difficultyState = null;
    sessionCollectedWords = [];
    wordGates = [];
    currentLearningChallenge = null;
    clearLearningChallengeTimer();
    hideLearningChallenge();
    wordMatchActive = false;
    if (wordMatchTimer) {
        clearInterval(wordMatchTimer);
        wordMatchTimer = null;
    }
    activeWordMatch = null;
    resetInventory();
    updateInventoryUI();
    player = createPlayer();
    bossSpawned = false;
    if (typeof bossArena !== 'undefined' && bossArena) {
        bossArena.active = false; bossArena.boss = null; bossArena.spawned = {};
    }
    if (typeof activeVillages !== 'undefined') activeVillages = [];
    if (typeof villageSpawnedForScore !== 'undefined') villageSpawnedForScore = {};
    if (typeof playerInVillage !== 'undefined') playerInVillage = false;
    if (typeof currentVillage !== 'undefined') currentVillage = null;
    startLevel(0);
    updateDifficultyState(true);
}

function startLevel(idx) {
    currentLevelIdx = idx;
    const level = levels[currentLevelIdx];
    canvas.style.backgroundColor = level.bg;
    const initBiome = getBiomeById(getBiomeIdForScore(getProgressScore()));
    currentBiome = initBiome.id;
    const info = document.getElementById("level-info");
    if (info) info.innerText = `ç”Ÿæ€: ${initBiome.name}`;
    platforms = [];
    trees = [];
    chests = [];
    items = [];
    decorations = [];
    particles = [];
    enemies = [];
    golems = [];
    digHits.clear();
    resetProjectiles();
    playerPositionHistory = [];
    lastGenX = 0;
    cameraX = 0;
    wordGates = [];
    sessionCollectedWords = [];
    updateHpUI();
    player.x = 100;
    player.y = 300;
    player.velX = 0;
    player.velY = 0;
    generatePlatform(0, 12, groundY);
}

function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function buildWordPicker() {
    const base = Array.isArray(wordDatabase) ? wordDatabase.filter(w => w && w.en) : [];
    let bag = shuffle(base);
    let cursor = 0;
    const INTERVALS = {
        correct_fast: [0, 5, 15, 40, 120, 300],
        correct_slow: [0, 3, 10, 28, 80, 220],
        wrong: [0, 1, 3, 8, 20, 60]
    };
    const stats = Object.create(null);
    const due = Object.create(null);
    const unseen = shuffle(base.map(w => w.en));
    let tick = 0;
    const byEn = Object.create(null);
    base.forEach(w => { byEn[w.en] = w; });
    function ensureStat(en) {
        if (!stats[en]) stats[en] = { count: 0, quality: "correct_slow" };
        return stats[en];
    }
    return {
        next(excludeSet) {
            if (!base.length) return { en: "word", zh: "å•è¯" };
            const excludes = excludeSet || new Set();
            tick++;

            for (let tries = 0; tries < unseen.length; tries++) {
                const en = unseen[0];
                if (!en) break;
                if (!excludes.has(en) && !stats[en]) {
                    unseen.shift();
                    const stat = ensureStat(en);
                    stat.count++;
                    const ivl = INTERVALS[stat.quality] || INTERVALS.correct_slow;
                    due[en] = tick + ivl[Math.min(stat.count, ivl.length - 1)];
                    return byEn[en] || base[0];
                }
                unseen.shift();
                unseen.push(en);
            }

            let best = null;
            let bestCount = Infinity;
            for (let i = 0; i < base.length; i++) {
                const w = bag[cursor++ % bag.length];
                if (!w || excludes.has(w.en)) continue;
                const nextDue = typeof due[w.en] === "number" ? due[w.en] : 0;
                if (nextDue > tick) continue;
                const c = stats[w.en]?.count || 0;
                if (c < bestCount) {
                    best = w;
                    bestCount = c;
                    if (bestCount === 0) break;
                } else if (c === bestCount && Math.random() < 0.25) {
                    best = w;
                }
            }
            const chosen = best || base[Math.floor(Math.random() * base.length)];
            const stat = ensureStat(chosen.en);
            stat.count++;
            const ivl = INTERVALS[stat.quality] || INTERVALS.correct_slow;
            due[chosen.en] = tick + ivl[Math.min(stat.count, ivl.length - 1)];
            return chosen;
        },
        updateWordQuality(en, quality) {
            if (!en) return;
            const stat = ensureStat(en);
            if (quality === "correct_fast" || quality === "correct_slow" || quality === "wrong") {
                stat.quality = quality;
            }
            if (quality === "wrong") due[en] = tick;
        }
    };
}

function ensureWordPicker() {
    if (!wordPicker) wordPicker = buildWordPicker();
}

function pickWordForSpawn() {
    ensureWordPicker();
    const exclude = new Set();
    if (settings.avoidWordRepeats) {
        items.forEach(i => { if (i && i.wordObj && i.wordObj.en) exclude.add(i.wordObj.en); });
        if (lastWord && lastWord.en) exclude.add(lastWord.en);
    }
    return wordPicker.next(exclude);
}

function clearOldWordItems() {
    items = items.filter(item => !(item && item.wordObj));
    lastWordItemX = cameraX - 100;
}

function spawnWordItemNearPlayer() {
    if (!player) return;
    const word = pickWordForSpawn();
    if (!word) return;
    const spawnX = player.x + 200;
    if (!canSpawnWordItemAt(spawnX)) return;
    const spawnY = player.y - 50;
    const item = new Item(spawnX, spawnY, word);
    items.push(item);
    registerWordItemSpawn(spawnX);
}

function getSpawnRates() {
    const s = gameConfig.spawn || {};
    let treeChance = s.treeChance ?? 0.2;
    let chestChance = s.chestChance ?? 0.35;
    let itemChance = s.itemChance ?? 0.55;
    let enemyChance = s.enemyChance ?? 0.7;

    if (settings.learningMode) {
        // Learning mode should reduce enemies, but not to the point that they vanish.
        enemyChance *= 0.6;
        treeChance *= 0.6;
        chestChance *= 0.8;
        itemChance = Math.min(0.85, itemChance * 1.2);
    }

    const diff = getDifficultyState();
    enemyChance *= diff.enemySpawnMult;
    chestChance *= diff.chestSpawnMult;

    const clamp01 = v => Math.max(0, Math.min(1, v));
    treeChance = clamp01(treeChance);
    chestChance = clamp01(Math.max(chestChance, treeChance));
    itemChance = clamp01(Math.max(itemChance, chestChance));
    enemyChance = clamp01(Math.max(enemyChance, itemChance));
    return { treeChance, chestChance, itemChance, enemyChance };
}

function canSpawnWordItemAt(x) {
    const minGap = Number(gameConfig?.spawn?.wordItemMinGap ?? 150) || 150;
    return Math.abs(x - lastWordItemX) >= minGap;
}

function registerWordItemSpawn(x) {
    lastWordItemX = x;
}

function estimateMaxJumpHeightPx() {
    const g = Math.max(0.05, Number(gameConfig?.physics?.gravity) || 0.2);
    const v1 = Math.abs(Number(player?.jumpStrength ?? gameConfig?.physics?.jumpStrength ?? -7));
    let h = (v1 * v1) / (2 * g);
    const maxJumps = Number(player?.maxJumps ?? gameConfig?.player?.maxJumps ?? 1);
    if (maxJumps >= 2) {
        const v2 = v1 * 0.8;
        h += (v2 * v2) / (2 * g);
    }
    if (!isFinite(h) || h <= 0) return 120;
    return h;
}

function generatePlatform(startX, length, groundYValue) {
    const level = levels[currentLevelIdx];
    const biome = getBiomeById(getBiomeIdForScore(getProgressScore()));
    const platformCfg = biome.platform || {};
    const groundType = biome.groundType || level.ground;
    const newWidth = length * blockSize;
    let merged = false;
    for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        if (p.y === groundYValue && p.type === groundType) {
            if (Math.abs((p.x + p.width) - startX) < 1.5) {
                p.width += newWidth;
                merged = true;
            }
            break;
        }
    }

    if (!merged) {
        platforms.push(new Platform(startX, groundYValue, newWidth, blockSize, groundType));
    }

    generateBiomeDecorations(startX, groundYValue, newWidth, biome);

    const floatChance = (gameConfig.spawn.floatingPlatformChance || 0) * (platformCfg.floatingChanceMult || 1);
    const floatItemChance = (gameConfig.spawn.floatingItemChance || 0) * (platformCfg.floatingItemChanceMult || 1);
    if (length > 5 && Math.random() < floatChance) {
        const floatLen = 2 + Math.floor(Math.random() * 3);
        const maxJump = estimateMaxJumpHeightPx() * 0.85;
        const minOffset = Math.max(50, Number(platformCfg.floatingMinOffset) || 100);
        const maxExtra = Math.max(0, Number(platformCfg.floatingMaxExtra) || 80);
        const maxOffset = Math.max(60, Math.min(minOffset + maxExtra, maxJump - 12));
        const baseOffset = Math.min(minOffset, maxOffset);
        const extra = Math.max(0, maxOffset - baseOffset);
        const floatY = Math.round((groundYValue - baseOffset - Math.random() * extra) / (blockSize / 2)) * (blockSize / 2);
        const floatX = startX + blockSize + Math.floor(Math.random() * (length - floatLen) * blockSize);
        const floatTypes = Array.isArray(platformCfg.floatingGroundTypes) && platformCfg.floatingGroundTypes.length ? platformCfg.floatingGroundTypes : [groundType];
        const floatType = floatTypes[Math.floor(Math.random() * floatTypes.length)] || groundType;
        platforms.push(new Platform(floatX, floatY, floatLen * blockSize, blockSize, floatType));
        const floatItemX = floatX + blockSize / 2;
        if (Math.random() < floatItemChance && canSpawnWordItemAt(floatItemX)) {
            const word = pickWordForSpawn();
            items.push(new Item(floatItemX, floatY - 50, word));
            registerWordItemSpawn(floatItemX);
        }
    }

    const microChance = Number(platformCfg.microPlatformChance) || 0;
    const microPeriod = Math.max(1, Number(platformCfg.microPlatformPeriod) || 1);
    const microSegment = Math.floor(startX / (blockSize * 6));
    const allowMicro = microSegment % microPeriod === 0;
    if (microChance > 0 && allowMicro && Math.random() < microChance && newWidth >= blockSize * 4) {
        const maxCount = Math.max(1, Number(platformCfg.microPlatformMaxCount) || 2);
        const count = 1 + Math.floor(Math.random() * maxCount);
        const microType = platformCfg.microPlatformType || "grass";
        const pattern = String(platformCfg.microPattern || "stair").toLowerCase();
        const maxJumpBlocks = Math.max(1, Math.floor((estimateMaxJumpHeightPx() * 0.85) / blockSize));
        const maxRiseBlocks = Math.max(1, Math.min(maxJumpBlocks, Number(platformCfg.microMaxRiseBlocks) || 2));

        if (pattern === "stair") {
            const steps = Math.max(1, Math.min(count, maxRiseBlocks));
            const minX = startX + blockSize;
            const maxX = startX + newWidth - blockSize * (steps + 1);
            if (maxX > minX) {
                let stairX0 = minX + Math.random() * (maxX - minX);
                stairX0 = Math.floor(stairX0 / blockSize) * blockSize;
                for (let i = 0; i < steps; i++) {
                    const mx = stairX0 + i * blockSize;
                    const my = groundYValue - (i + 1) * blockSize;
                    platforms.push(new Platform(mx, my, blockSize, blockSize, microType));
                }
                const topX = stairX0 + (steps - 1) * blockSize + blockSize / 2;
                if (Math.random() < (platformCfg.microItemChance || 0) && canSpawnWordItemAt(topX)) {
                    const word = pickWordForSpawn();
                    const topY = groundYValue - steps * blockSize - 50;
                    items.push(new Item(topX, topY, word));
                    registerWordItemSpawn(topX);
                }
            }
        } else {
            // fallback: random but clamped to be reachable
            const maxJump = estimateMaxJumpHeightPx() * 0.85;
            const minOffset = Math.max(50, Number(platformCfg.microPlatformMinOffset) || 80);
            const maxExtra = Math.max(0, Number(platformCfg.microPlatformMaxExtra) || 60);
            const maxOffset = Math.max(60, Math.min(minOffset + maxExtra, maxJump - 12));
            const baseOffset = Math.min(minOffset, maxOffset);
            const extra = Math.max(0, maxOffset - baseOffset);
            for (let i = 0; i < count; i++) {
                let mx = startX + blockSize + Math.random() * (newWidth - blockSize * 2);
                mx = Math.floor(mx / blockSize) * blockSize;
                const my = Math.round((groundYValue - baseOffset - Math.random() * extra) / (blockSize / 2)) * (blockSize / 2);
                platforms.push(new Platform(mx, my, blockSize, blockSize, microType));
                const spawnX = mx + blockSize / 2;
                if (Math.random() < (platformCfg.microItemChance || 0) && canSpawnWordItemAt(spawnX)) {
                    const word = pickWordForSpawn();
                    items.push(new Item(spawnX, my - 50, word));
                    registerWordItemSpawn(spawnX);
                }
            }
        }
    }

    if (startX > 400) {
        const objectX = startX + 100 + Math.random() * (length * blockSize - 150);
        const inVillage = typeof isInVillageArea === 'function' && isInVillageArea(objectX);
        const rand = Math.random();
        const rates = getSpawnRates();
        const enemyConfig = getEnemyConfig();
        let enemyChance = rates.enemyChance;
        if (enemyConfig.spawnChance != null) {
            let extra = enemyConfig.spawnChance;
            if (settings.learningMode) extra *= 0.6;
            enemyChance = Math.min(1, Math.max(enemyChance, rates.itemChance + extra));
        }
        enemyChance = Math.min(1, Math.max(enemyChance, rates.itemChance));
        if (inVillage) {
            // Village: no enemies, more words and chests
            if (rand < 0.4 && canSpawnWordItemAt(objectX)) {
                const word = pickWordForSpawn();
                items.push(new Item(objectX, groundYValue - 60, word));
                registerWordItemSpawn(objectX);
            } else if (rand < 0.6) {
                chests.push(new Chest(objectX, groundYValue));
            }
        } else if (rand < rates.treeChance) {
            spawnBiomeTree(objectX, groundYValue, biome, level.treeType);
        } else if (rand < rates.chestChance) {
            chests.push(new Chest(objectX, groundYValue));
        } else if (rand < rates.itemChance && canSpawnWordItemAt(objectX)) {
            const word = pickWordForSpawn();
            items.push(new Item(objectX, groundYValue - 60, word));
            registerWordItemSpawn(objectX);
        } else if (settings.wordGateEnabled && Math.random() < LEARNING_CONFIG.wordGate.spawnChance && getProgressScore() >= (LEARNING_CONFIG.wordGate.minScore || 0)) {
            const gateWord = pickWordForSpawn();
            if (gateWord) wordGates.push(new WordGate(objectX, groundYValue - 20, gateWord));
        } else if (rand < enemyChance) {
            spawnEnemyByDifficulty(objectX, groundYValue - 32);
        }
    }

    lastGenX = startX + length * blockSize;
}

function spawnEnemyByDifficulty(x, y) {
    const enemyConfig = getEnemyConfig();
    const step = Number(getBiomeSwitchConfig().stepScore) || 200;
    const tier = Math.max(0, Math.floor((Number(getProgressScore()) || 0) / Math.max(1, step)));
    const biomePools = {
        forest: ["zombie", "creeper", "spider", "skeleton", "enderman"],
        snow: ["zombie", "skeleton", "creeper", "spider", "enderman"],
        desert: ["zombie", "creeper", "skeleton", "spider", "enderman"],
        mountain: ["zombie", "skeleton", "enderman", "creeper", "spider"],
        ocean: ["drowned", "pufferfish"],
        nether: ["zombie", "piglin", "skeleton", "creeper", "enderman"],
        mushroom_island: ["spore_bug", "bee", "fox"]
    };
    const basePool = biomePools[currentBiome] || ["zombie", "creeper", "spider", "skeleton", "enderman"];
    const take = Math.max(2, Math.min(basePool.length, 2 + tier));
    let pool = basePool.slice(0, take).filter(t => ENEMY_STATS[t]);
    if (getProgressScore() < 3000) {
        pool = pool.filter(t => t !== "enderman");
    }

    const aliveEnemies = enemies.filter(e => !e.remove && e.y < 900).length;
    if (aliveEnemies >= (enemyConfig.maxOnScreen || 8)) return;

    const type = pool.length ? pool[Math.floor(Math.random() * pool.length)] : "zombie";
    enemies.push(new Enemy(x, y, type));
}

function weightedPick(table) {
    const entries = Object.entries(table || {});
    if (!entries.length) return null;
    const total = entries.reduce((sum, [, w]) => sum + w, 0);
    let r = Math.random() * (total || 1);
    for (const [key, w] of entries) {
        r -= w;
        if (r <= 0) return key;
    }
    return entries[entries.length - 1][0];
}

function pickWeightedLoot(table) {
    if (!table || !table.length) return null;
    const total = table.reduce((sum, entry) => sum + (entry.weight || 0), 0);
    let r = Math.random() * (total || 1);
    for (const entry of table) {
        r -= (entry.weight || 0);
        if (r <= 0) return entry;
    }
    return table[table.length - 1];
}

function pickChestRarity(rarities, rareBoost) {
    if (!rarities || !rarities.length) return "common";
    const boost = Number(rareBoost) || 0;
    const adjusted = rarities.map((r, idx) => {
        const base = Number(r.weight) || 1;
        const mult = 1 + boost * idx;
        return { ...r, weight: Math.max(1, base * mult) };
    });
    const picked = pickWeightedLoot(adjusted);
    return picked?.id || "common";
}

function spawnBiomeTree(x, yPos, biome, fallbackType) {
    if (biome && biome.id === "ocean") {
        spawnDecoration("seaweed", obj => obj.reset(x, yPos - 30), () => new Seaweed(x, yPos - 30));
        return;
    }
    const type = weightedPick(biome.treeTypes) || fallbackType || "oak";
    trees.push(new Tree(x, yPos, type));
}

function generateBiomeDecorations(x, yPos, width, biome) {
    const decorConfig = biome.decorations || {};
    Object.entries(decorConfig).forEach(([decorType, probability]) => {
        if (Math.random() >= probability) return;
        const decorX = x + Math.random() * width;
        switch (decorType) {
            case "tree":
                spawnBiomeTree(decorX, yPos, biome);
                break;
            case "spruce":
            case "pine":
            case "palm_tree":
                spawnBiomeTree(decorX, yPos, biome);
                break;
            case "bush":
                spawnDecoration("bush", obj => obj.reset(decorX, yPos - 20), () => new Bush(decorX, yPos - 20));
                break;
            case "flower":
                spawnDecoration("flower", obj => obj.reset(decorX, yPos - 18), () => new Flower(decorX, yPos - 18));
                break;
            case "mushroom":
                spawnDecoration("mushroom", obj => obj.reset(decorX, yPos - 20), () => new Mushroom(decorX, yPos - 20));
                break;
            case "vine":
                spawnDecoration("vine", obj => obj.reset(decorX, yPos - 80, 40 + Math.random() * 30), () => new Vine(decorX, yPos - 80, 40 + Math.random() * 30));
                break;
            case "ice_spike":
                spawnDecoration("ice_spike", obj => obj.reset(decorX, yPos - 80), () => new IceSpike(decorX, yPos - 80));
                break;
            case "snow_pile": {
                const size = ["small", "medium", "large"][Math.floor(Math.random() * 3)];
                spawnDecoration("snow_pile", obj => obj.reset(decorX, yPos - 25, size), () => new SnowPile(decorX, yPos - 25, size));
                break;
            }
            case "ice_block": {
                const blockWidth = 60 + Math.random() * 80;
                spawnDecoration("ice_block", obj => obj.reset(decorX, yPos - 50, blockWidth), () => new IceBlock(decorX, yPos - 50, blockWidth));
                break;
            }
            case "cactus":
                spawnDecoration("cactus", obj => obj.reset(decorX, yPos - 100), () => new CactusDecor(decorX, yPos - 100));
                break;
            case "dead_bush":
                spawnDecoration("dead_bush", obj => obj.reset(decorX, yPos - 30), () => new DeadBush(decorX, yPos - 30));
                break;
            case "rock": {
                const size = ["small", "medium", "large"][Math.floor(Math.random() * 3)];
                spawnDecoration("rock", obj => obj.reset(decorX, yPos - 30, size), () => new Rock(decorX, yPos - 30, size));
                break;
            }
            case "bones":
                spawnDecoration("bones", obj => obj.reset(decorX, yPos - 12), () => new BoneDecor(decorX, yPos - 12));
                break;
            case "ore_coal":
            case "ore_iron":
            case "ore_gold":
            case "ore_diamond": {
                const oreType = decorType.replace("ore_", "");
                spawnDecoration(decorType, obj => obj.reset(decorX, yPos - 30, oreType), () => new Ore(decorX, yPos - 30, oreType));
                break;
            }
            case "stalactite": {
                const direction = Math.random() > 0.5 ? "down" : "up";
                spawnDecoration("stalactite", obj => obj.reset(decorX, direction === "down" ? yPos - 100 : yPos - 20, direction), () => new Stalactite(decorX, direction === "down" ? yPos - 100 : yPos - 20, direction));
                break;
            }
            case "crystal":
                spawnDecoration("crystal", obj => obj.reset(decorX, yPos - 28), () => new Crystal(decorX, yPos - 28));
                break;
            case "lava_pool": {
                const poolWidth = 60 + Math.random() * 80;
                spawnDecoration("lava_pool", obj => obj.reset(decorX, yPos - 16, poolWidth, biome.id), () => new LavaPool(decorX, yPos - 16, poolWidth, biome.id));
                break;
            }
            case "palm_tree":
                spawnBiomeTree(decorX, yPos, biome);
                break;
            case "shell":
                spawnDecoration("shell", obj => obj.reset(decorX, yPos - 10), () => new Shell(decorX, yPos - 10));
                break;
            case "starfish":
                spawnDecoration("starfish", obj => obj.reset(decorX, yPos - 12), () => new Starfish(decorX, yPos - 12));
                break;
            case "seaweed":
                spawnDecoration("seaweed", obj => obj.reset(decorX, yPos - 30), () => new Seaweed(decorX, yPos - 30));
                break;
            case "boat":
                spawnDecoration("boat", obj => obj.reset(decorX, yPos - 18), () => new BoatDecor(decorX, yPos - 18));
                break;
            case "fire":
                spawnDecoration("fire", obj => obj.reset(decorX, yPos - 24), () => new FireDecor(decorX, yPos - 24));
                break;
            case "lava_fall":
                spawnDecoration("lava_fall", obj => obj.reset(decorX, yPos - 120), () => new LavaFall(decorX, yPos - 120));
                break;
            case "soul_sand": {
                const sandWidth = 40 + Math.random() * 60;
                spawnDecoration("soul_sand", obj => obj.reset(decorX, yPos - 10, sandWidth), () => new SoulSand(decorX, yPos - 10, sandWidth));
                break;
            }
            case "nether_wart":
                spawnDecoration("nether_wart", obj => obj.reset(decorX, yPos - 10), () => new NetherWart(decorX, yPos - 10));
                break;
            case "basalt":
                spawnDecoration("basalt", obj => obj.reset(decorX, yPos - 40), () => new Basalt(decorX, yPos - 40));
                break;
            default:
                break;
        }
    });
}

function updateMapGeneration() {
    if (player.x + mapBuffer > lastGenX) {
        if (Math.random() < 0.05) {
            lastGenX += 80 + Math.random() * 40;
        }
        const length = Math.floor(4 + Math.random() * 7);
        generatePlatform(lastGenX, length, groundY);
    }
    platforms = platforms.filter(p => p.x + p.width > cameraX - removeThreshold);
    trees = trees.filter(t => t.x + t.width > cameraX - removeThreshold && !t.remove);
    chests = chests.filter(c => c.x + 40 > cameraX - removeThreshold);
    items = items.filter(i => i.x + 30 > cameraX - removeThreshold && !i.collected);
    enemies = enemies.filter(e => e.x + e.width > cameraX - removeThreshold && !e.remove && e.y < 1000);
}

</script>
<script>
/**
 * 12-challenges.js - å•è¯æ”¶é›†ä¸å­¦ä¹ æŒ‘æˆ˜
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 3401-3817)
 */
function dropItem(type, x, y) {
    if (!inventory[type] && inventory[type] !== 0) inventory[type] = 0;
    inventory[type]++;
    updateInventoryUI();
    const icon = ITEM_ICONS[type] || "+";
    showFloatingText(`${icon} +1`, x, y);
}

function bumpWordDisplay() {
    const el = document.getElementById("word-display");
    if (!el) return;
    el.style.transform = "scale(1.15)";
    setTimeout(() => { el.style.transform = "scale(1)"; }, 160);
}

let challengeStartedAt = 0;

function showWordCard(wordObj) {
    const card = document.getElementById("word-card");
    if (!card) return;
    const en = document.getElementById("word-card-en");
    const zh = document.getElementById("word-card-zh");
    const phraseEl = document.getElementById("word-card-phrase");
    if (en) en.innerText = wordObj.en;
    if (zh) zh.innerText = wordObj.zh;
    if (phraseEl) {
        if (wordObj.phrase) {
            phraseEl.innerText = wordObj.phrase;
            phraseEl.style.display = "block";
        } else {
            phraseEl.style.display = "none";
        }
    }
    updateWordImage(wordObj);
    card.classList.add("visible");
    card.setAttribute("aria-hidden", "false");
    setTimeout(() => {
        card.classList.remove("visible");
        card.setAttribute("aria-hidden", "true");
    }, settings.wordCardDuration || 900);
}

function recordWordProgress(wordObj) {
    if (!wordObj || !wordObj.en) return;
    const en = String(wordObj.en);
    sessionWordCounts[en] = (sessionWordCounts[en] || 0) + 1;

    if (!activeVocabPackId) return;
    const pr = getPackProgress(activeVocabPackId);
    if (!pr.total) pr.total = Array.isArray(wordDatabase) ? wordDatabase.length : 0;
    if (!pr.unique[en]) {
        pr.unique[en] = 1;
        pr.uniqueCount = (pr.uniqueCount || 0) + 1;
        onWordCollected(wordObj);
        if (pr.total && pr.uniqueCount >= pr.total) {
            pr.completed = true;
            saveProgress();
            updateVocabProgressUI();
            const pack = vocabPacks[activeVocabPackId];
            showToast(`${pack?.title || activeVocabPackId} å·²å®Œæˆï¼Œåˆ‡æ¢ä¸‹ä¸€ä¸ªè¯åº“`);
            switchToNextPackInOrder();
            return;
        }
        saveProgress();
        updateVocabProgressUI();
    }
}

function registerCollectedWord(wordObj) {
    if (!wordObj || !wordObj.en) return;
    sessionCollectedWords.push(wordObj);
}

function getUniqueSessionWords() {
    const seen = new Set();
    return sessionCollectedWords.filter(w => {
        if (!w || !w.en) return false;
        if (seen.has(w.en)) return false;
        seen.add(w.en);
        return true;
    });
}

function generateLetterOptions(correctLetter, count = 4) {
    const options = [correctLetter];
    const similarLetters = {
        a: ["e", "o", "u"],
        b: ["d", "p", "q"],
        c: ["o", "e", "g"],
        d: ["b", "p", "q"],
        e: ["a", "o", "c"],
        i: ["l", "j", "t"],
        l: ["i", "t", "j"],
        m: ["n", "w", "v"],
        n: ["m", "h", "u"],
        o: ["a", "e", "c"],
        p: ["b", "d", "q"],
        q: ["p", "g", "o"],
        s: ["z", "c", "x"],
        t: ["i", "l", "f"],
        u: ["v", "n", "w"],
        v: ["u", "w", "y"],
        w: ["v", "m", "n"],
        z: ["s", "x", "y"]
    };
    const similar = similarLetters[correctLetter] || [];
    for (const letter of similar) {
        if (options.length >= count) break;
        if (!options.includes(letter)) options.push(letter);
    }
    const allLetters = "abcdefghijklmnopqrstuvwxyz";
    while (options.length < count) {
        const rand = allLetters[Math.floor(Math.random() * allLetters.length)];
        if (!options.includes(rand)) options.push(rand);
    }
    return options;
}

function generateFillBlankChallenge(wordObj) {
    const enRaw = String(wordObj?.en || "").toLowerCase();
    const en = enRaw.replace(/[^a-z]/g, "");
    if (!en) return null;
    const minIndex = en.length > 2 ? 1 : 0;
    const maxIndex = en.length > 2 ? en.length - 2 : Math.max(0, en.length - 1);
    const missingIndex = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;
    const missingLetter = en[missingIndex];
    const wordDisplay = en.split("").map((char, i) => (i === missingIndex ? "_" : char)).join(" ");
    const options = generateLetterOptions(missingLetter, 4);
    return {
        mode: "fill_blank",
        questionHtml:
            `<div class="challenge-fill">` +
            `<div class="challenge-fill-word">${wordDisplay}</div>` +
            `<div class="challenge-fill-hint">ç¼ºå°‘å“ªä¸ªå­—æ¯ï¼Ÿ</div>` +
            `<div class="challenge-fill-zh">${wordObj?.zh || wordObj?.en || ""}</div>` +
            `</div>`,
        options: shuffle(options).map(letter => ({ text: letter, value: letter, correct: letter === missingLetter })),
        answer: missingLetter
    };
}

function generateMultiBlankChallenge(wordObj) {
    const enRaw = String(wordObj?.en || "").toLowerCase();
    const en = enRaw.replace(/[^a-z]/g, "");
    if (en.length < 4) return generateFillBlankChallenge(wordObj);
    const blankCount = Math.min(2, Math.floor(en.length / 3));
    const positions = [];
    const available = [];
    for (let i = 1; i < en.length - 1; i++) available.push(i);
    for (let b = 0; b < blankCount && available.length > 0; b++) {
        const idx = Math.floor(Math.random() * available.length);
        const pos = available[idx];
        positions.push(pos);
        available.splice(idx, 1);
        const adjPrev = available.indexOf(pos - 1);
        if (adjPrev >= 0) available.splice(adjPrev, 1);
        const adjNext = available.indexOf(pos + 1);
        if (adjNext >= 0) available.splice(adjNext, 1);
    }
    positions.sort((a, b) => a - b);
    const missingLetters = positions.map(i => en[i]);
    const wordDisplay = en.split("").map((ch, i) => (positions.includes(i) ? "_" : ch)).join(" ");
    const correctAnswer = missingLetters.join("");
    const options = [correctAnswer];
    while (options.length < 4) {
        const fake = missingLetters.map(() => {
            const all = "abcdefghijklmnopqrstuvwxyz";
            return all[Math.floor(Math.random() * all.length)];
        }).join("");
        if (!options.includes(fake)) options.push(fake);
    }
    return {
        mode: "fill_blank",
        questionHtml:
            `<div class="challenge-fill">` +
            `<div class="challenge-fill-word">${wordDisplay}</div>` +
            `<div class="challenge-fill-hint">å¡«å…¥ç¼ºå°‘çš„${blankCount}ä¸ªå­—æ¯</div>` +
            `<div class="challenge-fill-zh">${wordObj?.zh || ""}</div>` +
            `</div>`,
        options: shuffle(options).map(opt => ({ text: opt, value: opt, correct: opt === correctAnswer })),
        answer: correctAnswer
    };
}

function generateScrambleDistractors(en, count) {
    const distractors = [];
    const pool = Array.isArray(wordDatabase) ? wordDatabase : [];
    const candidates = pool.filter(w => w.en && w.en !== en && Math.abs(w.en.length - en.length) <= 2);
    const picked = shuffle(candidates).slice(0, count);
    picked.forEach(w => {
        distractors.push({ text: w.en.toLowerCase(), value: w.en.toLowerCase(), correct: false });
    });
    while (distractors.length < count) {
        const fake = shuffle(en.split("")).join("");
        if (fake !== en && !distractors.find(d => d.text === fake)) {
            distractors.push({ text: fake, value: fake, correct: false });
        }
    }
    return distractors;
}

function generateUnscrambleChallenge(wordObj) {
    const enRaw = String(wordObj?.en || "").toLowerCase();
    const en = enRaw.replace(/[^a-z]/g, "");
    if (en.length < 3) return generateFillBlankChallenge(wordObj);
    let scrambled = shuffle(en.split(""));
    let tries = 0;
    while (scrambled.join("") === en && tries < 10) {
        scrambled = shuffle(en.split(""));
        tries++;
    }
    return {
        mode: "fill_blank",
        questionHtml:
            `<div class="challenge-fill">` +
            `<div class="challenge-fill-word" style="letter-spacing:8px; color:#FFD54F;">${scrambled.join(" ")}</div>` +
            `<div class="challenge-fill-hint">é‡æ–°æ’åˆ—å­—æ¯ï¼Œæ‹¼å‡ºæ­£ç¡®å•è¯</div>` +
            `<div class="challenge-fill-zh">${wordObj?.zh || ""}</div>` +
            `</div>`,
        options: shuffle([
            { text: en, value: en, correct: true },
            ...generateScrambleDistractors(en, 3)
        ]),
        answer: en
    };
}

const CHALLENGE_TYPES = {
    translate(wordObj) {
        const options = generateChallengeOptions(wordObj, "zh", LEARNING_CONFIG.challenge.baseOptions);
        return {
            mode: "options",
            question: `Translate "${wordObj.en}"`,
            options,
            answer: wordObj.zh || wordObj.en
        };
    },
    listen(wordObj) {
        const options = generateChallengeOptions(wordObj, "en", LEARNING_CONFIG.challenge.baseOptions);
        return {
            mode: "options",
            question: "å¬éŸ³é€‰æ‹©æ­£ç¡®çš„å•è¯",
            options,
            answer: wordObj.en
        };
    },
    fill_blank(wordObj) {
        return generateFillBlankChallenge(wordObj);
    },
    multi_blank(wordObj) {
        return generateMultiBlankChallenge(wordObj);
    },
    unscramble(wordObj) {
        return generateUnscrambleChallenge(wordObj);
    }
};

const CHALLENGE_TYPE_KEYS = ["translate", "listen", "fill_blank", "multi_blank", "unscramble"];

function generateChallengeOptions(wordObj, key, count) {
    const distinct = pickDistinctWords(wordObj, count);
    const baseValue = key === "zh" ? wordObj.zh || wordObj.en : wordObj.en;
    const options = [{ text: baseValue, value: baseValue, correct: true }];
    distinct.forEach(entry => {
        const value = key === "zh" ? entry.zh || entry.en : entry.en || entry.zh;
        if (!value) return;
        options.push({ text: value, value, correct: false });
    });
    return shuffle(options).slice(0, Math.max(2, options.length));
}

function pickDistinctWords(wordObj, count) {
    if (!Array.isArray(wordDatabase) || !wordDatabase.length) return [];
    const pool = wordDatabase.filter(w => w && w.en && w.en !== wordObj.en);
    return shuffle(pool).slice(0, Math.max(0, count));
}

function shouldTriggerLearningChallenge(wordObj) {
    if (!settings.learningMode) return false;
    if (!settings.challengeEnabled || currentLearningChallenge) return false;
    if (!wordObj || !wordObj.en) return false;
    const freq = Number(settings.challengeFrequency ?? 0.3);
    if (Math.random() >= Math.max(0.1, Math.min(0.9, freq))) return false;
    return true;
}

function maybeTriggerLearningChallenge(wordObj) {
    if (!wordObj || !wordObj.en) return;
    registerCollectedWord(wordObj);

    // === v1.6.1 æ–°å¢ï¼šå¦‚æœå®ç®±å­¦ä¹ å·²å¼€å¯ï¼Œä¸å†éšæœºå¼¹å‡º Challenge ===
    // é¿å…åŒé‡æ‰“æ–­å¿ƒæµï¼Œä¿ç•™ WordGate è§¦å‘ä¸å—å½±å“
    if (settings.chestLearningEnabled) {
        return;
    }
    // === v1.6.1 ç»“æŸ ===

    if (!shouldTriggerLearningChallenge(wordObj)) return;
    startLearningChallenge(wordObj);
}

function pickChallengeType(forced) {
    if (forced && CHALLENGE_TYPES[forced]) return forced;
    return CHALLENGE_TYPE_KEYS[Math.floor(Math.random() * CHALLENGE_TYPE_KEYS.length)];
}

function startLearningChallenge(wordObj, forcedType, origin) {
    const type = pickChallengeType(forcedType);
    const handler = CHALLENGE_TYPES[type];
    if (!handler) return;
    const payload = handler(wordObj);
    if (!payload) return;
    payload.type = type;
    payload.wordObj = wordObj;
    currentLearningChallenge = payload;
    challengeOrigin = origin || null;
    challengePausedBefore = paused;
    paused = true;
    challengeStartedAt = Date.now();
    showLearningChallenge(payload);
    challengeDeadline = Date.now() + (LEARNING_CONFIG.challenge.timeLimit || 10000);
    updateChallengeTimerDisplay();
    clearLearningChallengeTimer();
    challengeTimerId = setInterval(() => {
        const remaining = challengeDeadline - Date.now();
        if (remaining <= 0) {
            completeLearningChallenge(false);
        } else {
            updateChallengeTimerDisplay();
        }
    }, 250);
}

function showLearningChallenge(challenge) {
    if (!challengeModalEl) return;
    challengeModalEl.classList.add("visible");
    if (challengeQuestionEl) {
        if (challenge.questionHtml) {
            challengeQuestionEl.innerHTML = challenge.questionHtml;
        } else {
            challengeQuestionEl.innerText = challenge.question || "";
        }
    }
    const isInput = challenge.mode === "input";
    if (challengeInputWrapperEl) {
        challengeInputWrapperEl.classList.toggle("active", isInput);
        if (isInput && challengeInputEl) {
            challengeInputEl.value = "";
            challengeInputEl.focus();
        }
    }
    if (challengeOptionsEl) {
        challengeOptionsEl.innerHTML = "";
        if (challenge.options && challenge.options.length && !isInput) {
            challenge.options.forEach(option => {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.innerText = option.text;
                btn.className = challenge.mode === "fill_blank"
                    ? "challenge-option letter-option"
                    : "challenge-option";
                btn.addEventListener("click", () => {
                    completeLearningChallenge(option.correct);
                });
                challengeOptionsEl.appendChild(btn);
            });
        }
    }
    if (challengeRepeatBtn) {
        challengeRepeatBtn.style.display = challenge.type === "listen" ? "inline-flex" : "none";
    }
}

function updateChallengeTimerDisplay() {
    if (!challengeTimerEl || !currentLearningChallenge) return;
    const remaining = Math.max(0, Math.ceil((challengeDeadline - Date.now()) / 1000));
    challengeTimerEl.innerText = String(remaining);
}

function clearLearningChallengeTimer() {
    if (challengeTimerId) {
        clearInterval(challengeTimerId);
        challengeTimerId = null;
    }
}

function hideLearningChallenge() {
    if (challengeModalEl) challengeModalEl.classList.remove("visible");
    if (challengeInputEl) challengeInputEl.value = "";
}

function showChallengeCorrection(wordObj) {
    if (!wordObj || !challengeQuestionEl) return;
    const existed = challengeQuestionEl.querySelector(".challenge-correction");
    if (existed) existed.remove();
    const correctionDiv = document.createElement("div");
    correctionDiv.className = "challenge-correction";
    correctionDiv.innerHTML =
        `<div style="margin-top:12px; padding:8px; background:rgba(76,175,80,0.2); border-radius:8px;">` +
        `<div style="color:#4CAF50; font-size:14px;">æ­£ç¡®ç­”æ¡ˆ:</div>` +
        `<div style="color:#FFF; font-size:18px; font-weight:bold; margin-top:4px;">${wordObj.en} = ${wordObj.zh || ""}</div>` +
        (wordObj.phrase ? `<div style="color:#FFD54F; font-size:12px; margin-top:4px;">${wordObj.phrase}</div>` : "") +
        `</div>`;
    challengeQuestionEl.appendChild(correctionDiv);
    if (challengeOptionsEl) {
        challengeOptionsEl.querySelectorAll("button").forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = "0.5";
        });
    }
    if (typeof speakWord === "function") speakWord(wordObj);
}

function completeLearningChallenge(correct) {
    if (!currentLearningChallenge) return;
    clearLearningChallengeTimer();
    const reward = LEARNING_CONFIG.challenge.rewards;
    const wordObj = currentLearningChallenge.wordObj;

    // === æ–°å¢ï¼šè®°å½•ç­”é¢˜ç»Ÿè®¡ (v1.6.0) ===
    const wordEn = currentLearningChallenge?.wordObj?.en;
    if (wordEn) {
        if (!progress.challengeStats) progress.challengeStats = {};
        const stat = progress.challengeStats[wordEn] || {
            correct: 0,
            wrong: 0,
            lastSeen: 0
        };

        if (correct) {
            stat.correct++;
        } else {
            stat.wrong++;
        }
        stat.lastSeen = Date.now();

        progress.challengeStats[wordEn] = stat;
        saveProgress();
    }
    // === è®°å½•ç»“æŸ ===

    // === v1.6.3 æ–°å¢ï¼šå¤„ç†å¤ä¹ æ¥æºï¼ˆå¿…é¡»åœ¨ paused æ¢å¤ä¹‹å‰ï¼‰ ===
    if (challengeOrigin && challengeOrigin._isReview) {
        // è®°å½•å¤ä¹ ç»“æœ
        reviewResults.push({
            word: currentLearningChallenge.wordObj.en,
            correct: correct
        });

        // ç§»åˆ°ä¸‹ä¸€ä¸ªå•è¯
        reviewIndex++;

        // æ¸…ç†çŠ¶æ€
        currentLearningChallenge = null;
        challengeOrigin = null;
        hideLearningChallenge();

        // çŸ­æš‚å»¶è¿Ÿåæ˜¾ç¤ºä¸‹ä¸€ä¸ªï¼ˆä¸æ¢å¤ pausedï¼‰
        setTimeout(() => showReviewWord(), 600);

        return;  // æå‰è¿”å›ï¼Œä¸æ‰§è¡Œåé¢çš„é€»è¾‘
    }
    // === v1.6.3 å¤ä¹ å¤„ç†ç»“æŸ ===

    if (correct) {
        addScore(reward.correct.score);
        inventory.diamond = (inventory.diamond || 0) + (reward.correct.diamond || 0);
        updateInventoryUI();
        showFloatingText("ğŸ‰ æŒ‘æˆ˜æˆåŠŸ", player.x, player.y - 40);

        // === WordGate åˆ†æ”¯ ===
        if (challengeOrigin && challengeOrigin instanceof WordGate) {
            challengeOrigin.locked = false;
            challengeOrigin.remove = true;
            showToast("ğŸ’  è¯è¯­é—¸é—¨å·²è§£é”ï¼");
        }

        // === v1.6.1 æ–°å¢ï¼šChest åˆ†æ”¯ ===
        if (challengeOrigin && challengeOrigin instanceof Chest) {
            // ç­”å¯¹ï¼šæ ‡è®°æå‡ç¨€æœ‰åº¦
            challengeOrigin._rarityBoost = true;
            challengeOrigin.open();
            showToast("ğŸ ç­”å¯¹äº†ï¼å®ç®±å¥–åŠ±å‡çº§ï¼", 2000);
        }
        // === v1.6.1 ç»“æŸ ===

    } else {
        addScore(-reward.wrong.scorePenalty);
        showFloatingText("âŒ æŒ‘æˆ˜å¤±è´¥", player.x, player.y - 40);

        // === WordGate åˆ†æ”¯ ===
        if (challengeOrigin && challengeOrigin instanceof WordGate) {
            challengeOrigin.cooldown = 180;
        }

        // === v1.6.1 æ–°å¢ï¼šChest åˆ†æ”¯ ===
        if (challengeOrigin && challengeOrigin instanceof Chest) {
            // ç­”é”™ä¹Ÿå¼€ç®±ï¼Œåªæ˜¯ä¸æå‡ç¨€æœ‰åº¦
            challengeOrigin.open();
            showToast("ğŸ’¼ ç­”é”™äº†ï¼Œä½†è¿˜æ˜¯å¯ä»¥å¼€ç®±", 2000);
        }
        // === v1.6.1 ç»“æŸ ===
    }
    paused = challengePausedBefore;
    currentLearningChallenge = null;
    challengeOrigin = null;
}

function triggerWordGateChallenge(gate) {
    if (!gate || !gate.wordObj || gate.locked === false) return;
    if (currentLearningChallenge) return;
    startLearningChallenge(gate.wordObj, "fill_blank", gate);
    gate.cooldown = 60;
}

function updateWordUI(wordObj) {
    const el = document.getElementById("word-display");
    if (!el) return;
    el.innerText = wordObj ? [wordObj.en, wordObj.zh].filter(Boolean).join(" ") : "Start!";
}

function speakWord(wordObj) {
    lastWord = wordObj;
    updateWordUI(wordObj);
    bumpWordDisplay();
    showWordCard(wordObj);

    if (!settings.speechEnabled) return;
    const enText = normalizeSpeechText(wordObj?.en, wordObj?.word);
    const zhText = settings.speechZhEnabled ? normalizeSpeechText(wordObj?.zh, "") : "";
    if (!enText && !zhText) return;

    const nativeTts = getNativeTts();
    if (!audioUnlocked && !nativeTts) {
        speechPendingUnlockWord = wordObj;
        return;
    }
    if (nativeTts) {
        const speak = () => {
            const enRate = clamp(Number(settings.speechEnRate) || 1.0, 0.5, 2.0);
            const zhRate = clamp(Number(settings.speechZhRate) || 1.0, 0.5, 2.0);
            let ok = false;
            if (enText) {
                ok = speakNativeTts(nativeTts, enText, "en-US", enRate, "QUEUE_FLUSH") || ok;
            }
            if (zhText) {
                ok = speakNativeTts(nativeTts, zhText, "zh-CN", zhRate, "QUEUE_ADD") || ok;
            }
            return ok || false;
        };
        try {
            if (typeof nativeTts.stop === "function") {
                const p = nativeTts.stop();
                if (p && typeof p.finally === "function") {
                    p.finally(speak);
                    return;
                } else {
                    if (speak()) return;
                }
            } else if (speak()) {
                return;
            }
        } catch {
            if (speak()) return;
        }
    }

    // Web Speech is the best offline fallback on browsers (some WebViews return empty voices but can still speak).
    const hasSpeech = "speechSynthesis" in window && typeof SpeechSynthesisUtterance !== "undefined";
    if (hasSpeech) {
        try {
            ensureSpeechReady();
            // Still listen for voiceschanged so we can pick better voices later, but do not block speaking on it.
            ensureSpeechVoices();

            window.speechSynthesis.cancel();
            window.speechSynthesis.resume();

            if (!enText && zhText) {
                const onlyZh = new SpeechSynthesisUtterance(zhText);
                onlyZh.lang = "zh-CN";
                const zhVoice = pickVoice("zh");
                if (zhVoice) onlyZh.voice = zhVoice;
                onlyZh.rate = clamp(Number(settings.speechZhRate) || 0.9, 0.5, 2.0);
                window.speechSynthesis.speak(onlyZh);
                return;
            }

            const uEn = new SpeechSynthesisUtterance(enText);
            uEn.lang = "en-US";
            const enVoice = pickVoice("en");
            if (enVoice) uEn.voice = enVoice;
            uEn.rate = clamp(Number(settings.speechEnRate) || 1.0, 0.5, 2.0);

            if (zhText) {
                const uZh = new SpeechSynthesisUtterance(zhText);
                uZh.lang = "zh-CN";
                const zhVoice = pickVoice("zh");
                if (zhVoice) uZh.voice = zhVoice;
                uZh.rate = clamp(Number(settings.speechZhRate) || 0.9, 0.5, 2.0);
                uEn.onend = () => {
                    try { window.speechSynthesis.speak(uZh); } catch {}
                };
            }

            window.speechSynthesis.speak(uEn);
            return;
        } catch {
            // Fall back to online audio below.
        }
    }

    // Online fallback (may be blocked by autoplay policies until the first user gesture).
    playOnlineTtsSequence([
        enText ? { text: enText, lang: "en" } : null,
        zhText ? { text: zhText, lang: "zh-CN" } : null
    ]);
}

// ==================== v1.6.3 å¤ä¹ ç³»ç»Ÿ ====================

// å¤ä¹ ç³»ç»Ÿå…¨å±€çŠ¶æ€
let reviewActive = false;
let reviewWords = [];
let reviewIndex = 0;
let reviewResults = [];

/**
 * æ£€æŸ¥å¹¶å¯åŠ¨å¤ä¹ æµç¨‹
 */
function maybeShowReview() {
    // å®‰å…¨æ£€æŸ¥ï¼šä¸ä¸å…¶ä»–ç³»ç»Ÿå†²çª
    if (reviewActive || currentLearningChallenge || paused) return;

    // è·å–éœ€è¦å¤ä¹ çš„å•è¯
    const words = getWordsForReview(3);
    if (words.length === 0) return;

    // åˆå§‹åŒ–å¤ä¹ çŠ¶æ€
    reviewActive = true;
    reviewWords = words;
    reviewIndex = 0;
    reviewResults = [];
    paused = true;

    showToast("ğŸ“š å¿«é€Ÿå¤ä¹ ï¼", 1000);
    setTimeout(() => showReviewWord(), 500);
}

/**
 * æ˜¾ç¤ºå½“å‰å¤ä¹ å•è¯
 */
function showReviewWord() {
    if (reviewIndex >= reviewWords.length) {
        finishReview();
        return;
    }

    const wordObj = reviewWords[reviewIndex];

    // å¤ç”¨ç°æœ‰çš„ Challenge ç³»ç»Ÿæ¥æ˜¾ç¤ºé¢˜ç›®
    // origin ä¼ å…¥ç‰¹æ®Šæ ‡è®°å¯¹è±¡
    startLearningChallenge(wordObj, "translate", {
        _isReview: true,
        _reviewIndex: reviewIndex
    });
}

/**
 * å®Œæˆå¤ä¹ æµç¨‹ï¼Œæ˜¾ç¤ºç»“æœå’Œå¥–åŠ±
 */
function finishReview() {
    reviewActive = false;

    const correct = reviewResults.filter(r => r.correct).length;
    const total = reviewResults.length;

    // æ›´æ–°ç»Ÿè®¡ï¼ˆå·²åœ¨ completeLearningChallenge ä¸­è®°å½•ï¼‰

    // è®¡ç®—å¥–åŠ±
    addScore(correct * 30);

    if (correct === total && total > 0) {
        // å…¨å¯¹å¥–åŠ±
        inventory.diamond = (inventory.diamond || 0) + 1;
        updateInventoryUI();
        showToast(`ğŸ“š å¤ä¹ å®Œæˆï¼å…¨å¯¹ï¼+${correct * 30}åˆ† +1ğŸ’`, 2500);
    } else {
        showToast(`ğŸ“š å¤ä¹ å®Œæˆï¼${correct}/${total} +${correct * 30}åˆ†`, 2000);
    }

    // æ¢å¤æ¸¸æˆçŠ¶æ€
    paused = false;
}


</script>
<script>
/**
 * 13-game-loop.js - æ¸¸æˆä¸»å¾ªç¯ã€èƒŒåŒ…ã€è£…å¤‡
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 3818-4571)
 */
function optimizedUpdate(entity, updateFn) {
    const margin = blockSize * 2;
    const onScreen = entity.x > cameraX - margin && entity.x < cameraX + canvas.width + margin;
    if (onScreen) {
        updateFn();
    } else if (gameFrame % 3 === 0) {
        updateFn();
    }
}

function checkBossSpawn() {
    if (bossSpawned) return;
    const enemyConfig = getEnemyConfig();
    if (getProgressScore() >= (enemyConfig.bossSpawnScore || 5000)) {
        bossSpawned = true;
        const dragon = new Enemy(player.x + 300, 100, "ender_dragon");
        enemies.push(dragon);
        showToast("âš ï¸ æœ«å½±é¾™é™ä¸´ï¼");
    }
}

function update() {
    if (paused) return;
    updateCurrentBiome();
    applyBiomeEffectsToPlayer();
    tickWeather();
    if (keys.right) {
        if (player.velX < player.speed) player.velX++;
        player.facingRight = true;
    }
    if (keys.left) {
        if (player.velX > -player.speed) player.velX--;
        player.facingRight = false;
    }

    player.velX *= gameConfig.physics.friction;
    let currentGravity = gameConfig.physics.gravity;
    if (Math.abs(player.velY) < 1.0) currentGravity = gameConfig.physics.gravity * 0.4;
    player.velY += currentGravity;
    player.grounded = false;

    for (let p of platforms) {
        const dir = colCheck(player, p);
        if (dir === "l" || dir === "r") {
            // å¦‚æœç©å®¶è„šåº•æ¥è¿‘å¹³å°é¡¶éƒ¨ï¼Œè§†ä¸ºè¸©ä¸Šå¹³å°è€Œéæ’å¢™
            const feetY = player.y + player.height;
            const stepUpThreshold = blockSize * 0.6;
            if (feetY >= p.y && feetY - p.y < stepUpThreshold) {
                player.y = p.y - player.height;
                player.grounded = true;
                player.jumpCount = 0;
                player.velY = 0;
                coyoteTimer = gameConfig.jump.coyoteFrames;
            } else {
                player.velX = 0;
            }
        } else if (dir === "b") {
            player.grounded = true;
            player.y = p.y - player.height;
            player.jumpCount = 0;
            coyoteTimer = gameConfig.jump.coyoteFrames;
        } else if (dir === "t") {
            player.y = p.y + p.height;
            if (player.velY < 0) player.velY = 0;
        }
    }

    for (let t of trees) {
        const trunkX = t.x + (t.width - 30) / 2;
        const trunkY = t.y + t.height - 60;
        const dir = colCheckRect(player.x, player.y, player.width, player.height, trunkX, trunkY, 30, 60);
        if (dir) {
            if (dir === "l" || dir === "r") {
                // æ ‘å¹²ä¹Ÿéœ€è¦ step-up é€»è¾‘
                const feetY = player.y + player.height;
                const stepUpThreshold = blockSize * 0.6;
                if (feetY >= trunkY && feetY - trunkY < stepUpThreshold) {
                    player.y = trunkY - player.height;
                    player.grounded = true;
                    player.jumpCount = 0;
                    player.velY = 0;
                    coyoteTimer = gameConfig.jump.coyoteFrames;
                } else {
                    player.velX = 0;
                }
            } else if (dir === "b") {
                player.grounded = true;
                player.jumpCount = 0;
                player.y = trunkY - player.height;
                coyoteTimer = gameConfig.jump.coyoteFrames;
            }
        }
    }

    if (!player.grounded && coyoteTimer > 0) {
        coyoteTimer--;
    }

    if (jumpBuffer > 0) {
        jumpBuffer--;
    }

    if (jumpBuffer > 0) {
        if (coyoteTimer > 0) {
            player.velY = player.jumpStrength;
            player.grounded = false;
            player.jumpCount = 1;
            coyoteTimer = 0;
            jumpBuffer = 0;
        } else if (player.jumpCount < player.maxJumps) {
            player.velY = player.jumpStrength * 0.8;
            player.jumpCount++;
            jumpBuffer = 0;
        }
    }

    if (player.grounded) player.velY = 0;

    player.x += player.velX;
    player.y += player.velY;

    // ä¸Šè¾¹ç•Œä¿æŠ¤
    if (player.y < -player.height * 2) {
        player.y = -player.height * 2;
        if (player.velY < 0) player.velY = 0;
    }

    if (player.y > fallResetY) {
        player.y = 0;
        player.x -= 200;
        if (player.x < 0) player.x = 100;
        player.velY = 0;
    }

    // å¡ä½æ£€æµ‹
    if (typeof player._stuckFrames === "undefined") player._stuckFrames = 0;
    if (typeof player._lastStuckX === "undefined") player._lastStuckX = player.x;
    const hasInput = keys.right || keys.left || keys.up || keys.jump;
    if (hasInput && Math.abs(player.x - player._lastStuckX) < 0.5 && player.grounded) {
        player._stuckFrames++;
        if (player._stuckFrames > 45) {
            player.y = player.y - blockSize * 0.8;
            player.velY = -2;
            player._stuckFrames = 0;
        }
    } else {
        player._stuckFrames = 0;
    }
    player._lastStuckX = player.x;

    let targetCamX = player.x - cameraOffsetX;
    if (targetCamX < 0) targetCamX = 0;
    if (targetCamX > cameraX) cameraX = targetCamX;

    updateMapGeneration();

    decorations.forEach(d => {
        if (d.update) {
            optimizedUpdate(d, () => d.update());
        }
        if ((d.interactive || d.harmful) && rectIntersect(player.x, player.y, player.width, player.height, d.x, d.y, d.width, d.height)) {
            d.onCollision(player);
        }
    });
    decorations = decorations.filter(d => d.x + d.width > cameraX - removeThreshold && !d.remove);

    if (particles.length) {
        particles.forEach(p => {
            if (!p) return;
            if (typeof p.update === "function") {
                optimizedUpdate(p, () => p.update());
            }
        });
        particles = particles.filter(p => {
            if (!p || p.remove || p.life <= 0) {
                if (typeof snowflakePool !== "undefined" && p instanceof Snowflake) snowflakePool.release(p);
                else if (typeof leafPool !== "undefined" && p instanceof LeafParticle) leafPool.release(p);
                else if (typeof dustPool !== "undefined" && p instanceof DustParticle) dustPool.release(p);
                return false;
            }
            return true;
        });
    }
    spawnBiomeParticles();

    checkBossSpawn();
    if (typeof bossArena !== 'undefined' && bossArena) {
        bossArena.checkSpawn(getProgressScore());
        bossArena.update(player);
    }
    if (typeof updateVillages === 'function') updateVillages();

    playerPositionHistory.push({ x: player.x, y: player.y, frame: gameFrame });
    if (playerPositionHistory.length > 150) playerPositionHistory.shift();

    golems.forEach(g => optimizedUpdate(g, () => g.update(player, playerPositionHistory, enemies, platforms)));
    golems = golems.filter(g => !g.remove && g.x > cameraX - 260);

    enemies.forEach(e => {
        optimizedUpdate(e, () => e.update(player));
        if (e.remove || e.y > 900) return;
        if (colCheck(player, e)) {
            if (player.velY > 0 && player.y + player.height < e.y + e.height * 0.8) {
                e.takeDamage(999);
                player.velY = -4;
            } else {
                damagePlayer(Number(e.damage) || 10, e.x);
            }
        }
    });
    enemies = enemies.filter(e => !e.remove && e.y < 950);

    if (projectiles.length) {
        projectiles.forEach(p => optimizedUpdate(p, () => p.update(player, golems, enemies)));
        projectiles = projectiles.filter(p => {
            const inRange = p.x > cameraX - 300 && p.x < cameraX + 1200;
            if (!inRange) p.remove = true;
            return !p.remove && inRange;
        });
    }

    items.forEach(item => {
        item.floatY = Math.sin(gameFrame / 20) * 5;
        if (rectIntersect(player.x, player.y, player.width, player.height, item.x, item.y + item.floatY, 30, 30)) {
            item.collected = true;
            addScore(gameConfig.scoring.word);
            recordWordProgress(item.wordObj);
            speakWord(item.wordObj);
            showFloatingText(item.wordObj.zh, item.x, item.y);
            maybeTriggerLearningChallenge(item.wordObj);
        }
    });

    wordGates.forEach(gate => {
        if (gate.cooldown > 0) gate.cooldown--;
        if (gate.locked && gate.cooldown <= 0 && rectIntersect(player.x, player.y, player.width, player.height, gate.x, gate.y, gate.width, gate.height)) {
            triggerWordGateChallenge(gate);
        }
    });
    wordGates = wordGates.filter(gate => !gate.remove);

    if (player.isAttacking) {
        player.attackTimer--;
        if (player.attackTimer <= 0) player.isAttacking = false;
    }

    floatingTexts = floatingTexts.filter(t => t.life > 0);
    floatingTexts.forEach(t => {
        t.y -= 1;
        t.life--;
    });

    if (playerInvincibleTimer > 0) playerInvincibleTimer--;
    if (playerWeapons.attackCooldown > 0) playerWeapons.attackCooldown--;
    if (playerWeapons.isCharging) {
        const weapon = WEAPONS.bow;
        playerWeapons.chargeTime = Math.min(weapon.chargeMax, playerWeapons.chargeTime + 1);
    }

    // Biomes are score-driven now; the old "next level / scene switch" caused conflicts.
    updateDifficultyState();
    gameFrame++;
}

function addScore(points) {
    score += points;
    levelScore += points;
    if (score < 0) score = 0;
    if (levelScore < 0) levelScore = 0;
    runBestScore = Math.max(runBestScore, score);
    document.getElementById("score").innerText = score;
    checkAchievement("score", score);
    updateDifficultyState();
}

function updateHpUI() {
    const el = document.getElementById("hp");
    if (!el) return;
    const maxPerRow = 5;
    const total = Math.max(0, playerMaxHp);
    const filled = Math.max(0, Math.min(playerHp, total));
    const rows = Math.ceil(total / maxPerRow) || 1;
    let html = "";
    for (let r = 0; r < rows; r++) {
        const rowStart = r * maxPerRow;
        const rowEnd = Math.min(total, rowStart + maxPerRow);
        const rowFilled = Math.max(0, Math.min(filled - rowStart, rowEnd - rowStart));
        const rowEmpty = (rowEnd - rowStart) - rowFilled;
        let rowHtml = "";
        for (let i = 0; i < rowFilled; i++) rowHtml += `<span class="hp-heart">â¤ï¸</span>`;
        for (let i = 0; i < rowEmpty; i++) rowHtml += `<span class="hp-heart">ğŸ–¤</span>`;
        html += `<div class="hp-row">${rowHtml}</div>`;
    }
    el.innerHTML = html;
}

function getDiamondCount() {
    return Number(inventory.diamond) || 0;
}

function updateDiamondUI() {
    updateInventoryUI();
}

function useDiamondForHp() {
    if (playerHp >= playerMaxHp) {
        showToast("â¤ï¸ å·²æ»¡è¡€");
        return;
    }
    if (getDiamondCount() < 1) {
        showToast("ğŸ’ ä¸è¶³");
        return;
    }
    inventory.diamond -= 1;
    healPlayer(1);
    updateDiamondUI();
    showToast("ğŸ’ æ¢å– +1â¤ï¸");
}

function getLearnedWordCount() {
    const vocab = progress && progress.vocab ? Object.keys(progress.vocab) : [];
    return vocab.length;
}

function recordEnemyKill(type) {
    enemyKillStats.total = (enemyKillStats.total || 0) + 1;
    enemyKillStats[type] = (enemyKillStats[type] || 0) + 1;
    onEnemyKilled();
}

function healPlayer(amount) {
    if (playerHp <= 0) return;
    playerHp = Math.min(playerMaxHp, playerHp + amount);
    updateHpUI();
}

function scorePenaltyForDamage(amount) {
    const dmg = Math.max(0, Number(amount) || 0);
    // Score is the "HP" proxy in this game: lose a few points on contact, but not too punishing.
    const scale = typeof gameConfig?.scoring?.hitPenaltyScale === "number" ? gameConfig.scoring.hitPenaltyScale : 0.5;
    const minPenalty = typeof gameConfig?.scoring?.minHitPenalty === "number" ? gameConfig.scoring.minHitPenalty : 5;
    const maxPenalty = typeof gameConfig?.scoring?.maxHitPenalty === "number" ? gameConfig.scoring.maxHitPenalty : 30;
    const raw = Math.round(dmg * scale);
    return Math.max(minPenalty, Math.min(maxPenalty, raw || minPenalty));
}

function damagePlayer(amount, sourceX, knockback = 90) {
    if (playerInvincibleTimer > 0) return;
    const invFrames = Number(getDifficultyConfig().invincibleFrames ?? 30) || 30;
    playerInvincibleTimer = Math.max(10, invFrames);
    lastDamageFrame = gameFrame;
    const dir = sourceX != null ? (player.x > sourceX ? 1 : -1) : -1;
    player.x += dir * knockback;
    player.y -= 40;
    // å‡»é€€åä½ç½®åˆæ³•æ€§æ ¡éªŒï¼šä¸åµŒå…¥å¹³å°
    for (let p of platforms) {
        if (!p || p.remove) continue;
        const d = colCheck(player, p);
        if (d === "l") player.x = p.x + p.width;
        else if (d === "r") player.x = p.x - player.width;
        else if (d === "b") player.y = p.y - player.height;
        else if (d === "t") player.y = p.y + p.height;
    }
    if (player.y < -player.height * 2) player.y = -player.height * 2;
    const baseDamage = Math.max(1, Number(amount) || 1);
    const diff = getDifficultyState();
    const damageUnit = Number(getDifficultyConfig().damageUnit ?? 20) || 20;
    const scaledDamage = Math.max(1, Math.round((baseDamage * diff.enemyDamageMult) / damageUnit));
    const penalty = scorePenaltyForDamage(baseDamage * diff.enemyDamageMult);
    addScore(-penalty);
    const defense = getArmorDefense();
    const reduction = Math.min(0.5, defense * 0.1);
    const actualDamage = Math.max(1, Math.round(scaledDamage * (1 - reduction)));
    if (playerEquipment.armor && playerEquipment.armorDurability > 0) {
        playerEquipment.armorDurability = Math.max(0, playerEquipment.armorDurability - 5);
        if (playerEquipment.armorDurability <= 0) {
            const broken = ARMOR_TYPES[playerEquipment.armor];
            showToast(`${broken?.name || "ç›”ç”²"} å·²ç ´æŸ`);
            playerEquipment.armor = null;
            playerEquipment.armorDurability = 0;
        }
    }
    updateArmorUI();
    playerHp = Math.max(0, playerHp - actualDamage);
    updateHpUI();
    showFloatingText(`-${penalty}åˆ†`, player.x, player.y);
    if (playerHp <= 0 || score <= 0) {
        triggerGameOver();
    }
}

function nextLevel() {
    // Deprecated: scenes are controlled by biomes now.
    levelScore = 0;
}

function showToast(msg) {
    const t = document.getElementById("toast");
    t.innerText = msg;
    t.style.display = "block";
    setTimeout(() => t.style.display = "none", 2000);
}

function showFloatingText(text, x, y, color) {
    floatingTexts.push({ text, x, y, life: 60, color: color || '#FFF' });
}

function updateInventoryUI() {
    const ids = {
        diamond: "count-diamond",
        pumpkin: "count-pumpkin",
        iron: "count-iron",
        stick: "count-stick",
        stone_sword: "count-stone_sword",
        iron_pickaxe: "count-iron_pickaxe",
        bow: "count-bow",
        arrow: "count-arrow"
    };
    Object.keys(ids).forEach(key => {
        const el = document.getElementById(ids[key]);
        if (el) el.innerText = inventory[key] ?? 0;
    });
    const slots = Array.from(document.querySelectorAll(".inventory-bar .inv-slot:not(.inv-slot-button)"));
    slots.forEach((s, idx) => {
        s.classList.toggle("selected", idx === selectedSlot);
    });
    syncWeaponsFromInventory();
    updateWeaponUI();
    updateInventoryModal();
}

function getInventoryEntries(keys) {
    return keys
        .map(key => ({
            key,
            count: Number(inventory[key]) || 0,
            label: ITEM_LABELS[key] || key,
            icon: ITEM_ICONS[key] || "ğŸ“¦"
        }))
        .filter(entry => entry.count > 0);
}

function renderInventoryModal() {
    if (!inventoryContentEl) return;
    if (inventoryTab === "equipment") {
        const armorLabel = playerEquipment.armor ? (ARMOR_TYPES[playerEquipment.armor]?.name || playerEquipment.armor) : "æ— ";
        const armorDur = playerEquipment.armor ? `${playerEquipment.armorDurability}%` : "--";
        const armorList = (armorInventory || []).map(entry => {
            const name = ARMOR_TYPES[entry.id]?.name || entry.id;
            return `${name} (${entry.durability}%)`;
        });
        const weapons = getInventoryEntries(["stone_sword", "iron_pickaxe", "bow", "arrow"]);
        const armorHtml = `
            <div class="inventory-equipment">
                <div>ğŸ›¡ï¸ æŠ¤ç”²ï¼š${armorLabel}</div>
                <div>è€ä¹…ï¼š${armorDur}</div>
                <div>åº“å­˜ï¼š${armorList.length ? armorList.join("ã€") : "æ— "}</div>
            </div>
        `;
        const weaponHtml = weapons.length
            ? weapons.map(entry => `
                <div class="inventory-item" data-item="${entry.key}" onclick="window.useInventoryItem && window.useInventoryItem('${entry.key}')">
                    <div class="inventory-item-left">
                        <div class="inventory-item-icon">${entry.icon}</div>
                        <div>${entry.label}</div>
                    </div>
                    <div class="inventory-item-count">${entry.count}</div>
                </div>
            `).join("")
            : `<div class="inventory-empty">æš‚æ— è£…å¤‡</div>`;
        inventoryContentEl.innerHTML = `${armorHtml}${weaponHtml}`;
        return;
    }

    const keys = INVENTORY_CATEGORIES[inventoryTab] || [];
    const entries = getInventoryEntries(keys);
    if (!entries.length) {
        inventoryContentEl.innerHTML = `<div class="inventory-empty">æš‚æ— ç‰©å“</div>`;
        return;
    }
    inventoryContentEl.innerHTML = entries.map(entry => `
        <div class="inventory-item" data-item="${entry.key}" onclick="window.useInventoryItem && window.useInventoryItem('${entry.key}')">
            <div class="inventory-item-left">
                <div class="inventory-item-icon">${entry.icon}</div>
                <div>${entry.label}</div>
            </div>
            <div class="inventory-item-count">${entry.count}</div>
        </div>
    `).join("");
}

function setInventoryTab(tab) {
    inventoryTab = tab;
    if (inventoryTabButtons) {
        inventoryTabButtons.forEach(btn => {
            btn.classList.toggle("active", btn.dataset.tab === tab);
        });
    }
    renderInventoryModal();
}

function showInventoryModal() {
    if (!inventoryModalEl) return;
    pausedByModal = !paused;
    paused = true;
    inventoryModalEl.classList.add("visible");
    inventoryModalEl.setAttribute("aria-hidden", "false");
    renderInventoryModal();
}

function hideInventoryModal() {
    if (!inventoryModalEl) return;
    inventoryModalEl.classList.remove("visible");
    inventoryModalEl.setAttribute("aria-hidden", "true");
    if (pausedByModal) paused = false;
    pausedByModal = false;
}

function updateInventoryModal() {
    if (!inventoryModalEl || !inventoryModalEl.classList.contains("visible")) return;
    renderInventoryModal();
}

// èƒŒåŒ…ç‰©å“ä½¿ç”¨å‡½æ•°
function useInventoryItem(itemKey) {
    const count = Number(inventory[itemKey]) || 0;
    if (count <= 0) {
        showToast("âŒ ç‰©å“ä¸è¶³");
        return;
    }

    const itemName = ITEM_LABELS[itemKey] || itemKey;
    let used = false;

    // æ¶ˆè€—å“ä½¿ç”¨
    if (itemKey === "diamond") {
        if (playerHp >= playerMaxHp) {
            showToast("â¤ï¸ å·²æ»¡è¡€");
            return;
        }
        inventory.diamond -= 1;
        healPlayer(1);
        showFloatingText("+1â¤ï¸", player.x, player.y - 60);
        showToast(`ğŸ’ æ¢å¤ç”Ÿå‘½`);
        used = true;
    } else if (itemKey === "pumpkin") {
        if (playerHp >= playerMaxHp) {
            showToast("â¤ï¸ å·²æ»¡è¡€");
            return;
        }
        inventory.pumpkin -= 1;
        healPlayer(2);
        showFloatingText("+2â¤ï¸", player.x, player.y - 60);
        showToast(`ğŸƒ æ¢å¤2ç‚¹ç”Ÿå‘½`);
        used = true;
    }
    // æ­¦å™¨åˆ‡æ¢
    else if (itemKey === "stone_sword" || itemKey === "iron_pickaxe") {
        const weaponMap = {
            stone_sword: "sword",
            iron_pickaxe: "pickaxe"
        };
        const weaponId = weaponMap[itemKey];
        if (weaponId && playerWeapons.current !== weaponId) {
            playerWeapons.current = weaponId;
            playerWeapons.attackCooldown = 0;
            const weapon = WEAPONS[weaponId];
            updateWeaponUI();
            showToast(`âš”ï¸ åˆ‡æ¢åˆ° ${weapon.emoji} ${weapon.name}`);
            used = true;
        } else {
            showToast("âš”ï¸ å·²è£…å¤‡å½“å‰æ­¦å™¨");
        }
    }
    // ç®­çŸ¢
    else if (itemKey === "arrow") {
        showToast(`ğŸ¹ ç®­çŸ¢æ•°é‡: ${count}`);
    }
    // å…¶ä»–ææ–™
    else {
        showToast(`${itemName}: ${count}ä¸ª`);
    }

    if (used) {
        updateHpUI();
        updateInventoryUI();
        updateInventoryModal(); // åˆ·æ–°èƒŒåŒ…æ˜¾ç¤º
    }
}

// å¯¼å‡ºåˆ°å…¨å±€ä¾› HTML onclick ä½¿ç”¨
if (typeof window !== "undefined") {
    window.useInventoryItem = useInventoryItem;
}

function addArmorToInventory(armorId) {
    if (!ARMOR_TYPES[armorId]) return;
    armorInventory.push({
        id: armorId,
        durability: 100
    });
    updateArmorUI();
}

function equipArmor(armorId) {
    const armor = ARMOR_TYPES[armorId];
    if (!armor) return false;
    if (playerEquipment.armor === armorId) return false;
    const idx = armorInventory.findIndex(a => a.id === armorId);
    if (idx === -1) {
        return false;
    }
    const selected = armorInventory.splice(idx, 1)[0];
    if (playerEquipment.armor) {
        armorInventory.push({
            id: playerEquipment.armor,
            durability: playerEquipment.armorDurability
        });
    }
    playerEquipment.armor = selected.id;
    playerEquipment.armorDurability = selected.durability;
    updateArmorUI();
    showToast(`ğŸ›¡ï¸ è£…å¤‡ ${armor.name}`);
    showFloatingText(`ğŸ›¡ï¸ ${armor.name}`, player ? player.x : 0, player ? player.y - 60 : 120);
    return true;
}

function unequipArmor() {
    if (!playerEquipment.armor) return;
    const armor = ARMOR_TYPES[playerEquipment.armor];
    armorInventory.push({
        id: playerEquipment.armor,
        durability: playerEquipment.armorDurability
    });
    playerEquipment.armor = null;
    playerEquipment.armorDurability = 0;
    updateArmorUI();
    showToast(`${armor?.name || "ç›”ç”²"} å·²å¸ä¸‹`);
}

function getArmorDefense() {
    if (!playerEquipment.armor) return 0;
    const armor = ARMOR_TYPES[playerEquipment.armor];
    return armor ? armor.defense : 0;
}

function updateArmorUI() {
    const el = document.getElementById("armor-status");
    if (!el) return;
    if (playerEquipment.armor) {
        const armor = ARMOR_TYPES[playerEquipment.armor];
        const dur = Math.max(0, Math.min(100, playerEquipment.armorDurability));
        el.innerText = `ğŸ›¡ï¸ ${armor.name} ${dur}%`;
        el.classList.add("hud-box-active");
    } else {
        el.innerText = "ğŸ›¡ï¸ æ— ";
        el.classList.remove("hud-box-active");
    }
}

function showArmorSelectUI() {
    const modal = document.getElementById("armor-select-modal");
    if (!modal) return;
    const list = modal.querySelector(".armor-list");
    if (!list) return;
    list.innerHTML = "";
    if (playerEquipment.armor) {
        const armor = ARMOR_TYPES[playerEquipment.armor];
        const card = document.createElement("div");
        card.className = "armor-item equipped";
        card.innerHTML = `
            <span class="armor-icon" style="background:${armor.color}">ğŸ›¡ï¸</span>
            <div class="armor-details">
                <div class="armor-name">${armor.name}ï¼ˆå·²è£…å¤‡ï¼‰</div>
                <div class="armor-defense">é˜²å¾¡ ${armor.defense}</div>
                <div class="armor-durability">è€ä¹… ${playerEquipment.armorDurability}%</div>
            </div>
        `;
        card.addEventListener("click", () => {
            unequipArmor();
            hideArmorSelectUI();
        });
        list.appendChild(card);
    }
    if (armorInventory.length) {
        armorInventory.forEach(item => {
            const armor = ARMOR_TYPES[item.id];
            if (!armor) return;
            const card = document.createElement("div");
            card.className = "armor-item";
            card.innerHTML = `
                <span class="armor-icon" style="background:${armor.color}">ğŸ›¡ï¸</span>
                <div class="armor-details">
                    <div class="armor-name">${armor.name}</div>
                    <div class="armor-defense">é˜²å¾¡ ${armor.defense}</div>
                    <div class="armor-durability">è€ä¹… ${item.durability}%</div>
                </div>
            `;
            card.addEventListener("click", () => {
                if (equipArmor(item.id)) {
                    hideArmorSelectUI();
                }
            });
            list.appendChild(card);
        });
    } else if (!playerEquipment.armor) {
        list.innerHTML = "<div class=\"armor-item\">å½“å‰æ— ç›”ç”²å¯ç”¨</div>";
    }
    modal.classList.add("visible");
    modal.setAttribute("aria-hidden", "false");
    pausedByModal = !paused;
    paused = true;
}

function hideArmorSelectUI() {
    const modal = document.getElementById("armor-select-modal");
    if (!modal) return;
    modal.classList.remove("visible");
    modal.setAttribute("aria-hidden", "true");
    if (pausedByModal) {
        paused = false;
        pausedByModal = false;
    } else {
        paused = false;
    }
}

const RECIPES = {
    iron_golem: { iron: 10 },
    snow_golem: { pumpkin: 10 }
};

function tryCraft(recipeKey) {
    const recipe = RECIPES[recipeKey];
    if (!recipe) return false;
    for (const [item, count] of Object.entries(recipe)) {
        if ((inventory[item] || 0) < count) {
            showToast(`ææ–™ä¸è¶³: éœ€è¦ ${ITEM_LABELS[item] || item} x${count}`);
            return false;
        }
    }
    for (const [item, count] of Object.entries(recipe)) {
        inventory[item] -= count;
    }
    spawnGolem(recipeKey === "iron_golem" ? "iron" : "snow");
    updateInventoryUI();
    return true;
}

function spawnGolem(type) {
    const config = getGolemConfig();
    const maxCount = Number(config.maxCount) || MAX_GOLEMS;
    if (golems.length >= maxCount) {
        showToast(`æœ€å¤šåŒæ—¶å­˜åœ¨ ${maxCount} ä¸ªå‚€å„¡ï¼`);
        return;
    }
    const newGolem = new Golem(player.x + 50, player.y, type);
    golems.push(newGolem);
    const name = type === "iron" ? "é“å‚€å„¡" : "é›ªå‚€å„¡";
    showToast(`âœ… æˆåŠŸå¬å”¤ ${name}ï¼`);
    showFloatingText(`âš’ï¸ ${name}`, player.x, player.y - 40);
}

function handleInteraction() {
    // æ‘åº„å»ºç­‘äº¤äº’ä¼˜å…ˆ
    if (typeof tryVillageInteraction === 'function' && tryVillageInteraction()) return;

    let nearestChest = null;
    let minDist = 60;
    const now = Date.now();
    for (let c of chests) {
        const d = Math.abs((player.x + player.width / 2) - (c.x + c.width / 2));
        if (d < minDist) {
            nearestChest = c;
            minDist = d;
        }
    }
    if (!nearestChest) return;
    if (nearestChest.opened) {
        if (now - (nearestChest.lastClickTime || 0) < 350) {
            nearestChest.onDoubleClick();
        }
    } else {
        // === v1.6.1 å®ç®±å­¦ä¹ æ¨¡å¼ï¼šå¼€ç®±å‰å…ˆç­”é¢˜ ===
        if (settings.learningMode &&
            settings.chestLearningEnabled &&
            !currentLearningChallenge) {

            // ä»å½“å‰è¯åº“éšæœºå–ä¸€ä¸ªå•è¯
            const wordObj = pickWordForSpawn();

            if (wordObj) {
                // è§¦å‘ Challengeï¼Œorigin ä¼ å…¥ chest å®ä¾‹
                startLearningChallenge(wordObj, null, nearestChest);
            } else {
                // æ— å¯ç”¨å•è¯æ—¶ç›´æ¥å¼€ç®±
                nearestChest.open();
            }
        } else {
            // å­¦ä¹ æ¨¡å¼å…³é—­æ—¶ç›´æ¥å¼€ç®±
            nearestChest.open();
        }
        // === v1.6.1 ç»“æŸ ===
    }
    nearestChest.lastClickTime = now;
}

function handleDecorationInteract() {
    for (const d of decorations) {
        if (!d.collectible) continue;
        if (rectIntersect(player.x, player.y, player.width, player.height, d.x, d.y, d.width, d.height)) {
            d.interact(player);
            break;
        }
    }
}

function handleAttack(mode = "press") {
    if (playerWeapons.attackCooldown > 0) return;
    const weapon = WEAPONS[playerWeapons.current] || WEAPONS.sword;

    if (weapon.type === "ranged") {
        if (mode === "tap") {
            releaseBowShot(0.35);
            return;
        }
        if (!playerWeapons.isCharging) {
            startBowCharge();
        }
        return;
    }

    if (weapon.type === "dig") {
        digGroundBlock();
        return;
    }

    performMeleeAttack(weapon);
}

function handleAttackRelease() {
    const weapon = WEAPONS[playerWeapons.current] || WEAPONS.sword;
    if (weapon.type !== "ranged") return;
    if (!playerWeapons.isCharging) return;
    releaseBowShot();
}

function triggerChestHint() {
    if (chestHintSeen) return;
    chestHintSeen = true;
    chestHintFramesLeft = CHEST_HINT_FRAMES;
    chestHintPos = null;
    if (storage) storage.saveJson("mmwg:hintChestSeen", true);
}

</script>
<script>
/**
 * entity-names.js - æ¸¸æˆå®ä½“è‹±æ–‡åæ˜ å°„è¡¨ (v1.6.2)
 * ç”¨äºç¯å¢ƒå•è¯æ ‡ç­¾åŠŸèƒ½
 */

/**
 * æ¸¸æˆå®ä½“è‹±æ–‡åæ˜ å°„è¡¨
 */
const ENTITY_NAMES = {
    // æ•Œäºº
    zombie:          { en: "ZOMBIE",          zh: "åƒµå°¸" },
    spider:          { en: "SPIDER",          zh: "èœ˜è››" },
    creeper:         { en: "CREEPER",         zh: "çˆ¬è¡Œè€…" },
    skeleton:        { en: "SKELETON",        zh: "éª·é«…" },
    enderman:        { en: "ENDERMAN",        zh: "æœ«å½±äºº" },
    slime:           { en: "SLIME",           zh: "å²è±å§†" },

    // BOSS
    ender_dragon:    { en: "ENDER DRAGON",    zh: "æœ«å½±é¾™" },
    wither:          { en: "WITHER",          zh: "å‡‹é›¶" },
    ghast:           { en: "GHAST",           zh: "æ¶é­‚" },
    blaze:           { en: "BLAZE",           zh: "çƒˆç„°äºº" },
    wither_skeleton: { en: "WITHER SKELETON", zh: "å‡‹é›¶éª·é«…" },

    // æ‘åº„
    villager:        { en: "VILLAGER",        zh: "æ‘æ°‘" },

    // å‹æ–¹
    iron_golem:      { en: "IRON GOLEM",      zh: "é“å‚€å„¡" },
    snow_golem:      { en: "SNOW GOLEM",      zh: "é›ªå‚€å„¡" },

    // ç‰©å“
    chest:           { en: "CHEST",           zh: "å®ç®±" },
    diamond:         { en: "DIAMOND",         zh: "é’»çŸ³" },
    iron:            { en: "IRON",            zh: "é“" },
    pumpkin:         { en: "PUMPKIN",         zh: "å—ç“œ" },
    stick:           { en: "STICK",           zh: "æœ¨æ£" },
    beef:            { en: "BEEF",            zh: "ç‰›è‚‰" },
    mutton:          { en: "MUTTON",          zh: "ç¾Šè‚‰" },

    // ç¯å¢ƒ
    ocean:           { en: "OCEAN",           zh: "æµ·æ´‹" },
    nether:          { en: "NETHER",          zh: "ä¸‹ç•Œ" },
    lava:            { en: "LAVA",            zh: "å²©æµ†" },
    seaweed:         { en: "SEAWEED",         zh: "æµ·è‰" },
    mushroom:        { en: "MUSHROOM",        zh: "è˜‘è‡" }
};

</script>
<script>
/**
 * 14-renderer-main.js - ä¸»æ¸²æŸ“å‡½æ•°
 * ä» 14-renderer.js æ‹†åˆ†
 */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const biome = getBiomeById(currentBiome);
    drawBackground(biome);
    ctx.save();
    ctx.translate(-cameraX, 0);

    platforms.forEach(p => drawBlock(p.x, p.y, p.width, p.height, p.type));

    if (biome.effects?.waterLevel) {
        ctx.fillStyle = "rgba(33, 150, 243, 0.25)";
        ctx.fillRect(cameraX - 50, biome.effects.waterLevel, canvas.width + 100, canvas.height - biome.effects.waterLevel);
    }

    trees.forEach(t => {
        if (t.shake > 0) t.shake--;
        const shakeX = (Math.random() - 0.5) * t.shake * 2;
        drawPixelTree(ctx, t.x + shakeX, t.y, t.type, t.hp);
    });

    decorations.forEach(d => drawDecoration(d));

    chests.forEach(c => {
        drawChest(c.x, c.y, c.opened);

        // === v1.6.2 æ–°å¢ï¼šæœªå¼€å¯çš„å®ç®±æ˜¾ç¤ºè‹±æ–‡å ===
        if (!c.opened) {
            const width = c.width || blockSize * 0.8;
            drawEntityLabel(c.x, c.y, width, "chest");
        }
    });

    items.forEach(i => {
        if (!i.collected) drawItem(i.x, i.y + i.floatY, i.wordObj.en);
    });

    wordGates.forEach(gate => drawWordGate(gate));

    // æ‘åº„æ¸²æŸ“ï¼ˆåœ¨æ•Œäººä¹‹å‰ï¼‰
    if (typeof drawVillages === 'function') drawVillages(ctx);

    if (particles.length) {
        particles.forEach(p => drawParticle(p));
    }

    enemies.forEach(e => drawEnemy(e));

    golems.forEach(g => drawGolem(g));

    if (projectiles.length) {
        projectiles.forEach(p => drawProjectile(p));
    }

    drawSteve(player.x, player.y, player.facingRight, player.isAttacking);

    ctx.fillStyle = "#FFF";
    ctx.font = "bold 20px Verdana";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 3;
    floatingTexts.forEach(t => {
        ctx.fillStyle = t.color || '#FFF';
        ctx.strokeText(t.text, t.x + 10, t.y);
        ctx.fillText(t.text, t.x + 10, t.y);
    });

    chests.forEach(c => {
        if (!c.opened && Math.abs(player.x - c.x) < 60 && !chestHintSeen) {
            triggerChestHint();
            chestHintPos = { x: c.x, y: c.y };
        }
    });

    if (chestHintFramesLeft > 0 && chestHintPos) {
        ctx.strokeStyle = "black";
        ctx.lineWidth = 4;
        ctx.fillStyle = "white";
        const hint = "æŒ‰(ğŸ“¦)æ‰“å¼€";
        ctx.strokeText(hint, chestHintPos.x - 10, chestHintPos.y - 15);
        ctx.fillText(hint, chestHintPos.x - 10, chestHintPos.y - 15);
        chestHintFramesLeft--;
    }

    ctx.restore();

    // BOSSç«æŠ€åœºæ¸²æŸ“
    if (typeof bossArena !== 'undefined' && bossArena && bossArena.active) {
        ctx.save();
        ctx.translate(-cameraX, 0);
        bossArena.renderBoss(ctx);
        bossArena.renderProjectiles(ctx);
        ctx.restore();
        bossArena.renderBossHpBar(ctx);
    }

    const boss = enemies.find(e => e.type === "ender_dragon" && !e.remove);
    if (boss) {
        const barW = 360;
        const barH = 14;
        const bx = (canvas.width - barW) / 2;
        const by = 20;
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(bx - 4, by - 4, barW + 8, barH + 8);
        ctx.fillStyle = "#111";
        ctx.fillRect(bx, by, barW, barH);
        const pct = Math.max(0, boss.hp / boss.maxHp);
        ctx.fillStyle = "#8E24AA";
        ctx.fillRect(bx, by, barW * pct, barH);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px Verdana";
        ctx.textAlign = "center";
        ctx.fillText("æœ«å½±é¾™", canvas.width / 2, by - 6);
        ctx.textAlign = "left";
    }

    requestAnimationFrame(() => { update(); draw(); });
}

function drawBlock(x, y, w, h, type) {
    const cols = Math.ceil(w / blockSize);
    for (let i = 0; i < cols; i++) {
        const cx = x + i * blockSize;
        if (type === "grass") {
            ctx.fillStyle = "#5d4037";
            ctx.fillRect(cx, y, blockSize, h);
            ctx.fillStyle = "#4CAF50";
            ctx.fillRect(cx, y, blockSize, h / 3);
        } else if (type === "snow") {
            ctx.fillStyle = "#1e3f66";
            ctx.fillRect(cx, y, blockSize, h);
            ctx.fillStyle = "#fff";
            ctx.fillRect(cx, y, blockSize, h / 3);
        } else if (type === "stone") {
            ctx.fillStyle = "#757575";
            ctx.fillRect(cx, y, blockSize, h);
            ctx.fillStyle = "#424242";
            ctx.fillRect(cx + 5, y + 5, 10, 10);
        } else if (type === "sand") {
            ctx.fillStyle = "#FDD835";
            ctx.fillRect(cx, y, blockSize, h);
        } else if (type === "netherrack") {
            ctx.fillStyle = "#5E1B1B";
            ctx.fillRect(cx, y, blockSize, h);
            ctx.fillStyle = "#8B0000";
            ctx.fillRect(cx + 4, y + 6, 12, 8);
            ctx.fillRect(cx + 20, y + 16, 10, 8);
        } else {
            ctx.fillStyle = "#5d4037";
            ctx.fillRect(cx, y, blockSize, h);
            ctx.fillStyle = "#4CAF50";
            ctx.fillRect(cx, y, blockSize, h / 3);
        }

        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.strokeRect(cx, y, blockSize, h);

        if (y >= groundY) {
            const fillHeight = canvasHeight - (y + h);
            if (fillHeight > 0) {
                if (type === "grass") ctx.fillStyle = "#5d4037";
                else if (type === "snow") ctx.fillStyle = "#1e3f66";
                else if (type === "stone") ctx.fillStyle = "#757575";
                else if (type === "sand") ctx.fillStyle = "#FDD835";
                else if (type === "netherrack") ctx.fillStyle = "#3E1010";
                else ctx.fillStyle = "#5d4037";
                ctx.fillRect(cx, y + h, blockSize, fillHeight);
                ctx.fillStyle = "rgba(0,0,0,0.05)";
                ctx.fillRect(cx + 10, y + h + 10, 20, 20);
            }
        }
    }
}

function drawPixelTree(ctx2d, x, y, type, hp) {
    const trunkW = 20;
    const trunkH = 60;
    const trunkX = x + (80 - trunkW) / 2;
    const trunkY = y + 140 - trunkH;
    if (type === "cactus") {
        ctx2d.fillStyle = "#2E7D32";
        ctx2d.fillRect(trunkX, trunkY, trunkW, trunkH);
        ctx2d.fillRect(trunkX - 15, trunkY + 10, 15, 10);
        ctx2d.fillRect(trunkX - 15, trunkY - 10, 10, 20);
        ctx2d.fillRect(trunkX + 20, trunkY + 20, 15, 10);
        ctx2d.fillRect(trunkX + 25, trunkY + 5, 10, 15);
        return;
    }

    if (type === "palm") {
        ctx2d.fillStyle = "#8D6E63";
        ctx2d.fillRect(trunkX + 6, trunkY - 20, 8, trunkH + 20);
        ctx2d.fillStyle = "#2E7D32";
        ctx2d.beginPath();
        ctx2d.moveTo(trunkX + 10, trunkY - 30);
        ctx2d.lineTo(trunkX - 10, trunkY - 10);
        ctx2d.lineTo(trunkX + 30, trunkY - 10);
        ctx2d.closePath();
        ctx2d.fill();
        return;
    }

    if (type === "spruce" || type === "pine") {
        ctx2d.fillStyle = "#5D4037";
        ctx2d.fillRect(trunkX + 4, trunkY, trunkW - 8, trunkH);
        ctx2d.fillStyle = type === "spruce" ? "#1B5E20" : "#2E7D32";
        ctx2d.beginPath();
        ctx2d.moveTo(x + 40, y + 10);
        ctx2d.lineTo(x + 10, y + 70);
        ctx2d.lineTo(x + 70, y + 70);
        ctx2d.closePath();
        ctx2d.fill();
        ctx2d.fillStyle = "rgba(255,255,255,0.5)";
        ctx2d.fillRect(x + 20, y + 40, 40, 6);
        return;
    }

    let leafColor = "#2E7D32";
    if (type === "birch") leafColor = "#7CB342";
    if (type === "dark_oak") leafColor = "#1B5E20";
    if (type === "mushroom") leafColor = "#D32F2F";

    if (type === "birch") {
        ctx2d.fillStyle = "#F5F5F5";
    } else if (type === "dark_oak") {
        ctx2d.fillStyle = "#4E342E";
    } else {
        ctx2d.fillStyle = "#5D4037";
    }
    ctx2d.fillRect(trunkX, trunkY, trunkW, trunkH);

    ctx2d.fillStyle = leafColor;
    ctx2d.fillRect(x, y + 40, 80, 40);
    ctx2d.fillRect(x + 10, y + 20, 60, 20);
    ctx2d.fillRect(x + 20, y, 40, 20);

    if (type === "birch") {
        ctx2d.fillStyle = "#424242";
        ctx2d.fillRect(trunkX + 4, trunkY + 10, 4, 6);
        ctx2d.fillRect(trunkX + 12, trunkY + 28, 4, 6);
    }

    if (hp < 5) {
        ctx2d.fillStyle = "rgba(0,0,0,0.3)";
        const crackH = (5 - hp) * 10;
        ctx2d.fillRect(trunkX + 5, trunkY + trunkH - crackH, 10, crackH);
    }
}

function drawChest(x, y, opened) {
    const size = blockSize * 0.8;
    ctx.fillStyle = "#795548";
    ctx.fillRect(x, y, size, size);
    ctx.fillStyle = "#3E2723";
    ctx.strokeRect(x, y, size, size);
    ctx.fillStyle = "#FFC107";
    if (opened) {
        ctx.fillRect(x + size * 0.38, y + size * 0.12, size * 0.25, size * 0.12);
        ctx.fillStyle = "#000";
        ctx.fillText("?", x + size * 0.25, y + size * 0.62);
    } else {
        ctx.fillRect(x + size * 0.38, y + size * 0.45, size * 0.25, size * 0.15);
    }
}

function drawItem(x, y, text) {
    const size = blockSize * 0.6;
    const cx = x + size / 2;
    const cy = y + size / 2;
    const r = size / 2;
    const grad = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.2, cx, cy, r);
    grad.addColorStop(0, "#FFF7B0");
    grad.addColorStop(0.55, "#FFD54F");
    grad.addColorStop(1, "#F9A825");

    ctx.save();
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#C99700";
    ctx.lineWidth = Math.max(2, size * 0.08);
    ctx.stroke();

    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.lineWidth = Math.max(1, size * 0.05);
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.72, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.beginPath();
    ctx.arc(cx - r * 0.25, cy - r * 0.28, r * 0.28, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = Math.max(2, size * 0.12);
    ctx.font = `bold ${Math.max(12, Math.round(size * 0.6))}px Arial`;
    ctx.textAlign = "center";
    ctx.strokeText(text, cx, y - size * 0.2);
    ctx.fillText(text, cx, y - size * 0.2);
}

function drawWordGate(gate) {
    if (!gate || gate.remove) return;
    ctx.save();
    ctx.translate(0, 0);
    ctx.fillStyle = gate.locked ? "#FFA726" : "#4CAF50";
    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.lineWidth = 3;
    ctx.fillRect(gate.x, gate.y, gate.width, gate.height);
    ctx.strokeRect(gate.x, gate.y, gate.width, gate.height);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px Verdana";
    ctx.textAlign = "center";
    ctx.fillText(gate.wordObj?.en || "è¯è¯­", gate.x + gate.width / 2, gate.y + 28);
    ctx.font = "14px Verdana";
    ctx.fillText(gate.locked ? "è¯è¯­é—¸é—¨" : "å·²è§£é”", gate.x + gate.width / 2, gate.y + gate.height - 12);
    ctx.restore();
}

function drawParticle(p) {
    if (p.type === "snowflake") {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === "leaf") {
        ctx.fillStyle = p.color || "#7CB342";
        ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === "dust") {
        ctx.fillStyle = "rgba(210, 180, 120, 0.5)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === "ember") {
        ctx.fillStyle = "rgba(255, 140, 0, 0.8)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === "bubble") {
        ctx.strokeStyle = "rgba(173, 216, 230, 0.8)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.stroke();
    } else if (p.type === "sparkle") {
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === "rain") {
        ctx.strokeStyle = "rgba(120, 170, 255, 0.8)";
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + p.velX, p.y + p.size);
        ctx.stroke();
    }
}

function drawBackground(biome) {
    const ambient = biome.effects?.ambient || "#87CEEB";
    ctx.fillStyle = ambient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const parallaxX = cameraX * 0.2;
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    for (let i = 0; i < 3; i++) {
        const mx = -parallaxX + i * 400;
        ctx.beginPath();
        ctx.moveTo(mx, canvas.height - 200);
        ctx.lineTo(mx + 200, canvas.height - 320);
        ctx.lineTo(mx + 400, canvas.height - 200);
        ctx.closePath();
        ctx.fill();
    }

    ctx.fillStyle = "rgba(255,255,255,0.6)";
    for (let i = 0; i < 4; i++) {
        const cx = (i * 220 + (cameraX * 0.4) % 220) - 100;
        ctx.beginPath();
        ctx.arc(cx, 80, 30, 0, Math.PI * 2);
        ctx.arc(cx + 40, 90, 20, 0, Math.PI * 2);
        ctx.arc(cx + 70, 80, 26, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.fillStyle = "rgba(255, 215, 0, 0.8)";
    ctx.beginPath();
    ctx.arc(canvas.width - 80, 60, 24, 0, Math.PI * 2);
    ctx.fill();

    if (biome.effects?.darkness) {
        ctx.fillStyle = `rgba(0,0,0,${biome.effects.darkness})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    if (weatherState.type === "fog") {
        ctx.fillStyle = "rgba(200,200,200,0.25)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    if (weatherState.type === "sandstorm") {
        ctx.fillStyle = "rgba(210,180,140,0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    if (weatherState.type === "rain") {
        ctx.fillStyle = "rgba(0,0,50,0.15)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    if (weatherState.type === "snow") {
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    if (biome.effects?.heatWave) {
        ctx.strokeStyle = "rgba(255, 200, 120, 0.25)";
        for (let y = 120; y < canvas.height; y += 40) {
            ctx.beginPath();
            for (let x = 0; x <= canvas.width; x += 40) {
                const offset = Math.sin((x + gameFrame) * 0.02 + y * 0.05) * 6;
                ctx.lineTo(x, y + offset);
            }
            ctx.stroke();
        }
    }
}

</script>
<script>
/**
 * 14-renderer-entities.js - å®ä½“æ¸²æŸ“å‡½æ•°
 * ä» 14-renderer.js æ‹†åˆ†
 */

/**
 * ç»˜åˆ¶å®ä½“ä¸Šæ–¹çš„è‹±æ–‡åæ ‡ç­¾ (v1.6.2 æ–°å¢)
 * @param {number} x - å®ä½“Xåæ ‡
 * @param {number} y - å®ä½“Yåæ ‡
 * @param {number} width - å®ä½“å®½åº¦
 * @param {string} type - å®ä½“ç±»å‹ï¼ˆå¦‚ "zombie", "chest"ï¼‰
 */
function drawEntityLabel(x, y, width, type) {
    // æ£€æŸ¥é…ç½®å¼€å…³
    if (!settings.showEnvironmentWords) return;

    // æŸ¥æ‰¾æ˜ å°„è¡¨
    const entry = ENTITY_NAMES[type];
    if (!entry) return;

    const centerX = x + width / 2;
    const labelY = y - 14;  // åœ¨å®ä½“ä¸Šæ–¹14åƒç´ 

    ctx.save();
    ctx.font = "bold 11px Arial";
    ctx.textAlign = "center";

    // é»‘è‰²æè¾¹ï¼ˆç¡®ä¿åœ¨ä»»ä½•èƒŒæ™¯ä¸‹å¯è§ï¼‰
    ctx.strokeStyle = "rgba(0,0,0,0.7)";
    ctx.lineWidth = 3;
    ctx.strokeText(entry.en, centerX, labelY);

    // ç™½è‰²æ–‡å­—
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillText(entry.en, centerX, labelY);

    ctx.restore();
}


function drawSteve(x, y, facingRight, attacking) {
    const s = player.width / 26;
    ctx.fillStyle = "#00AAAA";
    ctx.fillRect(x + 6 * s, y + 20 * s, 14 * s, 20 * s);
    ctx.fillStyle = "#0000AA";
    ctx.fillRect(x + 6 * s, y + 40 * s, 14 * s, 12 * s);
    ctx.fillStyle = "#F5Bca9";
    ctx.fillRect(x + 3 * s, y, 20 * s, 20 * s);
    ctx.fillStyle = "#4A332A";
    ctx.fillRect(x + 3 * s, y, 20 * s, 6 * s);

    // Eyes: Black
    ctx.fillStyle = "#000";
    const ex = facingRight ? x + 16 * s : x + 6 * s;
    ctx.fillRect(ex, y + 6 * s, 4 * s, 4 * s); // Steve's eye

    if (attacking) {
        ctx.save();
        ctx.translate(x + (facingRight ? 26 * s : 0), y + 26 * s);
        if (!facingRight) ctx.scale(-1, 1);
        ctx.rotate(Math.PI / 4);
        ctx.fillStyle = "#00FFFF";
        ctx.fillRect(0, -16 * s, 5 * s, 32 * s);
        ctx.restore();
    }
}

function drawMobRect(x, y, s, px, py, pw, ph) {
    ctx.fillRect(x + px * s, y + py * s, pw * s, ph * s);
}

function drawCreeperMob(enemy) {
    const x = enemy.x;
    const s = enemy.width / 16;
    const y = enemy.y + enemy.height - 24 * s;

    // Base greens close to the in-game creeper texture.
    ctx.fillStyle = "#3AAE2A";
    drawMobRect(x, y, s, 0, 0, 16, 8); // head
    drawMobRect(x, y, s, 2, 8, 12, 8); // body
    // legs
    drawMobRect(x, y, s, 1, 16, 3, 8);
    drawMobRect(x, y, s, 5, 16, 3, 8);
    drawMobRect(x, y, s, 8, 16, 3, 8);
    drawMobRect(x, y, s, 12, 16, 3, 8);

    // Texture patches
    ctx.fillStyle = "#2E7D32";
    drawMobRect(x, y, s, 1, 1, 3, 2);
    drawMobRect(x, y, s, 10, 1, 3, 2);
    drawMobRect(x, y, s, 4, 9, 2, 2);
    drawMobRect(x, y, s, 11, 10, 2, 2);

    // Face
    ctx.fillStyle = "#111";
    drawMobRect(x, y, s, 3, 2, 3, 3);  // left eye
    drawMobRect(x, y, s, 10, 2, 3, 3); // right eye
    drawMobRect(x, y, s, 7, 5, 2, 2);  // nose
    drawMobRect(x, y, s, 6, 6, 4, 2);  // mouth top
    drawMobRect(x, y, s, 5, 7, 2, 1);  // mouth left
    drawMobRect(x, y, s, 9, 7, 2, 1);  // mouth right
}

function drawEnemy(enemy) {
    if (enemy.remove || enemy.y > 900) return;
    switch (enemy.type) {
        case "zombie":
            drawZombie(enemy);
            break;
        case "spider":
            drawSpider(enemy);
            break;
        case "creeper":
            drawCreeperMob(enemy);
            if (enemy.state === "exploding") {
                const flash = Math.floor(enemy.explodeTimer / 10) % 2 === 0;
                if (flash) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.fillRect(enemy.x - 6, enemy.y - 6, enemy.width + 12, enemy.height + 12);
                }
            }
            break;
        case "skeleton":
            drawSkeleton(enemy);
            break;
        case "enderman":
            drawEnderman(enemy);
            break;
        case "ender_dragon":
            drawEnderDragon(enemy.x, enemy.y);
            break;
    }

    if (enemy.hp < enemy.maxHp) {
        drawHealthBar(enemy.x, enemy.y - 8, enemy.width, enemy.hp, enemy.maxHp);
    }

    // === v1.6.2 æ–°å¢ï¼šç»˜åˆ¶è‹±æ–‡åæ ‡ç­¾ ===
    // å¦‚æœæœ‰è¡€æ¡ï¼Œæ ‡ç­¾ä½ç½®ä¸Šç§»é¿å…é‡å 
    const labelOffset = enemy.hp < enemy.maxHp ? 16 : 0;
    drawEntityLabel(enemy.x, enemy.y - labelOffset, enemy.width, enemy.type);
}

function drawZombie(enemy) {
    const x = enemy.x;
    const s = enemy.width / 16;
    const y = enemy.y + enemy.height - 24 * s;

    // Head (green), shirt (blue), pants (purple) - closer to the classic Minecraft zombie palette.
    ctx.fillStyle = "#4CAF50";
    drawMobRect(x, y, s, 0, 0, 16, 8);
    ctx.fillStyle = "#2E7D32";
    drawMobRect(x, y, s, 2, 1, 3, 2);
    drawMobRect(x, y, s, 11, 2, 3, 2);

    // Face
    ctx.fillStyle = "#1B1B1B";
    drawMobRect(x, y, s, 4, 3, 2, 2);
    drawMobRect(x, y, s, 10, 3, 2, 2);
    ctx.fillStyle = "#2B2B2B";
    drawMobRect(x, y, s, 7, 5, 2, 1);

    // Torso + arms
    ctx.fillStyle = "#2E7D9A"; // shirt
    drawMobRect(x, y, s, 3, 8, 10, 8);
    drawMobRect(x, y, s, 0, 8, 3, 12);
    drawMobRect(x, y, s, 13, 8, 3, 12);

    // Pants + legs
    ctx.fillStyle = "#5E35B1";
    drawMobRect(x, y, s, 3, 16, 5, 8);
    drawMobRect(x, y, s, 8, 16, 5, 8);
    ctx.fillStyle = "#4527A0";
    drawMobRect(x, y, s, 3, 22, 5, 2);
    drawMobRect(x, y, s, 8, 22, 5, 2);
}

function drawSpider(enemy) {
    const x = enemy.x;
    const y = enemy.y + enemy.height - 12 * (enemy.width / 22);
    const s = enemy.width / 22;

    // Body
    ctx.fillStyle = "#1B1B1B";
    ctx.fillRect(x + 4 * s, y + 3 * s, 14 * s, 6 * s);
    ctx.fillStyle = "#2B2B2B";
    ctx.fillRect(x + 6 * s, y + 2 * s, 10 * s, 3 * s);

    // Eyes (red)
    ctx.fillStyle = "#D50000";
    ctx.fillRect(x + 7 * s, y + 3 * s, 2 * s, 2 * s);
    ctx.fillRect(x + 13 * s, y + 3 * s, 2 * s, 2 * s);

    // Legs (8)
    ctx.strokeStyle = "#111";
    ctx.lineWidth = Math.max(2, s);
    const legPairs = [
        [[6, 4], [1, 1]],
        [[6, 7], [1, 10]],
        [[8, 4], [2, 0]],
        [[8, 7], [2, 11]],
        [[16, 4], [21, 1]],
        [[16, 7], [21, 10]],
        [[14, 4], [20, 0]],
        [[14, 7], [20, 11]]
    ];
    ctx.beginPath();
    for (const [[sx, sy], [ex, ey]] of legPairs) {
        ctx.moveTo(x + sx * s, y + sy * s);
        ctx.lineTo(x + ex * s, y + ey * s);
    }
    ctx.stroke();
}

function drawSkeleton(enemy) {
    const x = enemy.x;
    const s = enemy.width / 16;
    const y = enemy.y + enemy.height - 24 * s;

    ctx.fillStyle = "#E0E0E0";
    drawMobRect(x, y, s, 0, 0, 16, 8); // head
    ctx.fillStyle = "#111";
    drawMobRect(x, y, s, 4, 3, 3, 3);
    drawMobRect(x, y, s, 9, 3, 3, 3);

    // torso + arms
    ctx.fillStyle = "#D6D6D6";
    drawMobRect(x, y, s, 4, 8, 8, 8);
    drawMobRect(x, y, s, 1, 8, 3, 12);
    drawMobRect(x, y, s, 12, 8, 3, 12);

    // ribs detail
    ctx.fillStyle = "#BDBDBD";
    for (let i = 0; i < 4; i++) drawMobRect(x, y, s, 5, 9 + i * 2, 6, 1);

    // legs
    ctx.fillStyle = "#D6D6D6";
    drawMobRect(x, y, s, 5, 16, 3, 8);
    drawMobRect(x, y, s, 8, 16, 3, 8);

    // simple bow hint
    ctx.strokeStyle = "#8B4513";
    ctx.lineWidth = Math.max(2, s);
    ctx.beginPath();
    ctx.arc(x + 1.5 * s, y + 12 * s, 4 * s, 0, Math.PI);
    ctx.stroke();
}

function drawEnderman(enemy) {
    const x = enemy.x;
    const s = enemy.width / 16;
    const y = enemy.y + enemy.height - 32 * s;

    ctx.fillStyle = "#0B0B0B";
    // head
    drawMobRect(x, y, s, 0, 0, 16, 8);
    // torso
    drawMobRect(x, y, s, 6, 8, 4, 10);
    // arms
    drawMobRect(x, y, s, 4, 8, 2, 20);
    drawMobRect(x, y, s, 10, 8, 2, 20);
    // legs
    drawMobRect(x, y, s, 6, 18, 2, 14);
    drawMobRect(x, y, s, 8, 18, 2, 14);

    // eyes
    ctx.fillStyle = "#AA00FF";
    drawMobRect(x, y, s, 4, 3, 3, 1);
    drawMobRect(x, y, s, 9, 3, 3, 1);
    ctx.fillStyle = "#E1BEE7";
    drawMobRect(x, y, s, 5, 3, 1, 1);
    drawMobRect(x, y, s, 10, 3, 1, 1);
}

function drawEnderDragon(x, y) {
    ctx.fillStyle = "#000000";
    ctx.fillRect(x, y + 20, 80, 30);
    ctx.fillRect(x + 60, y + 30, 40, 15);
    ctx.fillStyle = "#AA00FF";
    ctx.fillRect(x + 85, y + 35, 4, 4);
    const wingFlap = Math.sin(gameFrame * 0.1) * 10;
    ctx.fillStyle = "#1A0033";
    ctx.beginPath();
    ctx.moveTo(x + 20, y + 25);
    ctx.lineTo(x - 20, y + 10 + wingFlap);
    ctx.lineTo(x + 10, y + 35);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 60, y + 25);
    ctx.lineTo(x + 100, y + 10 + wingFlap);
    ctx.lineTo(x + 70, y + 35);
    ctx.fill();
}

function drawGolem(golem) {
    const x = golem.x;
    const y = golem.y;
    if (golem.type === "iron") {
        ctx.fillStyle = "#757575";
        ctx.fillRect(x + 10, y + 10, 20, 38);
        ctx.fillStyle = "#424242";
        ctx.fillRect(x + 5, y, 30, 10);
        ctx.fillStyle = "#FF5722";
        ctx.fillRect(x + 12, y + 3, 4, 4);
        ctx.fillRect(x + 22, y + 3, 4, 4);
    } else {
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + 8, y + 15, 16, 16);
        ctx.fillRect(x + 10, y, 12, 12);
        ctx.fillStyle = "#FF5722";
        ctx.fillRect(x + 12, y + 4, 2, 2);
        ctx.fillRect(x + 18, y + 4, 2, 2);
        ctx.fillStyle = "#FFA500";
        ctx.fillRect(x + 15, y + 6, 4, 2);
    }
    drawHealthBar(x, y - 8, golem.width, golem.hp, golem.maxHp);

    // === v1.6.2 æ–°å¢ï¼šç»˜åˆ¶è‹±æ–‡åæ ‡ç­¾ ===
    const golemType = golem.type === "iron" ? "iron_golem" : "snow_golem";
    drawEntityLabel(x, y - 16, golem.width, golemType);
}

function drawHealthBar(x, y, width, hp, maxHp) {
    const barWidth = width;
    const barHeight = 4;
    const hpPercent = Math.max(0, hp / maxHp);
    ctx.fillStyle = "#333";
    ctx.fillRect(x, y, barWidth, barHeight);
    ctx.fillStyle = hpPercent > 0.5 ? "#4CAF50" : hpPercent > 0.2 ? "#FFC107" : "#F44336";
    ctx.fillRect(x, y, barWidth * hpPercent, barHeight);
}

function drawProjectile(proj) {
    if (proj instanceof Arrow) {
        ctx.fillStyle = "#8B4513";
        ctx.save();
        ctx.translate(proj.x, proj.y);
        const angle = Math.atan2(proj.velY, proj.velX);
        ctx.rotate(angle);
        ctx.fillRect(0, -1, 12, 2);
        ctx.fillStyle = "#C0C0C0";
        ctx.fillRect(10, -2, 2, 4);
        ctx.restore();
    } else if (proj instanceof Snowball) {
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#E0E0E0";
        ctx.stroke();
    } else if (proj instanceof DragonFireball) {
        ctx.fillStyle = "#FF5722";
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#FF9800";
        ctx.stroke();
    }
}

</script>
<script>
/**
 * 14-renderer-decorations.js - è£…é¥°ç‰©æ¸²æŸ“å‡½æ•°
 * ä» 14-renderer.js æ‹†åˆ†
 */

function drawDecoration(decor) {
    switch (decor.type) {
        case "bush":
            drawBush(decor);
            break;
        case "flower":
            drawFlower(decor);
            break;
        case "mushroom":
            drawMushroom(decor);
            break;
        case "vine":
            drawVine(decor);
            break;
        case "ice_spike":
            drawIceSpike(decor);
            break;
        case "snow_pile":
            drawSnowPile(decor);
            break;
        case "ice_block":
            drawIceBlock(decor);
            break;
        case "dead_bush":
            drawDeadBush(decor);
            break;
        case "rock":
            drawRock(decor);
            break;
        case "bones":
            drawBones(decor);
            break;
        case "cactus":
            drawCactusDecor(decor);
            break;
        case "ore_coal":
        case "ore_iron":
        case "ore_gold":
        case "ore_diamond":
            drawOre(decor);
            break;
        case "stalactite":
            drawStalactite(decor);
            break;
        case "crystal":
            drawCrystal(decor);
            break;
        case "lava_pool":
            drawLavaPool(decor);
            break;
        case "shell":
            drawShell(decor);
            break;
        case "starfish":
            drawStarfish(decor);
            break;
        case "seaweed":
            drawSeaweed(decor);
            break;
        case "boat":
            drawBoatDecor(decor);
            break;
        case "fire":
            drawFireDecor(decor);
            break;
        case "lava_fall":
            drawLavaFall(decor);
            break;
        case "soul_sand":
            drawSoulSand(decor);
            break;
        case "nether_wart":
            drawNetherWart(decor);
            break;
        case "basalt":
            drawBasalt(decor);
            break;
        default:
            break;
    }
}

function drawBush(bush) {
    const x = bush.x;
    const y = bush.y;
    ctx.fillStyle = "#2E7D32";
    ctx.beginPath();
    ctx.ellipse(x + 15, y + 10, 15, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.ellipse(x + 12, y + 8, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    if (bush.variant === 1) {
        ctx.fillStyle = "#2E7D32";
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 12, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
    } else if (bush.variant === 2) {
        ctx.fillStyle = "#FF1744";
        ctx.fillRect(x + 10, y + 5, 3, 3);
        ctx.fillRect(x + 18, y + 7, 3, 3);
    }
}

function drawFlower(flower) {
    const x = flower.x;
    const y = flower.y;
    ctx.fillStyle = "#4CAF50";
    ctx.fillRect(x + 5, y + 8, 2, 10);
    ctx.fillStyle = flower.color;
    for (let i = 0; i < 4; i++) {
        const angle = (Math.PI / 2) * i;
        const px = x + 6 + Math.cos(angle) * 4;
        const py = y + 6 + Math.sin(angle) * 4;
        ctx.fillRect(px, py, 4, 4);
    }
    ctx.fillStyle = "#FFEB3B";
    ctx.fillRect(x + 5, y + 5, 3, 3);
}

function drawMushroom(mushroom) {
    const x = mushroom.x;
    const y = mushroom.y;
    ctx.fillStyle = "#F5F5DC";
    ctx.fillRect(x + 6, y + 8, 4, 12);
    ctx.fillStyle = mushroom.isRed ? "#D32F2F" : "#8D6E63";
    ctx.fillRect(x, y, 16, 10);
    ctx.fillRect(x + 2, y - 2, 12, 2);
    if (mushroom.isRed) {
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + 4, y + 3, 3, 3);
        ctx.fillRect(x + 10, y + 5, 2, 2);
        ctx.fillRect(x + 7, y + 1, 2, 2);
    }
}

function drawVine(vine) {
    const x = vine.x;
    const y = vine.y;
    const sway = Math.sin(vine.animFrame * 0.05 + vine.swayOffset) * 3;
    ctx.strokeStyle = "#2E7D32";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, y);
    const segments = 5;
    for (let i = 1; i <= segments; i++) {
        const segY = y + (vine.height / segments) * i;
        const segX = x + sway * (i / segments);
        ctx.lineTo(segX, segY);
    }
    ctx.stroke();
    ctx.fillStyle = "#4CAF50";
    for (let i = 1; i < segments; i++) {
        const leafY = y + (vine.height / segments) * i;
        const leafX = x + sway * (i / segments);
        ctx.fillRect(leafX - 3, leafY, 6, 4);
    }
}

function drawIceSpike(spike) {
    const x = spike.x;
    const y = spike.y;
    const h = spike.height;
    const gradient = ctx.createLinearGradient(x, y, x, y + h);
    gradient.addColorStop(0, "#E3F2FD");
    gradient.addColorStop(0.5, "#90CAF9");
    gradient.addColorStop(1, "#42A5F5");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 20, y + h);
    ctx.lineTo(x, y + h);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    ctx.beginPath();
    ctx.moveTo(x + 10, y + 5);
    ctx.lineTo(x + 14, y + h / 2);
    ctx.lineTo(x + 10, y + h / 2);
    ctx.fill();
}

function drawSnowPile(pile) {
    const x = pile.x;
    const y = pile.y;
    const w = pile.width;
    const h = pile.height;
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "rgba(200, 220, 255, 0.6)";
    ctx.beginPath();
    ctx.ellipse(x + w / 2, y + h - 5, w / 2 - 3, h / 4, 0, 0, Math.PI * 2);
    ctx.fill();
}

function drawIceBlock(ice) {
    const x = ice.x;
    const y = ice.y;
    const w = ice.width;
    const h = ice.height;
    ctx.fillStyle = "#B3E5FC";
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
    ctx.fillRect(x + 5, y + 5, w - 10, 10);
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
        const cx = x + Math.random() * w;
        const cy = y + Math.random() * h;
        ctx.beginPath();
        ctx.moveTo(cx - 5, cy);
        ctx.lineTo(cx + 5, cy);
        ctx.moveTo(cx, cy - 5);
        ctx.lineTo(cx, cy + 5);
        ctx.stroke();
    }
}

function drawDeadBush(bush) {
    const x = bush.x;
    const y = bush.y;
    ctx.strokeStyle = "#5D4037";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 12, y + 30);
    ctx.lineTo(x + 12, y + 15);
    ctx.stroke();
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 12, y + 18);
    ctx.lineTo(x + 5, y + 10);
    ctx.moveTo(x + 5, y + 10);
    ctx.lineTo(x + 3, y + 5);
    ctx.moveTo(x + 12, y + 20);
    ctx.lineTo(x + 20, y + 12);
    ctx.moveTo(x + 20, y + 12);
    ctx.lineTo(x + 23, y + 8);
    ctx.stroke();
}

function drawRock(rock) {
    const x = rock.x;
    const y = rock.y;
    const w = rock.width;
    const h = rock.height;
    ctx.fillStyle = "#9E9E9E";
    if (rock.shape === 0) {
        ctx.beginPath();
        ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
    } else if (rock.shape === 1) {
        ctx.fillRect(x, y, w, h);
    } else {
        ctx.beginPath();
        ctx.moveTo(x + w * 0.2, y);
        ctx.lineTo(x + w * 0.8, y);
        ctx.lineTo(x + w, y + h * 0.6);
        ctx.lineTo(x + w * 0.7, y + h);
        ctx.lineTo(x + w * 0.3, y + h);
        ctx.lineTo(x, y + h * 0.5);
        ctx.closePath();
        ctx.fill();
    }
    ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
    ctx.fillRect(x + 5, y + h - 5, w - 10, 5);
}

function drawBones(bones) {
    const x = bones.x;
    const y = bones.y;
    ctx.strokeStyle = "#E0E0E0";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, y + 6);
    ctx.lineTo(x + 30, y + 6);
    ctx.stroke();
    ctx.fillStyle = "#EEEEEE";
    ctx.beginPath();
    ctx.arc(x + 4, y + 6, 4, 0, Math.PI * 2);
    ctx.arc(x + 26, y + 6, 4, 0, Math.PI * 2);
    ctx.fill();
}

function drawCactusDecor(cactus) {
    const x = cactus.x;
    const y = cactus.y;
    const h = cactus.height;
    ctx.fillStyle = "#2E7D32";
    ctx.fillRect(x + 4, y, 12, h);
    ctx.fillStyle = "#1B5E20";
    for (let i = 0; i < h; i += 10) {
        ctx.fillRect(x + 2, y + i, 2, 4);
        ctx.fillRect(x + 16, y + i + 5, 2, 4);
    }
    if (h > 50) {
        ctx.fillStyle = "#2E7D32";
        ctx.fillRect(x, y + 20, 8, 15);
        ctx.fillRect(x + 12, y + 35, 8, 15);
    }
}

function drawOre(ore) {
    const x = ore.x;
    const y = ore.y;
    ctx.fillStyle = "#757575";
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = ore.color;
    ctx.fillRect(x + 5, y + 8, 8, 8);
    ctx.fillRect(x + 15, y + 5, 10, 6);
    ctx.fillRect(x + 8, y + 18, 6, 8);
    if (ore.oreType === "diamond" || ore.oreType === "gold") {
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.fillRect(x + 7, y + 10, 2, 2);
        ctx.fillRect(x + 18, y + 7, 2, 2);
    }
}

function drawStalactite(stal) {
    const x = stal.x;
    const y = stal.y;
    const h = stal.height;
    ctx.fillStyle = "#616161";
    ctx.beginPath();
    if (stal.direction === "down") {
        ctx.moveTo(x + 10, y);
        ctx.lineTo(x + 20, y + h);
        ctx.lineTo(x, y + h);
    } else {
        ctx.moveTo(x, y);
        ctx.lineTo(x + 20, y);
        ctx.lineTo(x + 10, y + h);
    }
    ctx.closePath();
    ctx.fill();
}

function drawCrystal(crystal) {
    const x = crystal.x;
    const y = crystal.y;
    const glow = 0.6 + Math.sin(crystal.animFrame * 0.1) * 0.2;
    ctx.fillStyle = `rgba(160, 255, 255, ${glow})`;
    ctx.beginPath();
    ctx.moveTo(x + 9, y);
    ctx.lineTo(x + 18, y + 16);
    ctx.lineTo(x + 9, y + 28);
    ctx.lineTo(x, y + 16);
    ctx.closePath();
    ctx.fill();
}

function drawLavaPool(pool) {
    const x = pool.x;
    const y = pool.y;
    const w = pool.width;
    const h = pool.height;
    const wave = Math.sin(pool.animFrame * 0.1) * 3;
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(x, y + wave, w, h);
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.fillRect(x + 5, y + 4 + wave, w - 10, 4);
}

function drawShell(shell) {
    const x = shell.x;
    const y = shell.y;
    ctx.fillStyle = "#FFE0B2";
    ctx.beginPath();
    ctx.arc(x + 8, y + 6, 6, Math.PI, 0);
    ctx.fill();
}

function drawStarfish(star) {
    const x = star.x;
    const y = star.y;
    ctx.fillStyle = "#FF9800";
    ctx.beginPath();
    ctx.moveTo(x + 9, y);
    ctx.lineTo(x + 12, y + 6);
    ctx.lineTo(x + 18, y + 7);
    ctx.lineTo(x + 13, y + 11);
    ctx.lineTo(x + 15, y + 18);
    ctx.lineTo(x + 9, y + 14);
    ctx.lineTo(x + 3, y + 18);
    ctx.lineTo(x + 5, y + 11);
    ctx.lineTo(x, y + 7);
    ctx.lineTo(x + 6, y + 6);
    ctx.closePath();
    ctx.fill();
}

function drawSeaweed(seaweed) {
    const x = seaweed.x;
    const y = seaweed.y;
    const sway = Math.sin(seaweed.animFrame * 0.05 + seaweed.swayOffset) * 4;
    ctx.strokeStyle = "#2E7D32";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 5, y + seaweed.height);
    ctx.lineTo(x + 5 + sway, y);
    ctx.stroke();
}

function drawBoatDecor(boat) {
    const x = boat.x;
    const y = boat.y;
    ctx.fillStyle = "#8D6E63";
    ctx.fillRect(x, y, boat.width, boat.height);
    ctx.fillStyle = "#6D4C41";
    ctx.fillRect(x + 4, y - 6, boat.width - 8, 6);
}

function drawFireDecor(fire) {
    const x = fire.x;
    const y = fire.y;
    const flicker = Math.sin(fire.animFrame * 0.2) * 2;
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(x + 6, y + 24);
    ctx.lineTo(x + 12, y + 24);
    ctx.lineTo(x + 9, y + 6 + flicker);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#FFC107";
    ctx.beginPath();
    ctx.moveTo(x + 6, y + 20);
    ctx.lineTo(x + 12, y + 20);
    ctx.lineTo(x + 9, y + 10 + flicker);
    ctx.closePath();
    ctx.fill();
}

function drawLavaFall(fall) {
    const x = fall.x;
    const y = fall.y;
    const h = fall.height;
    const wobble = Math.sin(fall.animFrame * 0.1) * 2;
    ctx.fillStyle = "#FF7043";
    ctx.fillRect(x + wobble, y, fall.width, h);
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.fillRect(x + wobble + 2, y + 10, fall.width - 4, 6);
}

function drawSoulSand(sand) {
    const x = sand.x;
    const y = sand.y;
    const w = sand.width;
    ctx.fillStyle = "#5D4037";
    ctx.fillRect(x, y, w, sand.height);
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(x + 4, y + 2, w - 8, 4);
}

function drawNetherWart(wart) {
    const x = wart.x;
    const y = wart.y;
    ctx.fillStyle = "#B71C1C";
    ctx.fillRect(x, y, 12, 10);
    ctx.fillStyle = "#D32F2F";
    ctx.fillRect(x + 2, y + 2, 8, 4);
}

function drawBasalt(basalt) {
    const x = basalt.x;
    const y = basalt.y;
    ctx.fillStyle = "#424242";
    ctx.fillRect(x, y, basalt.width, basalt.height);
    ctx.fillStyle = "#303030";
    ctx.fillRect(x + 4, y + 6, basalt.width - 8, 6);
}

</script>
<script>
/**
 * 15-entities-base.js - ç¢°æ’æ£€æµ‹ä¸åŸºç¡€å®ä½“ç±»
 * ä» 15-entities.js æ‹†åˆ†
 */
function colCheck(shapeA, shapeB) {
    return colCheckRect(shapeA.x, shapeA.y, shapeA.width, shapeA.height, shapeB.x, shapeB.y, shapeB.width, shapeB.height);
}

function colCheckRect(x1, y1, w1, h1, x2, y2, w2, h2) {
    const vX = (x1 + w1 / 2) - (x2 + w2 / 2);
    const vY = (y1 + h1 / 2) - (y2 + h2 / 2);
    const hWidths = w1 / 2 + w2 / 2;
    const hHeights = h1 / 2 + h2 / 2;
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {
        const oX = hWidths - Math.abs(vX);
        const oY = hHeights - Math.abs(vY);
        if (oX >= oY || oY < 15) {
            if (vY > 0) return "t";
            return "b";
        }
        if (vX > 0) return "l";
        return "r";
    }
    return null;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

class Entity {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
        this.remove = false;
    }
}

class Platform extends Entity {
    constructor(x, y, w, h, type) {
        super(x, y, w, h);
        this.type = type;
    }
}

class Tree extends Entity {
    constructor(x, y, type) {
        const w = blockSize * 1.6;
        const h = blockSize * 2.8;
        super(x, y - h, w, h);
        this.type = type;
        this.hp = 5;
        this.shake = 0;
    }
    hit() {
        this.hp--;
        this.shake = 8;
        if (this.hp <= 0) {
            this.remove = true;
            dropItem("stick", this.x + this.width / 2, this.y + this.height - blockSize * 0.4);
        }
    }
}

class Chest extends Entity {
    constructor(x, y) {
        const size = blockSize * 0.8;
        super(x, y - size, size, size);
        this.opened = false;
        this.lastClickTime = 0;
        this.pendingArmor = null;
    }
    open() {
        if (this.opened) return;
        this.opened = true;
        const diff = getDifficultyState();
        const lootCfg = getLootConfig();

        // === v1.6.1 æ–°å¢ï¼šç­”å¯¹åæå‡ç¨€æœ‰åº¦ ===
        let rarity = pickChestRarity(lootCfg.chestRarities, diff.chestRareBoost);
        if (this._rarityBoost) {
            const levels = ['common', 'rare', 'epic', 'legendary'];
            const idx = levels.indexOf(rarity);

            if (idx >= 0 && idx < levels.length - 1) {
                rarity = levels[idx + 1];  // æå‡ä¸€çº§
                console.log(`[v1.6.1] å®ç®±ç¨€æœ‰åº¦æå‡ï¼š${levels[idx]} â†’ ${rarity}`);
            }

            this._rarityBoost = false;  // æ¸…é™¤æ ‡è®°
        }
        // === v1.6.1 ç»“æŸ ===

        const lootTable = lootCfg.chestTables[rarity] || lootCfg.chestTables.common || [];
        const baseTwo = Number(lootCfg.chestRolls.twoDropChance ?? 0.45);
        const baseThree = Number(lootCfg.chestRolls.threeDropChance ?? 0.15);
        const rollBonus = Number(diff.chestRollBonus) || 0;
        const twoChance = clamp(baseTwo + rollBonus, 0.1, 0.9);
        const threeChance = clamp(baseThree + rollBonus * 0.6, 0.05, 0.6);
        const rollCount = Math.random() < threeChance ? 3 : Math.random() < twoChance ? 2 : 1;
        const drops = [];
        for (let i = 0; i < rollCount; i++) {
            const picked = pickWeightedLoot(lootTable);
            if (!picked) continue;
            const count = picked.min + Math.floor(Math.random() * (picked.max - picked.min + 1));
            drops.push({ item: picked.item, count });
        }
        drops.forEach(d => {
            if (d.item === "hp") {
                healPlayer(d.count);
                return;
            }
            if (d.item === "max_hp") {
                playerMaxHp = Math.min(10, playerMaxHp + d.count);
                playerHp = Math.min(playerMaxHp, playerHp + d.count);
                updateHpUI();
                return;
            }
            if (d.item === "score") {
                addScore(d.count);
                return;
            }
            if (d.item && d.item.startsWith("armor_")) {
                const armorId = d.item.replace("armor_", "");
                this.pendingArmor = armorId;
                if (typeof addArmorToInventory === "function") addArmorToInventory(armorId);
                const armorName = ARMOR_TYPES[armorId]?.name || armorId;
                showToast(`âœ¨ è·å¾— ${armorName}ï¼ŒåŒå‡»å®ç®±å³å¯è£…å¤‡`);
                return;
            }
            if (!inventory[d.item] && inventory[d.item] !== 0) inventory[d.item] = 0;
            inventory[d.item] += d.count;
        });
        updateHpUI();
        updateInventoryUI();
        const summary = drops.map(d => `${ITEM_ICONS[d.item] || "âœ¨"}x${d.count}`).join(" ");
        const rarityLabel = { common: "æ™®é€š", rare: "ç¨€æœ‰", epic: "å²è¯—", legendary: "ä¼ è¯´" }[rarity] || "æ™®é€š";
        showFloatingText("ğŸ", this.x + 10, this.y - 30);
        if (summary) showToast(`å®ç®±(${rarityLabel}): ${summary}`);
        onChestOpened();
    }

    onDoubleClick() {
        if (!this.opened) return;
        if (this.pendingArmor && equipArmor(this.pendingArmor)) {
            this.pendingArmor = null;
            return;
        }
        if (typeof showArmorSelectUI === "function") {
            showArmorSelectUI();
        }
    }
}

class Item extends Entity {
    constructor(x, y, wordObj) {
        const size = blockSize * 0.6;
        super(x, y, size, size);
        this.wordObj = wordObj;
        this.collected = false;
        this.floatY = 0;
    }
}

class WordGate extends Entity {
    constructor(x, y, wordObj) {
        super(x - 30, y - 90, 90, 90);
        this.wordObj = wordObj;
        this.locked = true;
        this.attempts = 0;
        this.cooldown = 0;
    }
}

const decorationPool = Object.create(null);

function getPooledDecoration(type, resetFn, createFn) {
    const pool = decorationPool[type] || (decorationPool[type] = []);
    const reused = pool.find(d => d.remove);
    if (reused) {
        resetFn(reused);
        reused.remove = false;
        return reused;
    }
    const fresh = createFn();
    pool.push(fresh);
    return fresh;
}

function spawnDecoration(type, resetFn, createFn) {
    if (decorations.length >= MAX_DECORATIONS_ONSCREEN) return;
    const decor = getPooledDecoration(type, resetFn, createFn);
    decorations.push(decor);
}

</script>
<script>
/**
 * 15-entities-decorations.js - è£…é¥°å®ä½“ç±»
 * ä» 15-entities.js æ‹†åˆ† (åŸå§‹è¡Œ 182-605)
 */

class Decoration extends Entity {
    constructor(x, y, type, biome) {
        super(x, y, 0, 0);
        this.type = type;
        this.biome = biome;
        this.interactive = false;
        this.collectible = false;
        this.harmful = false;
        this.animated = false;
        this.animFrame = 0;
    }

    resetBase(x, y, type, biome) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.biome = biome;
        this.remove = false;
        this.animFrame = 0;
    }

    update() {
        if (this.animated) this.animFrame++;
    }

    interact() {
    }

    onCollision() {
    }
}

class Bush extends Decoration {
    constructor(x, y) {
        super(x, y, "bush", "forest");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "bush", "forest");
        this.width = 30;
        this.height = 20;
        this.variant = Math.floor(Math.random() * 3);
    }
}

class Flower extends Decoration {
    constructor(x, y) {
        super(x, y, "flower", "forest");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "flower", "forest");
        this.width = 12;
        this.height = 18;
        this.collectible = true;
        this.color = ["#FF1744", "#FFEB3B", "#2196F3", "#9C27B0", "#FFFFFF"][Math.floor(Math.random() * 5)];
    }
    interact() {
        inventory.flower = (inventory.flower || 0) + 1;
        this.remove = true;
        showFloatingText("ğŸŒ¸ +1", this.x, this.y);
        updateInventoryUI();
    }
}

class Mushroom extends Decoration {
    constructor(x, y) {
        super(x, y, "mushroom", "forest");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "mushroom", "forest");
        this.width = 16;
        this.height = 20;
        this.collectible = true;
        this.isRed = Math.random() > 0.5;
    }
    interact() {
        inventory.mushroom = (inventory.mushroom || 0) + 1;
        this.remove = true;
        showFloatingText("ğŸ„ +1", this.x, this.y);
        updateInventoryUI();
    }
}

class Vine extends Decoration {
    constructor(x, y, height) {
        super(x, y, "vine", "forest");
        this.reset(x, y, height);
    }
    reset(x, y, height) {
        this.resetBase(x, y, "vine", "forest");
        this.width = 4;
        this.height = height || (30 + Math.random() * 40);
        this.animated = true;
        this.swayOffset = Math.random() * Math.PI * 2;
    }
}

class IceSpike extends Decoration {
    constructor(x, y) {
        super(x, y, "ice_spike", "snow");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "ice_spike", "snow");
        this.width = 20;
        this.height = 40 + Math.random() * 40;
    }
}

class SnowPile extends Decoration {
    constructor(x, y, size = "medium") {
        super(x, y, "snow_pile", "snow");
        this.reset(x, y, size);
    }
    reset(x, y, size = "medium") {
        this.resetBase(x, y, "snow_pile", "snow");
        this.size = size;
        this.width = size === "small" ? 20 : size === "medium" ? 35 : 50;
        this.height = size === "small" ? 10 : size === "medium" ? 18 : 25;
        this.interactive = true;
    }
    onCollision(entity) {
        if (entity === player && entity.grounded) {
            entity.velX *= 0.9;
        }
    }
}

class IceBlock extends Decoration {
    constructor(x, y, width) {
        super(x, y, "ice_block", "snow");
        this.reset(x, y, width);
    }
    reset(x, y, width) {
        this.resetBase(x, y, "ice_block", "snow");
        this.width = width || 80;
        this.height = 50;
        this.interactive = true;
        this.slippery = true;
    }
    onCollision(entity) {
        if (this.slippery && entity.grounded) {
            entity.velX *= 1.2;
        }
    }
}

class DeadBush extends Decoration {
    constructor(x, y) {
        super(x, y, "dead_bush", "desert");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "dead_bush", "desert");
        this.width = 25;
        this.height = 30;
    }
}

class Rock extends Decoration {
    constructor(x, y, size = "medium") {
        super(x, y, "rock", "desert");
        this.reset(x, y, size);
    }
    reset(x, y, size = "medium") {
        this.resetBase(x, y, "rock", "desert");
        this.size = size;
        this.width = size === "small" ? 20 : size === "medium" ? 35 : 50;
        this.height = size === "small" ? 15 : size === "medium" ? 25 : 35;
        this.shape = Math.floor(Math.random() * 3);
    }
}

class BoneDecor extends Decoration {
    constructor(x, y) {
        super(x, y, "bones", "desert");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "bones", "desert");
        this.width = 30;
        this.height = 12;
    }
}

class CactusDecor extends Decoration {
    constructor(x, y, height) {
        super(x, y, "cactus", "desert");
        this.reset(x, y, height);
    }
    reset(x, y, height) {
        this.resetBase(x, y, "cactus", "desert");
        this.width = 20;
        this.height = height || (40 + Math.random() * 60);
        this.harmful = true;
        this.damage = 5;
    }
    onCollision(entity) {
        if (this.harmful && rectIntersect(entity.x, entity.y, entity.width, entity.height, this.x, this.y, this.width, this.height)) {
            damagePlayer(this.damage, this.x, 40);
            showFloatingText("ğŸŒµ -5", entity.x, entity.y - 20);
        }
    }
}

class Ore extends Decoration {
    constructor(x, y, oreType) {
        super(x, y, `ore_${oreType}`, "mountain");
        this.reset(x, y, oreType);
    }
    reset(x, y, oreType) {
        this.resetBase(x, y, `ore_${oreType}`, "mountain");
        this.oreType = oreType;
        this.width = 30;
        this.height = 30;
        this.collectible = true;
        this.hp = { coal: 3, iron: 5, gold: 7, diamond: 10 }[oreType];
        this.color = { coal: "#424242", iron: "#B0BEC5", gold: "#FFD700", diamond: "#00BCD4" }[oreType];
    }
    interact() {
        if (inventory.iron_pickaxe <= 0) {
            showToast("âŒ éœ€è¦é“é•");
            return;
        }
        this.hp--;
        showFloatingText(`â›ï¸ ${this.hp}`, this.x, this.y - 20);
        if (this.hp <= 0) {
            inventory[this.oreType] = (inventory[this.oreType] || 0) + 1;
            this.remove = true;
            showFloatingText(`âœ¨ +1 ${this.oreType}`, this.x, this.y);
            updateInventoryUI();
        }
    }
}

class Stalactite extends Decoration {
    constructor(x, y, direction = "down") {
        super(x, y, "stalactite", "mountain");
        this.reset(x, y, direction);
    }
    reset(x, y, direction = "down") {
        this.resetBase(x, y, "stalactite", "mountain");
        this.direction = direction;
        this.width = 20;
        this.height = 30 + Math.random() * 40;
    }
}

class Crystal extends Decoration {
    constructor(x, y) {
        super(x, y, "crystal", "mountain");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "crystal", "mountain");
        this.width = 18;
        this.height = 28;
        this.animated = true;
    }
}

class LavaPool extends Decoration {
    constructor(x, y, width, biome = "mountain") {
        super(x, y, "lava_pool", biome);
        this.reset(x, y, width, biome);
    }
    reset(x, y, width, biome = "mountain") {
        this.resetBase(x, y, "lava_pool", biome);
        this.width = width || (60 + Math.random() * 80);
        this.height = 16;
        this.harmful = true;
        this.damage = 2;
        this.animated = true;
    }
    onCollision() {
        damagePlayer(this.damage, this.x, 30);
    }
}

class Shell extends Decoration {
    constructor(x, y) {
        super(x, y, "shell", "ocean");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "shell", "ocean");
        this.width = 16;
        this.height = 10;
        this.collectible = true;
    }
    interact() {
        inventory.shell = (inventory.shell || 0) + 1;
        this.remove = true;
        showFloatingText("ğŸš +1", this.x, this.y);
        updateInventoryUI();
    }
}

class Starfish extends Decoration {
    constructor(x, y) {
        super(x, y, "starfish", "ocean");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "starfish", "ocean");
        this.width = 18;
        this.height = 18;
        this.collectible = true;
    }
    interact() {
        inventory.starfish = (inventory.starfish || 0) + 1;
        this.remove = true;
        showFloatingText("â­ +1", this.x, this.y);
        updateInventoryUI();
    }
}

class Seaweed extends Decoration {
    constructor(x, y) {
        super(x, y, "seaweed", "ocean");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "seaweed", "ocean");
        this.width = 10;
        this.height = 30 + Math.random() * 20;
        this.animated = true;
        this.swayOffset = Math.random() * Math.PI * 2;
    }
}

class BoatDecor extends Decoration {
    constructor(x, y) {
        super(x, y, "boat", "ocean");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "boat", "ocean");
        this.width = 40;
        this.height = 16;
    }
}

class FireDecor extends Decoration {
    constructor(x, y) {
        super(x, y, "fire", "nether");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "fire", "nether");
        this.width = 12;
        this.height = 24;
        this.harmful = true;
        this.damage = 2;
        this.animated = true;
    }
    onCollision() {
        damagePlayer(this.damage, this.x, 20);
    }
}

class LavaFall extends Decoration {
    constructor(x, y) {
        super(x, y, "lava_fall", "nether");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "lava_fall", "nether");
        this.width = 12;
        this.height = 60 + Math.random() * 60;
        this.harmful = true;
        this.damage = 3;
        this.animated = true;
    }
    onCollision() {
        damagePlayer(this.damage, this.x, 20);
    }
}

class SoulSand extends Decoration {
    constructor(x, y, width) {
        super(x, y, "soul_sand", "nether");
        this.reset(x, y, width);
    }
    reset(x, y, width) {
        this.resetBase(x, y, "soul_sand", "nether");
        this.width = width || 50;
        this.height = 10;
        this.interactive = true;
    }
    onCollision(entity) {
        if (entity === player && entity.grounded) {
            entity.velX *= 0.8;
        }
    }
}

class NetherWart extends Decoration {
    constructor(x, y) {
        super(x, y, "nether_wart", "nether");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "nether_wart", "nether");
        this.width = 12;
        this.height = 10;
    }
}

class Basalt extends Decoration {
    constructor(x, y) {
        super(x, y, "basalt", "nether");
        this.reset(x, y);
    }
    reset(x, y) {
        this.resetBase(x, y, "basalt", "nether");
        this.width = 25;
        this.height = 40;
    }
}

</script>
<script>
/**
 * 15-entities-particles.js - ç²’å­æ•ˆæœç±»
 * ä» 15-entities.js æ‹†åˆ† (åŸå§‹è¡Œ 606-826)
 */

class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.velX = 0;
        this.velY = 0;
        this.life = 100;
        this.remove = false;
    }

    reset(x, y) {
        this.x = x;
        this.y = y;
        this.remove = false;
    }

    update() {
        this.x += this.velX;
        this.y += this.velY;
        this.life--;
        if (this.life <= 0) this.remove = true;
    }
}

class Snowflake extends Particle {
    constructor(x, y) {
        super(x, y, "snowflake");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = (Math.random() - 0.5) * 0.5;
        this.velY = 0.5 + Math.random() * 1;
        this.size = 2 + Math.random() * 3;
        this.life = 200;
    }
    update() {
        super.update();
        this.velX += Math.sin(this.life * 0.05) * 0.02;
    }
}

class LeafParticle extends Particle {
    constructor(x, y) {
        super(x, y, "leaf");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = (Math.random() - 0.5) * 0.6;
        this.velY = 0.4 + Math.random() * 0.6;
        this.size = 3 + Math.random() * 3;
        this.life = 180;
        this.color = ["#7CB342", "#558B2F", "#9CCC65"][Math.floor(Math.random() * 3)];
    }
}

class DustParticle extends Particle {
    constructor(x, y) {
        super(x, y, "dust");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = -0.5 + Math.random() * 1;
        this.velY = 0.2 + Math.random() * 0.4;
        this.size = 2 + Math.random() * 2;
        this.life = 140;
    }
}

class EmberParticle extends Particle {
    constructor(x, y) {
        super(x, y, "ember");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = (Math.random() - 0.5) * 0.3;
        this.velY = -0.6 - Math.random() * 0.6;
        this.size = 2 + Math.random() * 2;
        this.life = 120;
    }
}

class BubbleParticle extends Particle {
    constructor(x, y) {
        super(x, y, "bubble");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = (Math.random() - 0.5) * 0.2;
        this.velY = -0.4 - Math.random() * 0.4;
        this.size = 2 + Math.random() * 2;
        this.life = 120;
    }
}

class SparkleParticle extends Particle {
    constructor(x, y) {
        super(x, y, "sparkle");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = (Math.random() - 0.5) * 0.2;
        this.velY = -0.2 + Math.random() * 0.4;
        this.size = 2 + Math.random() * 3;
        this.life = 100;
    }
}

class RainParticle extends Particle {
    constructor(x, y) {
        super(x, y, "rain");
        this.reset(x, y);
    }
    reset(x, y) {
        super.reset(x, y);
        this.velX = -0.3 + Math.random() * 0.6;
        this.velY = 3 + Math.random() * 2;
        this.size = 6;
        this.life = 80;
    }
}

class ParticlePool {
    constructor(ParticleClass, size = 50) {
        this._pool = [];
        this._Class = ParticleClass;
        for (let i = 0; i < size; i++) {
            this._pool.push(new ParticleClass(0, 0));
        }
    }
    acquire(x, y) {
        const p = this._pool.length > 0 ? this._pool.pop() : new this._Class(x, y);
        if (typeof p.reset === "function") p.reset(x, y);
        else {
            p.x = x;
            p.y = y;
            p.remove = false;
            p.life = 1;
        }
        return p;
    }
    release(p) {
        if (!p) return;
        if (this._pool.length < 100) this._pool.push(p);
    }
}

const snowflakePool = new ParticlePool(Snowflake, 40);
const leafPool = new ParticlePool(LeafParticle, 30);
const dustPool = new ParticlePool(DustParticle, 30);

const ENEMY_STATS = {
    zombie: {
        hp: 20,
        speed: 0.55,
        damage: 10,
        attackType: "melee",
        color: "#00AA00",
        drops: ["rotten_flesh"],
        scoreValue: 10,
        size: { w: 32, h: 48 }
    },
    spider: {
        hp: 16,
        speed: 1.2,
        damage: 8,
        attackType: "melee",
        color: "#4A0E0E",
        drops: ["string"],
        scoreValue: 12,
        size: { w: 44, h: 24 }
    },
    creeper: {
        hp: 20,
        speed: 0.4,
        damage: 40,
        attackType: "explode",
        color: "#00AA00",
        drops: ["gunpowder"],
        scoreValue: 18,
        size: { w: 32, h: 48 }
    },
    skeleton: {
        hp: 15,
        speed: 0.5,
        damage: 12,
        attackType: "ranged",
        color: "#C0C0C0",
        drops: ["arrow"],
        scoreValue: 20,
        size: { w: 32, h: 48 }
    },
    drowned: {
        hp: 18,
        speed: 0.6,
        damage: 9,
        attackType: "melee",
        color: "#1E88E5",
        drops: ["rotten_flesh", "shell"],
        scoreValue: 14,
        size: { w: 32, h: 48 }
    },
    pufferfish: {
        hp: 14,
        speed: 0.9,
        damage: 7,
        attackType: "melee",
        color: "#FFB300",
        drops: ["shell", "starfish"],
        scoreValue: 12,
        size: { w: 30, h: 30 }
    },
    enderman: {
        hp: 40,
        speed: 1.4,
        damage: 25,
        attackType: "teleport",
        color: "#1A0033",
        drops: ["ender_pearl"],
        scoreValue: 35,
        size: { w: 32, h: 64 }
    },
    piglin: {
        hp: 60,
        speed: 1.1,
        damage: 20,
        attackType: "melee",
        color: "#C68642",
        drops: ["diamond"],
        scoreValue: 28,
        size: { w: 32, h: 52 }
    },
    ender_dragon: {
        hp: 200,
        speed: 1.5,
        damage: 30,
        attackType: "boss",
        color: "#000000",
        drops: ["dragon_egg"],
        scoreValue: 200,
        size: { w: 120, h: 60 }
    }
};

</script>
<script>
/**
 * 15-entities-combat.js - æˆ˜æ–—å®ä½“ç±» (æŠ•å°„ç‰©ã€æ•Œäººã€å‚€å„¡)
 * ä» 15-entities.js æ‹†åˆ† (åŸå§‹è¡Œ 827-1319)
 */

class Projectile extends Entity {
    constructor(x, y, targetX, targetY, speed = 3, faction = "enemy") {
        super(x, y, 8 * worldScale.unit, 8 * worldScale.unit);
        const angle = Math.atan2(targetY - y, targetX - x);
        const scaledSpeed = speed * worldScale.unit;
        this.velX = Math.cos(angle) * scaledSpeed;
        this.velY = Math.sin(angle) * scaledSpeed;
        this.lifetime = 180;
        this.damage = 12;
        this.faction = faction;
    }

    reset(x, y, targetX, targetY, speed) {
        this.x = x;
        this.y = y;
        const angle = Math.atan2(targetY - y, targetX - x);
        const scaledSpeed = speed * worldScale.unit;
        this.velX = Math.cos(angle) * scaledSpeed;
        this.velY = Math.sin(angle) * scaledSpeed;
        this.lifetime = 180;
        this.remove = false;
    }

    update(playerRef, golemList, enemyList) {
        this.x += this.velX;
        this.y += this.velY;
        this.lifetime--;

        if (this.faction === "enemy") {
            if (rectIntersect(this.x, this.y, this.width, this.height, playerRef.x, playerRef.y, playerRef.width, playerRef.height)) {
                damagePlayer(this.damage, this.x);
                this.remove = true;
                return;
            }
            for (const g of golemList) {
                if (rectIntersect(this.x, this.y, this.width, this.height, g.x, g.y, g.width, g.height)) {
                    g.takeDamage(this.damage);
                    this.remove = true;
                    return;
                }
            }
        } else if (this.faction === "golem") {
            for (const e of enemyList) {
                if (!e.remove && rectIntersect(this.x, this.y, this.width, this.height, e.x, e.y, e.width, e.height)) {
                    e.takeDamage(this.damage);
                    showFloatingText(`âš”ï¸ ${this.damage}`, e.x, e.y - 10);
                    this.remove = true;
                    return;
                }
            }
        } else if (this.faction === "player") {
            for (const e of enemyList) {
                if (!e.remove && rectIntersect(this.x, this.y, this.width, this.height, e.x, e.y, e.width, e.height)) {
                    e.takeDamage(this.damage);
                    showFloatingText(`-${this.damage}`, e.x, e.y - 10);
                    this.remove = true;
                    return;
                }
            }
        }

        if (this.lifetime <= 0) this.remove = true;
    }
}

class Arrow extends Projectile {
    constructor(x, y, targetX, targetY, faction = "enemy", speed = 4, damage = 12) {
        super(x, y, targetX, targetY, speed, faction);
        this.damage = damage;
        this.width = 12;
        this.height = 4;
    }
}

class Snowball extends Projectile {
    constructor(x, y, targetX, targetY) {
        super(x, y, targetX, targetY, 3, "golem");
        this.damage = 8;
    }
}

class DragonFireball extends Projectile {
    constructor(x, y, targetX, targetY) {
        super(x, y, targetX, targetY, 2, "enemy");
        this.damage = 30;
        this.width = 16;
        this.height = 16;
    }
}

class Enemy extends Entity {
    constructor(x, y, type = "zombie", range = 120) {
        const stats = ENEMY_STATS[type] || ENEMY_STATS.zombie;
        const size = stats.size || { w: 32, h: 32 };
        const diff = getDifficultyState();
        super(x, y, size.w, size.h);
        this.type = type;
        this.startX = x;
        this.startY = y;
        this.range = range;
        this.hp = Math.max(1, Math.round(stats.hp * diff.enemyHpMult));
        this.maxHp = this.hp;
        this.speed = stats.speed;
        this.damage = Math.max(1, Math.round(stats.damage * diff.enemyDamageMult));
        this.attackType = stats.attackType;
        this.color = stats.color;
        this.drops = stats.drops || [];
        this.scoreValue = Math.max(1, Math.round((stats.scoreValue || gameConfig.scoring.enemy) * diff.scoreMultiplier));
        this.dir = 1;
        this.state = "patrol";
        this.attackCooldown = 0;
        this.explodeTimer = 0;
        this.teleportCooldown = 0;
        this.phaseChanged = false;
        this.velY = 0;
        this.grounded = false;
    }

    takeDamage(amount) {
        this.hp -= amount;
        playHitSfx(Math.min(1, Math.max(0.2, amount / 20)));
        if (this.hp <= 0) this.die();
    }

    die() {
        this.remove = true;
        this.y = 1000;
        if (Math.random() < 0.6 && this.drops.length) {
            const drop = this.drops[Math.floor(Math.random() * this.drops.length)];
            dropItem(drop, this.x, this.y);
        }
        addScore(this.scoreValue);
        recordEnemyKill(this.type);
    }

    update(playerRef) {
        if (this.remove || this.y > 900) return;
        switch (this.type) {
            case "zombie":
                this.updateZombie(playerRef);
                break;
            case "spider":
                this.updateSpider(playerRef);
                break;
            case "creeper":
                this.updateCreeper(playerRef);
                break;
            case "skeleton":
                this.updateSkeleton(playerRef);
                break;
            case "enderman":
                this.updateEnderman(playerRef);
                break;
            case "ender_dragon":
                this.updateEnderDragon(playerRef);
                break;
            default:
                this.updateBasic();
        }

        this.applyGravity();
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.teleportCooldown > 0) this.teleportCooldown--;
    }

    applyGravity() {
        if (this.type === "ender_dragon") return;
        this.velY += gameConfig.physics.gravity;
        this.y += this.velY;
        this.grounded = false;

        for (const p of platforms) {
            const dir = colCheck(this, p);
            if (dir === "b") {
                this.grounded = true;
                this.y = p.y - this.height;
                this.velY = 0;
            } else if (dir === "t") {
                this.velY = 0;
            }
        }

        if (this.y > fallResetY) {
            this.remove = true;
        }
    }

    updateBasic() {
        this.x += this.speed * this.dir;
        if (this.x > this.startX + this.range || this.x < this.startX) this.dir *= -1;
    }

    updateZombie(playerRef) {
        const dist = Math.abs(this.x - playerRef.x);
        if (dist < 200) {
            this.state = "chase";
            this.x += (playerRef.x > this.x ? 1 : -1) * this.speed;
        } else {
            this.state = "patrol";
            this.updateBasic();
        }
    }

    updateSpider(playerRef) {
        const dist = Math.abs(this.x - playerRef.x);
        if (dist < 240) {
            this.state = "chase";
            this.x += (playerRef.x > this.x ? 1 : -1) * this.speed;
        } else {
            this.state = "patrol";
            this.updateBasic();
        }
    }

    updateCreeper(playerRef) {
        const dist = Math.abs(this.x - playerRef.x);
        if (dist < 60) {
            this.state = "exploding";
            if (this.explodeTimer === 0) this.explodeTimer = 90;
            this.explodeTimer--;
            if (this.explodeTimer <= 0) {
                if (Math.abs(this.x - playerRef.x) < 120 && Math.abs(this.y - playerRef.y) < 120) {
                    damagePlayer(this.damage, this.x);
                    showFloatingText("ğŸ’¥ çˆ†ç‚¸!", this.x, this.y);
                }
                this.die();
            }
        } else if (dist < 200) {
            this.state = "chase";
            this.x += (playerRef.x > this.x ? 1 : -1) * this.speed;
            this.explodeTimer = 0;
        } else {
            this.state = "patrol";
            this.explodeTimer = 0;
            this.updateBasic();
        }
    }

    updateSkeleton(playerRef) {
        const dist = Math.abs(this.x - playerRef.x);
        if (dist < 80) {
            this.x += (playerRef.x > this.x ? -1 : 1) * this.speed;
        } else if (dist > 150 && dist < 300) {
            this.x += (playerRef.x > this.x ? 1 : -1) * this.speed;
        }

        if (this.attackCooldown === 0 && dist < 260) {
            const arrow = projectilePool.getArrow(this.x, this.y, playerRef.x, playerRef.y);
            if (!projectiles.includes(arrow)) projectiles.push(arrow);
            this.attackCooldown = 120;
        }
    }

    updateEnderman(playerRef) {
        const dist = Math.abs(this.x - playerRef.x);
        if (dist > 300 && this.teleportCooldown === 0 && Math.random() < 0.02) {
            this.x = playerRef.x + (Math.random() > 0.5 ? 120 : -120);
            this.y = playerRef.y;
            this.teleportCooldown = 180;
            showFloatingText("âš¡", this.x, this.y);
        } else if (dist < 150) {
            this.x += (playerRef.x > this.x ? 1 : -1) * this.speed;
        } else {
            this.updateBasic();
        }
    }

    updateEnderDragon(playerRef) {
        const phase = this.hp > this.maxHp * 0.5 ? 1 : 2;
        if (phase === 2 && !this.phaseChanged) {
            this.phaseChanged = true;
            this.speed *= 1.5;
            showToast("âš ï¸ æœ«å½±é¾™è¿›å…¥ç‹‚æš´çŠ¶æ€ï¼");
        }

        this.x += this.speed * this.dir;
        this.y = 100 + Math.sin(gameFrame * 0.02) * 50;
        if (this.x > this.startX + 400 || this.x < this.startX - 200) this.dir *= -1;

        if (this.attackCooldown === 0 && Math.random() < 0.02) {
            const fireball = projectilePool.getFireball(this.x + 40, this.y + 20, playerRef.x, playerRef.y);
            if (!projectiles.includes(fireball)) projectiles.push(fireball);
            this.attackCooldown = phase === 1 ? 120 : 60;
        }

        if (phase === 2 && Math.random() < 0.005) {
            this.state = "diving";
            this.targetDiveY = 400;
        }

        if (this.state === "diving") {
            this.y += 5;
            if (this.y >= this.targetDiveY) {
                this.state = "patrol";
                if (Math.abs(this.x - playerRef.x) < 150) {
                    damagePlayer(this.damage, this.x, 150);
                    showFloatingText("ğŸ’¥ é¾™æ¯å†²å‡»!", playerRef.x, playerRef.y);
                }
            }
        }
    }
}

class Golem extends Entity {
    constructor(x, y, type = "iron") {
        const sizeScale = worldScale.unit;
        super(x, y, type === "iron" ? 40 * sizeScale : 32 * sizeScale, type === "iron" ? 48 * sizeScale : 40 * sizeScale);
        const config = getGolemConfig();
        const stats = type === "iron" ? config.ironGolem : config.snowGolem;
        this.type = type;
        this.hp = stats.hp;
        this.maxHp = stats.hp;
        this.damage = stats.damage;
        this.speed = stats.speed;
        this.followDelay = 30;
        this.attackCooldown = 0;
        this.attackRange = (type === "iron" ? 80 : 120) * sizeScale;
        this.velX = 0;
        this.velY = 0;
        this.grounded = false;
        this.facingRight = true;
        this.stuckCounter = 0;
        this.lastX = x;
    }

    updateFollow(playerHistory, platformsRef, playerRef) {
        if (playerHistory.length < this.followDelay) return;
        const target = playerHistory[playerHistory.length - this.followDelay];
        const dx = target.x - this.x;
        if (Math.abs(dx) > 30 * worldScale.unit) {
            this.velX = Math.sign(dx) * this.speed;
            this.facingRight = dx > 0;
        } else {
            this.velX *= 0.8;
        }
        if (this.grounded && this.shouldJump(playerRef, platformsRef)) {
            this.velY = -10 * worldScale.unit;
        }
    }

    shouldJump(playerRef, platformsRef) {
        if (this.detectObstacle(platformsRef)) return true;
        if (this.detectGap(platformsRef)) return true;
        return this.shouldMirrorPlayerJump(playerRef);
    }

    detectObstacle(platformsRef) {
        if (!platformsRef || !platformsRef.length) return false;
        const unit = worldScale?.unit || 1;
        const offset = 5 * unit;
        const checkX = this.facingRight ? this.x + this.width + offset : this.x - offset;
        const checkY = this.y + this.height;
        return platformsRef.some(p => {
            const withinY = p.y < checkY && p.y > this.y - 40 * unit;
            return withinY && checkX >= p.x && checkX <= p.x + p.width;
        });
    }

    detectGap(platformsRef) {
        if (!platformsRef || !platformsRef.length) return false;
        if (this.hasGroundAhead(platformsRef)) return false;
        return this.findLandingPlatform(platformsRef);
    }

    hasGroundAhead(platformsRef) {
        if (!platformsRef || !platformsRef.length) return false;
        const unit = worldScale?.unit || 1;
        const lookX = this.facingRight ? this.x + this.width + 10 * unit : this.x - 10 * unit;
        const feetY = this.y + this.height;
        return platformsRef.some(p => {
            const withinY = p.y >= feetY - 4 * unit && p.y <= feetY + 12 * unit;
            return withinY && lookX >= p.x && lookX <= p.x + p.width;
        });
    }

    findLandingPlatform(platformsRef) {
        if (!platformsRef || !platformsRef.length) return false;
        const unit = worldScale?.unit || 1;
        const offset = 20 * unit;
        const lookRange = 160 * unit;
        const start = this.facingRight ? this.x + this.width + offset : this.x - offset;
        const end = this.facingRight ? start + lookRange : start - lookRange;
        const minX = Math.min(start, end);
        const maxX = Math.max(start, end);
        for (const p of platformsRef) {
            if (p.x + p.width < minX || p.x > maxX) continue;
            if (p.y < this.y - 120 * unit || p.y > this.y + 60 * unit) continue;
            return true;
        }
        return false;
    }

    shouldMirrorPlayerJump(playerRef) {
        if (!playerRef) return false;
        const unit = worldScale?.unit || 1;
        const horizontalGap = Math.abs(playerRef.x - this.x);
        return horizontalGap < 150 * unit && playerRef.velY < -2 && !playerRef.grounded;
    }

    checkFallRecovery(playerRef) {
        if (!playerRef) return false;
        const unit = worldScale?.unit || 1;
        const verticalGap = this.y - playerRef.y;
        const threshold = 280 * unit;
        if (this.y > fallResetY + 80 || verticalGap > threshold) {
            const offset = (Math.random() > 0.5 ? -1 : 1) * 80 * unit;
            this.x = playerRef.x + offset;
            this.y = playerRef.y - 10 * unit;
            this.velX = 0;
            this.velY = 0;
            this.grounded = false;
            this.stuckCounter = 0;
            this.lastX = this.x;
            return true;
        }
        return false;
    }

    updateAttack(enemyList) {
        if (this.attackCooldown > 0) {
            this.attackCooldown--;
            return;
        }
        let nearest = null;
        let minDist = this.attackRange;
        for (const e of enemyList) {
            if (e.remove || e.y > canvas.height + blockSize * 4) continue;
            const dist = Math.abs(this.x - e.x);
            const vertDist = Math.abs(this.y - e.y);
            if (dist < minDist && vertDist < blockSize * 2) {
                nearest = e;
                minDist = dist;
            }
        }
        if (nearest) {
            if (this.type === "snow") {
                const snowball = projectilePool.getSnowball(this.x + this.width / 2, this.y + this.height / 2, nearest.x, nearest.y);
                if (!projectiles.includes(snowball)) projectiles.push(snowball);
            } else {
                nearest.takeDamage(this.damage);
            }
            this.attackCooldown = 60;
            showFloatingText(`âš”ï¸ ${this.damage}`, nearest.x, nearest.y - 20);
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.remove = true;
            if (Math.random() < 0.5) {
                const dropType = this.type === "iron" ? "iron" : "pumpkin";
                dropItem(dropType, this.x, this.y);
            }
        }
    }

    update(playerRef, playerHistory, enemyList, platformsRef) {
        this.updateFollow(playerHistory, platformsRef, playerRef);
        this.velY += gameConfig.physics.gravity;
        this.grounded = false;

        for (const p of platformsRef) {
            const dir = colCheck(this, p);
            if (dir === "l" || dir === "r") this.velX = 0;
            else if (dir === "b") {
                this.grounded = true;
                this.y = p.y - this.height;
                this.velY = 0;
            } else if (dir === "t") {
                this.velY = 0;
            }
        }

        this.updateAttack(enemyList);

        this.x += this.velX;
        this.y += this.velY;

        const recovered = this.checkFallRecovery(playerRef);
        if (!recovered && this.y > fallResetY) this.remove = true;

        if (Math.abs(this.x - this.lastX) < 0.2) this.stuckCounter++;
        else this.stuckCounter = 0;
        this.lastX = this.x;

        if (this.stuckCounter > 180 && playerRef) {
            this.x = playerRef.x + (Math.random() > 0.5 ? 50 : -50);
            this.y = playerRef.y;
            this.stuckCounter = 0;
        }
    }
}


</script>
<script>
// ============ BOSS æˆ˜æ–—ç³»ç»Ÿ ============

// BOSS åŸºç±»
class Boss {
    constructor(config) {
        this.name = config.name;
        this.maxHp = config.maxHp;
        this.hp = config.maxHp;
        this.x = config.x || 0;
        this.y = config.y || 100;
        this.width = config.width || 96;
        this.height = config.height || 96;
        this.color = config.color || '#333';
        this.phase = 1;
        this.phaseThresholds = config.phaseThresholds || [0.6, 0.2];
        this.alive = true;
        this.remove = false;
        this.bossProjectiles = [];
        this.attackTimer = 0;
        this.stunTimer = 0;
        this.flashTimer = 0;
        this.particles = [];
        this.damage = config.damage || 1;
        this.type = 'boss';
    }

    update(playerRef) {
        if (!this.alive) return;
        this.updatePhase();
        this.updateProjectiles();
        this.updateParticles();
        if (this.flashTimer > 0) this.flashTimer--;
        if (this.stunTimer > 0) { this.stunTimer--; return; }
        this.updateBehavior(playerRef);
    }

    updatePhase() {
        const pct = this.hp / this.maxHp;
        if (this.phase === 1 && pct <= this.phaseThresholds[0]) {
            this.phase = 2;
            this.onPhaseChange(2);
        } else if (this.phase === 2 && pct <= this.phaseThresholds[1]) {
            this.phase = 3;
            this.onPhaseChange(3);
        }
    }
// PLACEHOLDER_BOSS_METHODS

    updateProjectiles() {
        for (let i = this.bossProjectiles.length - 1; i >= 0; i--) {
            const p = this.bossProjectiles[i];
            // è¿½è¸ªé€»è¾‘ï¼ˆåå¼¹åä¸å†è¿½è¸ªç©å®¶ï¼‰
            if (p.tracking && !p.reflected && p.trackDelay !== undefined) {
                if (p.trackDelay > 0) { p.trackDelay--; }
                else {
                    const dx = player.x + player.width / 2 - p.x;
                    const dy = player.y + player.height / 2 - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        p.vx += (dx / dist) * 0.15;
                        p.vy += (dy / dist) * 0.15;
                        const spd = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        if (spd > 4) { p.vx = (p.vx / spd) * 4; p.vy = (p.vy / spd) * 4; }
                    }
                }
            }
            p.x += p.vx;
            p.y += p.vy;
            p.life = (p.life || 300) - 1;
            // åå¼¹å¼¹å¹•ç¢°æ’BOSS
            if (p.reflected) {
                if (Math.abs(p.x - this.x - this.width / 2) < p.size + this.width / 2 &&
                    Math.abs(p.y - this.y - this.height / 2) < p.size + this.height / 2) {
                    this.takeDamage(p.damage);
                    this.bossProjectiles.splice(i, 1);
                    continue;
                }
            } else {
                // ç¢°æ’ç©å®¶
                if (Math.abs(p.x - player.x - player.width / 2) < p.size + player.width / 2 &&
                    Math.abs(p.y - player.y - player.height / 2) < p.size + player.height / 2) {
                    damagePlayer(p.damage, p.x);
                    this.bossProjectiles.splice(i, 1);
                    continue;
                }
            }
            // è¶…å‡ºèŒƒå›´æˆ–ç”Ÿå‘½ç»“æŸ
            if (p.life <= 0 || p.x < cameraX - 200 || p.x > cameraX + canvas.width + 200 ||
                p.y < -200 || p.y > 1000) {
                this.bossProjectiles.splice(i, 1);
            }
        }
    }

    updateParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx || 0;
            p.y += p.vy || 0;
            p.life -= 0.02;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }

    takeDamage(amount) {
        if (this.stunTimer > 0) amount = Math.ceil(amount * 1.5);
        this.hp -= amount;
        this.flashTimer = 10;
        showFloatingText(`-${amount}`, this.x + this.width / 2, this.y - 10, '#FF4444');
        if (this.hp <= 0) {
            this.hp = 0;
            this.die();
        }
    }

    die() {
        this.alive = false;
        this.remove = true;
        bossArena.onVictory();
    }

    updateBehavior(playerRef) {}
    onPhaseChange(newPhase) {}
    render(ctx) {}
}

// BOSS æˆ˜åœºç®¡ç†å™¨
const bossArena = {
    active: false,
    boss: null,
    victoryTimer: 0,
    bossTypes: ['wither', 'ghast', 'blaze', 'wither_skeleton'],
    bossScores: [2000, 4000, 6000, 8000],         // è§¦å‘åˆ†æ•°é˜ˆå€¼
    spawned: {},           // å·²ç”Ÿæˆçš„BOSSè®°å½•

// PLACEHOLDER_ARENA_METHODS

    checkSpawn() {
        if (this.active) return;
        const score = getProgressScore();
        for (let i = 0; i < this.bossTypes.length; i++) {
            const type = this.bossTypes[i];
            if (!this.spawned[type] && score >= this.bossScores[i]) {
                this.enter(type);
                return;
            }
        }
    },

    enter(bossType) {
        this.active = true;
        this.victoryTimer = 0;
        this.spawned[bossType] = true;
        this.boss = this.createBoss(bossType);
        showToast(`âš ï¸ BOSSæˆ˜: ${this.boss.name}!`);
    },

    createBoss(type) {
        const spawnX = player.x + 300;
        switch (type) {
            case 'wither': return new WitherBoss(spawnX);
            case 'ghast': return new GhastBoss(spawnX);
            case 'blaze': return new BlazeBoss(spawnX);
            case 'wither_skeleton': return new WitherSkeletonBoss(spawnX);
            default: return new WitherBoss(spawnX);
        }
    },

    exit() {
        this.active = false;
        this.boss = null;
    },

    onVictory() {
        if (this.victoryTimer > 0) return;
        this.victoryTimer = 1;
        // å¥–åŠ±
        score += 500;
        inventory.iron = (inventory.iron || 0) + 5;
        addArmorToInventory('diamond');
        showFloatingText('ğŸ† BOSS DEFEATED!', player.x, player.y - 60, '#FFD700');
        showToast('ğŸ† å‡»è´¥BOSS! è·å¾—ä¸°åšå¥–åŠ±!');
    },

    update() {
        if (!this.active || !this.boss) return;
        if (!this.boss.alive) {
            this.victoryTimer++;
            if (this.victoryTimer > 180) this.exit();
            return;
        }
        this.boss.update(player);
    },

    renderBossHpBar(ctx) {
        if (!this.active || !this.boss) return;
        const barW = Math.min(360, canvas.width * 0.6);
        const barH = 14;
        const bx = (canvas.width - barW) / 2;
        const by = 20;
        const pct = Math.max(0, this.boss.hp / this.boss.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(bx - 4, by - 4, barW + 8, barH + 8);
        ctx.fillStyle = '#111';
        ctx.fillRect(bx, by, barW, barH);
        const hpColor = pct > 0.5 ? '#4CAF50' : pct > 0.2 ? '#FF9800' : '#F44336';
        ctx.fillStyle = hpColor;
        ctx.fillRect(bx, by, barW * pct, barH);
        ctx.strokeStyle = '#FFF';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, by, barW, barH);
        ctx.fillStyle = '#FFF';
        ctx.font = 'bold 14px Verdana';
        ctx.textAlign = 'center';
        ctx.fillText(`${this.boss.name} (é˜¶æ®µ${this.boss.phase})`, canvas.width / 2, by - 6);
        ctx.textAlign = 'left';
    },

    renderProjectiles(ctx, camX) {
        if (!this.active || !this.boss) return;
        this.boss.bossProjectiles.forEach(p => {
            ctx.fillStyle = p.color || '#1A1A1A';
            ctx.beginPath();
            ctx.arc(p.x - camX, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            // åå¼¹ç«çƒæ‹–å°¾
            if (p.reflected) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#00BFFF';
                ctx.beginPath();
                ctx.arc(p.x - camX - p.vx, p.y - p.vy, p.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        });
    },

    renderBoss(ctx, camX) {
        if (!this.active || !this.boss) return;
        this.boss.render(ctx, camX);
    }
};

// å‡‹é›¶ BOSS
class WitherBoss extends Boss {
    constructor(spawnX) {
        super({
            name: 'å‡‹é›¶ Wither',
            maxHp: 30,
            color: '#1A1A1A',
            x: spawnX,
            y: 80,
            width: 96,
            height: 96,
            phaseThresholds: [0.6, 0.2],
            damage: 1
        });
        this.floatOffset = 0;
        this.moveDir = 1;
        this.moveSpeed = 1.5;
        this.charging = false;
        this.chargeTarget = null;
        this.chargeTimer = 0;
        this.startX = spawnX;
    }

    updateBehavior(playerRef) {
        this.floatOffset = Math.sin(Date.now() / 500) * 10;
        // è·Ÿéšç©å®¶æ°´å¹³ä½ç½®
        const targetX = playerRef.x;
        if (Math.abs(this.x - targetX) > 150) {
            this.x += (targetX > this.x ? 1 : -1) * this.moveSpeed * (this.phase === 2 ? 1.5 : 1);
        }
        switch (this.phase) {
            case 1: this.phaseOne(playerRef); break;
            case 2: this.phaseTwo(playerRef); break;
            case 3: this.phaseThree(playerRef); break;
        }
    }

    // é˜¶æ®µä¸€ï¼šæ¯3ç§’1ä¸ªé»‘çƒ
    phaseOne(playerRef) {
        this.attackTimer++;
        if (this.attackTimer >= 180) {
            this.shootBlackBall(playerRef, 1);
            this.attackTimer = 0;
        }
    }

    // é˜¶æ®µäºŒï¼šæ¯2ç§’3ä¸ªæ‰‡å½¢é»‘çƒ + å†²åˆº
    phaseTwo(playerRef) {
        if (this.charging) { this.executeCharge(playerRef); return; }
        this.attackTimer++;
        if (this.attackTimer >= 120) {
            this.shootBlackBall(playerRef, 3);
            this.attackTimer = 0;
        }
        this.chargeTimer++;
        if (this.chargeTimer >= 480) {
            this.startCharge(playerRef);
            this.chargeTimer = 0;
        }
    }

    // é˜¶æ®µä¸‰ï¼šå›ºå®šä¸­å¤®ï¼Œæ¯1ç§’5ä¸ªè¿½è¸ªå¼¹
    phaseThree(playerRef) {
        const centerX = playerRef.x;
        this.x += (centerX - this.x) * 0.03;
        this.x += (Math.random() - 0.5) * 4;
        this.y = 80 + (Math.random() - 0.5) * 4;
        this.attackTimer++;
        if (this.attackTimer >= 60) {
            this.shootTrackingBalls(5);
            this.attackTimer = 0;
        }
    }
// PLACEHOLDER_WITHER_METHODS

    shootBlackBall(playerRef, count) {
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;
        const px = playerRef.x + playerRef.width / 2;
        const py = playerRef.y + playerRef.height / 2;
        const angle = Math.atan2(py - cy, px - cx);
        for (let i = 0; i < count; i++) {
            const spread = count > 1 ? (i - (count - 1) / 2) * 0.3 : 0;
            this.bossProjectiles.push({
                x: cx, y: cy,
                vx: Math.cos(angle + spread) * 4,
                vy: Math.sin(angle + spread) * 4,
                damage: this.phase >= 2 ? 2 : 1,
                size: 12, color: '#1A1A1A',
                tracking: false, life: 300
            });
        }
    }

    shootTrackingBalls(count) {
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 / count) * i;
            this.bossProjectiles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * 3,
                vy: Math.sin(angle) * 3,
                damage: 1, size: 10, color: '#4A0080',
                tracking: true, trackDelay: 60, life: 300
            });
        }
    }

    startCharge(playerRef) {
        this.charging = true;
        this.chargeTarget = { x: playerRef.x, y: playerRef.y };
        this.flashTimer = 30;
        showFloatingText('âš ï¸', this.x + this.width / 2, this.y - 20, '#FF0000');
    }

    executeCharge() {
        const dx = this.chargeTarget.x - this.x;
        const dy = this.chargeTarget.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 20) {
            this.charging = false;
            this.stunTimer = 30;
            this.y = 80;
            return;
        }
        this.x += (dx / dist) * 8;
        this.y += (dy / dist) * 8;
        // å†²åˆºç¢°æ’ç©å®¶
        if (Math.abs(this.x - player.x) < this.width &&
            Math.abs(this.y - player.y) < this.height) {
            damagePlayer(2, this.x, 120);
            this.charging = false;
            this.stunTimer = 30;
            this.y = 80;
        }
    }

    onPhaseChange(newPhase) {
        this.attackTimer = 0;
        this.chargeTimer = 0;
        if (newPhase === 2) {
            this.color = '#8B0000';
            showToast('âš ï¸ å‡‹é›¶è¿›å…¥æš´æ€’çŠ¶æ€!');
        } else if (newPhase === 3) {
            showToast('âš ï¸ å‡‹é›¶è¿›å…¥ç‹‚æš´çŠ¶æ€!');
        }
        // çˆ†å‘ç²’å­
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: this.x + Math.random() * this.width,
                y: this.y + Math.random() * this.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1
            });
        }
    }

    render(ctx, camX) {
        const drawX = this.x - camX;
        const drawY = this.y + this.floatOffset;
        // å—å‡»é—ªç™½
        ctx.fillStyle = this.flashTimer > 0 ? '#FFF' : this.color;
        // èº«ä½“
        ctx.fillRect(drawX, drawY, this.width, this.height);
        // ä¸‰ä¸ªå¤´
        const hs = 24;
        ctx.fillStyle = '#0D0D0D';
        ctx.fillRect(drawX + 8, drawY - hs, hs, hs);
        ctx.fillRect(drawX + this.width / 2 - hs / 2, drawY - hs - 8, hs, hs);
        ctx.fillRect(drawX + this.width - hs - 8, drawY - hs, hs, hs);
        // çœ¼ç›
        ctx.fillStyle = this.phase === 3 ? '#FF0000' : '#FFF';
        [drawX + 14, drawX + this.width / 2 - 4, drawX + this.width - 22].forEach(ex => {
            ctx.fillRect(ex, drawY - hs + 6, 4, 4);
            ctx.fillRect(ex + 8, drawY - hs + 6, 4, 4);
        });
        // é˜¶æ®µä¸‰è£‚ç—•
        if (this.phase === 3) {
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX + 20, drawY + 10);
            ctx.lineTo(drawX + 50, drawY + 50);
            ctx.lineTo(drawX + 30, drawY + 80);
            ctx.stroke();
        }
        // ç²’å­
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = '#8B008B';
            ctx.fillRect(p.x - camX, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    }
}

// æ¶é­‚ BOSS
class GhastBoss extends Boss {
    constructor(spawnX) {
        super({
            name: 'æ¶é­‚ Ghast',
            maxHp: 25,
            color: '#F0F0F0',
            x: spawnX,
            y: 80,
            width: 64,
            height: 64,
            phaseThresholds: [0.5, 0.2],
            damage: 2
        });
        this.hitCount = 0;
        this.crying = false;
        this.cryTimer = 0;
        this.moveAngle = 0;
        this.rushTimer = 0;
        this.rushing = false;
        this.rushTarget = null;
        this.startX = spawnX;
    }
// PLACEHOLDER_GHAST_PART1

    updateBehavior(playerRef) {
        // å“­æ³£çŠ¶æ€æ›´æ–°
        if (this.crying) {
            this.cryTimer--;
            if (this.cryTimer % 10 === 0) {
                this.particles.push({
                    x: this.x + this.width / 2 + (Math.random() - 0.5) * 20,
                    y: this.y + this.height / 2,
                    vx: 0, vy: 2, life: 1.0
                });
            }
            if (this.cryTimer <= 0) this.crying = false;
            return; // å“­æ³£æœŸé—´ä¸æ”»å‡»
        }

        // çªè¿›é€»è¾‘
        if (this.rushing) {
            this.executeRush(playerRef);
            return;
        }

        // 8å­—å½¢ç§»åŠ¨
        const speed = this.phase === 1 ? 0.02 : this.phase === 2 ? 0.03 : 0.04;
        this.moveAngle += speed;
        const rangeX = this.phase >= 3 ? 200 : 150;
        this.x = playerRef.x + Math.sin(this.moveAngle) * rangeX - this.width / 2;
        this.y = 80 + Math.sin(this.moveAngle * 2) * 60;

        // æ”»å‡»
        const interval = this.phase === 1 ? 150 : this.phase === 2 ? 90 : 60;
        this.attackTimer++;
        if (this.attackTimer >= interval) {
            const count = this.phase === 1 ? 1 : this.phase === 2 ? 2 : 3;
            this.shootFireball(playerRef, count);
            this.attackTimer = 0;
        }

        // çªè¿›è®¡æ—¶
        const rushInterval = this.phase >= 3 ? 360 : 600;
        this.rushTimer++;
        if (this.rushTimer >= rushInterval) {
            this.startRush(playerRef);
            this.rushTimer = 0;
        }
    }
// PLACEHOLDER_GHAST_PART2

    shootFireball(playerRef, count) {
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;
        const px = playerRef.x + playerRef.width / 2;
        const py = playerRef.y + playerRef.height / 2;
        const angle = Math.atan2(py - cy, px - cx);
        for (let i = 0; i < count; i++) {
            const spread = count > 1 ? (i - (count - 1) / 2) * 0.25 : 0;
            this.bossProjectiles.push({
                x: cx, y: cy,
                vx: Math.cos(angle + spread) * 3.5,
                vy: Math.sin(angle + spread) * 3.5,
                damage: 2, size: 16,
                color: '#FF4500',
                reflectable: true,
                reflected: false,
                tracking: false, life: 300
            });
        }
    }

    startRush(playerRef) {
        this.rushing = true;
        this.rushTarget = { x: playerRef.x, y: playerRef.y - 50 };
        this.flashTimer = 20;
        showFloatingText('âš ï¸', this.x + this.width / 2, this.y - 20, '#FF0000');
    }

    executeRush(playerRef) {
        const dx = this.rushTarget.x - this.x;
        const dy = this.rushTarget.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 20) {
            this.rushing = false;
            this.stunTimer = 20;
            return;
        }
        this.x += (dx / dist) * 6;
        this.y += (dy / dist) * 6;
        if (Math.abs(this.x - player.x) < this.width &&
            Math.abs(this.y - player.y) < this.height) {
            damagePlayer(2, this.x, 100);
            this.rushing = false;
            this.stunTimer = 20;
        }
    }

    takeDamage(amount) {
        super.takeDamage(amount);
        this.hitCount++;
        if (this.hitCount >= 10 && !this.crying) {
            this.crying = true;
            this.cryTimer = 300; // 5ç§’
            this.hitCount = 0;
            showToast('ğŸ˜¢ æ¶é­‚è¿›å…¥å“­æ³£çŠ¶æ€!');
        }
    }

    onPhaseChange(newPhase) {
        this.attackTimer = 0;
        this.rushTimer = 0;
        if (newPhase === 2) {
            showToast('âš ï¸ æ¶é­‚å˜å¾—æ›´åŠ ç‹‚æš´!');
        } else if (newPhase === 3) {
            showToast('âš ï¸ æ¶é­‚è¿›å…¥æ¿’æ­»çŠ¶æ€!');
        }
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: this.x + Math.random() * this.width,
                y: this.y + Math.random() * this.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                life: 1
            });
        }
    }
// PLACEHOLDER_GHAST_RENDER

    render(ctx, camX) {
        const drawX = this.x - camX;
        const drawY = this.y;
        // å“­æ³£æ—¶åŠé€æ˜
        ctx.globalAlpha = this.crying ? 0.5 : 0.9;
        // èº«ä½“
        ctx.fillStyle = this.flashTimer > 0 ? '#FFF' : '#F0F0F0';
        ctx.fillRect(drawX, drawY, this.width, this.height);
        // çº¢è‰²çœ¼ç›
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(drawX + 16, drawY + 20, 8, 12);
        ctx.fillRect(drawX + 40, drawY + 20, 8, 12);
        // å˜´å·´
        ctx.fillStyle = '#333';
        if (this.crying) {
            ctx.fillRect(drawX + 20, drawY + 44, 24, 4);
        } else {
            ctx.fillRect(drawX + 22, drawY + 40, 20, 8);
        }
        // è§¦æ‰‹
        ctx.fillStyle = '#DDD';
        for (let i = 0; i < 4; i++) {
            const tx = drawX + 8 + i * 14;
            const sway = Math.sin(Date.now() / 300 + i) * 3;
            ctx.fillRect(tx + sway, drawY + this.height, 6, 16);
        }
        ctx.globalAlpha = 1;
        // å“­æ³£æ³ªæ°´ç²’å­
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = this.crying ? '#4FC3F7' : '#FF8A65';
            ctx.fillRect(p.x - camX, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    }
}

// çƒˆç„°äºº BOSS
class BlazeBoss extends Boss {
    constructor(spawnX) {
        super({
            name: 'çƒˆç„°äºº Blaze',
            maxHp: 28,
            color: '#FFD700',
            x: spawnX,
            y: 100,
            width: 48,
            height: 64,
            phaseThresholds: [0.7, 0.5],
            damage: 1
        });
        this.rotationAngle = 0;
        this.floatY = 100;
        this.floatDir = 1;
        this.fireColumns = [];
        this.minions = [];
        this.minionsSummoned = false;
        this.burstQueue = [];
        this.burstTimer = 0;
        this.fireColumnTimer = 0;
    }

    updateBehavior(playerRef) {
        this.updateFloat();
        this.updateBurstQueue(playerRef);
        this.updateFireColumns(playerRef);
        this.updateMinions(playerRef);

        // ä¸‰è¿ç«çƒï¼ˆå§‹ç»ˆæ¿€æ´»ï¼‰
        const burstInterval = this.phase === 1 ? 240 : this.phase === 2 ? 180 : 120;
        this.attackTimer++;
        if (this.attackTimer >= burstInterval) {
            this.fireballBurst(playerRef, 3, 18);
            this.attackTimer = 0;
        }

        // ç«ç„°æ—‹é£ï¼ˆé˜¶æ®µ2+ï¼‰
        if (this.phase >= 2) {
            this.fireColumnTimer++;
            if (this.fireColumnTimer >= 600) {
                this.spawnFireColumns();
                this.fireColumnTimer = 0;
            }
        }

        // å¬å”¤å°çƒˆç„°äººï¼ˆé˜¶æ®µ3ï¼Œä»…ä¸€æ¬¡ï¼‰
        if (this.phase >= 3 && !this.minionsSummoned) {
            this.summonMinions();
        }
    }
// PLACEHOLDER_BLAZE_CONTINUE

    updateFloat() {
        this.floatY += this.floatDir * 0.5;
        if (this.floatY <= 60 || this.floatY >= 180) this.floatDir *= -1;
        this.y = this.floatY;
        // æ°´å¹³ç¼“æ…¢è¿½è¸ªç©å®¶
        const dx = player.x - this.x;
        this.x += Math.sign(dx) * 0.5;
    }

    fireballBurst(playerRef, count, interval) {
        for (let i = 0; i < count; i++) {
            this.burstQueue.push({ delay: i * interval, playerRef });
        }
    }

    updateBurstQueue(playerRef) {
        if (this.burstQueue.length === 0) return;
        this.burstTimer++;
        while (this.burstQueue.length > 0 && this.burstTimer >= this.burstQueue[0].delay) {
            const burst = this.burstQueue.shift();
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;
            const px = player.x + player.width / 2;
            const py = player.y + player.height / 2;
            const angle = Math.atan2(py - cy, px - cx);
            this.bossProjectiles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * 4,
                vy: Math.sin(angle) * 4,
                damage: 1, size: 10,
                color: '#FF4500',
                tracking: false, life: 300
            });
        }
        if (this.burstQueue.length === 0) this.burstTimer = 0;
    }

    spawnFireColumns() {
        for (let i = 0; i < 3; i++) {
            this.fireColumns.push({
                x: player.x + (Math.random() - 0.5) * 300,
                y: groundY,
                width: 20, height: 60,
                life: 480,
                trackSpeed: 0.8,
                dmgTimer: 0
            });
        }
        showFloatingText('ğŸ”¥ ç«ç„°æ—‹é£!', this.x + this.width / 2, this.y - 20, '#FF4500');
    }
// PLACEHOLDER_BLAZE_CONTINUE2

    updateFireColumns(playerRef) {
        for (let i = this.fireColumns.length - 1; i >= 0; i--) {
            const col = this.fireColumns[i];
            const dx = player.x - col.x;
            col.x += Math.sign(dx) * col.trackSpeed;
            col.life--;
            col.dmgTimer++;
            // æ¯ç§’1å¿ƒä¼¤å®³
            if (col.dmgTimer >= 60) {
                col.dmgTimer = 0;
                if (Math.abs(player.x + player.width / 2 - col.x - col.width / 2) < col.width / 2 + player.width / 2 &&
                    player.y + player.height > col.y - col.height && player.y < col.y) {
                    damagePlayer(1, col.x);
                }
            }
            if (col.life <= 0) this.fireColumns.splice(i, 1);
        }
    }

    summonMinions() {
        this.minionsSummoned = true;
        for (let i = 0; i < 2; i++) {
            this.minions.push({
                x: this.x + (i === 0 ? -80 : 80),
                y: this.y,
                hp: 8, maxHp: 8,
                width: 24, height: 32,
                speed: 2.5,
                attackTimer: 0,
                alive: true
            });
        }
        showFloatingText('ğŸ”¥ å¬å”¤å°çƒˆç„°äºº!', this.x + this.width / 2, this.y - 20, '#FF4500');
    }

    updateMinions(playerRef) {
        this.minions.forEach(m => {
            if (!m.alive) return;
            const dx = player.x - m.x;
            m.x += Math.sign(dx) * m.speed;
            // æµ®ç©º
            m.y = this.floatY + 30;
            m.attackTimer++;
            if (m.attackTimer >= 180) {
                this.bossProjectiles.push({
                    x: m.x + m.width / 2, y: m.y + m.height / 2,
                    vx: Math.sign(dx) * 3, vy: 0,
                    damage: 1, size: 8, color: '#FF6600',
                    tracking: false, life: 300
                });
                m.attackTimer = 0;
            }
        });
    }
// PLACEHOLDER_BLAZE_CONTINUE3

    // å°çƒˆç„°äººå—ä¼¤ï¼ˆè¿‘æˆ˜æ”»å‡»æ£€æµ‹ï¼‰
    damageMinionAt(ax, ay, range, damage) {
        this.minions.forEach(m => {
            if (!m.alive) return;
            if (Math.abs(ax - m.x - m.width / 2) < range + m.width / 2 &&
                Math.abs(ay - m.y - m.height / 2) < range + m.height / 2) {
                m.hp -= damage;
                showFloatingText(`-${damage}`, m.x + m.width / 2, m.y - 10, '#FF4444');
                if (m.hp <= 0) {
                    m.alive = false;
                    showFloatingText('ğŸ’€', m.x + m.width / 2, m.y - 20, '#FFD700');
                }
            }
        });
    }

    // å°æ€ªå­˜æ´»æ—¶BOSSé˜²å¾¡+50%
    takeDamage(amount) {
        const aliveMinions = this.minions.filter(m => m.alive).length;
        if (aliveMinions > 0) amount = Math.ceil(amount * 0.5);
        super.takeDamage(amount);
    }

    onPhaseChange(newPhase) {
        this.attackTimer = 0;
        this.fireColumnTimer = 0;
        if (newPhase === 2) {
            showToast('âš ï¸ çƒˆç„°äººé‡Šæ”¾ç«ç„°æ—‹é£!');
        } else if (newPhase === 3) {
            showToast('âš ï¸ çƒˆç„°äººå¬å”¤æ´å†›!');
        }
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: this.x + Math.random() * this.width,
                y: this.y + Math.random() * this.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1
            });
        }
    }

    render(ctx, camX) {
        const drawX = this.x - camX;
        const drawY = this.y;
        this.rotationAngle += 0.05;
        const cx = drawX + this.width / 2;
        const cy = drawY + this.height / 2;

        // ä¸­å¿ƒæ ¸å¿ƒ
        ctx.fillStyle = this.flashTimer > 0 ? '#FFF' : '#FFD700';
        ctx.fillRect(drawX + 8, drawY + 8, this.width - 16, this.height - 16);

        // æ—‹è½¬çƒˆç„°æ£’ï¼ˆ4æ ¹ï¼‰
        ctx.fillStyle = '#FF8C00';
        for (let i = 0; i < 4; i++) {
            const angle = this.rotationAngle + (Math.PI / 2) * i;
            const bx = cx + Math.cos(angle) * 28 - 4;
            const by = cy + Math.sin(angle) * 28 - 12;
            ctx.fillRect(bx, by, 8, 24);
        }

        // çœ¼ç›
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(drawX + 14, drawY + 20, 6, 6);
        ctx.fillRect(drawX + 28, drawY + 20, 6, 6);
// PLACEHOLDER_BLAZE_RENDER_END

        // ç«ç„°ç²’å­ç¯ç»•
        for (let i = 0; i < 3; i++) {
            const px = cx + Math.cos(Date.now() / 200 + i * 2) * 20;
            const py = cy + Math.sin(Date.now() / 200 + i * 2) * 20;
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100 | 0}, 0, 0.6)`;
            ctx.fillRect(px - 2, py - 2, 4, 4);
        }

        // æ¸²æŸ“ç«ç„°æŸ±
        this.fireColumns.forEach(col => {
            const colX = col.x - camX;
            const alpha = col.life > 60 ? 0.8 : (col.life / 60) * 0.8;
            ctx.fillStyle = `rgba(255, 69, 0, ${alpha})`;
            ctx.fillRect(colX, col.y - col.height, col.width, col.height);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(colX - 2, col.y - col.height - 8, col.width + 4, 8);
        });

        // æ¸²æŸ“å°çƒˆç„°äºº
        this.minions.forEach(m => {
            if (!m.alive) return;
            const mx = m.x - camX;
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(mx, m.y, m.width, m.height);
            // å°è¡€æ¡
            const hpPct = m.hp / m.maxHp;
            ctx.fillStyle = '#F44336';
            ctx.fillRect(mx, m.y - 6, m.width * hpPct, 3);
        });

        // ç²’å­
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = '#FF6600';
            ctx.fillRect(p.x - camX, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    }
}

// å‡‹é›¶éª·é«… BOSS
class WitherSkeletonBoss extends Boss {
    constructor(spawnX) {
        super({
            name: 'å‡‹é›¶éª·é«… Wither Skeleton',
            maxHp: 40,
            color: '#1A1A1A',
            x: spawnX,
            y: groundY - 96,
            width: 48,
            height: 96,
            phaseThresholds: [0.6, 0.3],
            damage: 1
        });
        this.grounded = true;
        this.moveSpeed = 2.0;
        this.facing = -1;
        this.state = 'patrol';
        this.comboStep = 0;
        this.comboTimer = 0;
        this.blockTimer = 0;
        this.blockHits = 0;
        this.jumpAttackPhase = 0;
        this.minions = [];
        this.minionsSummoned = false;
        this.vy = 0;
        this.gravity = 0.5;
        this.actionCooldown = 0;
    }

    updateBehavior(playerRef) {
        this.facing = playerRef.x > this.x ? 1 : -1;
        const dist = Math.abs(playerRef.x - this.x);

        // é‡åŠ›
        if (this.y < groundY - this.height) {
            this.vy += this.gravity;
            this.y += this.vy;
            if (this.y >= groundY - this.height) {
                this.y = groundY - this.height;
                this.vy = 0;
            }
        }

        if (this.actionCooldown > 0) this.actionCooldown--;

        switch (this.state) {
            case 'patrol':
                this.x += this.facing * this.moveSpeed * (this.phase >= 2 ? 1.3 : 1);
                if (dist < 64 && this.actionCooldown <= 0) {
                    this.startCombo();
                } else if (dist > 96 && this.actionCooldown <= 0 && Math.random() < 0.01) {
                    this.startJumpAttack();
                }
                if (this.actionCooldown <= 0 && Math.random() < 0.003) {
                    this.startBlocking();
                }
                break;
            case 'combo': this.updateCombo(); break;
            case 'jump_attack': this.updateJumpAttack(); break;
            case 'blocking': this.updateBlocking(); break;
            case 'stunned':
                this.stunTimer--;
                if (this.stunTimer <= 0) { this.state = 'patrol'; this.actionCooldown = 60; }
                break;
            case 'summoning':
                this.comboTimer++;
                if (this.comboTimer >= 60) { this.state = 'patrol'; this.actionCooldown = 60; }
                break;
        }

        if (this.hp / this.maxHp < 0.3) this.summonMinions();
        this.updateMinions();
    }
// PLACEHOLDER_WSKEL_CONTINUE

    startCombo() {
        this.state = 'combo';
        this.comboStep = 0;
        this.comboTimer = 0;
    }

    updateCombo() {
        this.comboTimer++;
        const stepDuration = 30;
        if (this.comboTimer >= stepDuration) {
            this.comboTimer = 0;
            this.executeComboStep(this.comboStep);
            this.comboStep++;
            if (this.comboStep >= 3) {
                this.state = 'patrol';
                this.comboStep = 0;
                this.actionCooldown = 60;
            }
        }
    }

    executeComboStep(step) {
        const range = 60;
        const playerDist = Math.abs(player.x - this.x);
        switch (step) {
            case 0: // æ¨ªæ‰«
                if (playerDist < range + 20) {
                    damagePlayer(1, this.x);
                    showFloatingText('æ¨ªæ‰«!', this.x + this.width / 2, this.y - 20, '#FF4444');
                }
                break;
            case 1: // ä¸‹åŠˆ
                if (playerDist < range) {
                    damagePlayer(2, this.x);
                    showFloatingText('ä¸‹åŠˆ!', this.x + this.width / 2, this.y - 20, '#FF0000');
                }
                break;
            case 2: // çªåˆº+å‡»é€€
                if (playerDist < range + 10) {
                    damagePlayer(1, this.x, 150);
                    showFloatingText('çªåˆº!', this.x + this.width / 2, this.y - 20, '#FF6600');
                }
                break;
        }
    }

    startJumpAttack() {
        this.state = 'jump_attack';
        this.jumpAttackPhase = 1;
        this.comboTimer = 0;
        showFloatingText('âš ï¸', this.x + this.width / 2, this.y - 20, '#FF0000');
    }
// PLACEHOLDER_WSKEL_CONTINUE2

    updateJumpAttack() {
        switch (this.jumpAttackPhase) {
            case 1: // è“„åŠ›
                this.comboTimer++;
                if (this.comboTimer >= 30) {
                    this.jumpAttackPhase = 2;
                    this.vy = -12;
                    this.facing = player.x > this.x ? 1 : -1;
                }
                break;
            case 2: // è·ƒèµ·+ä¸‹è½
                this.vy += this.gravity;
                this.y += this.vy;
                this.x += this.facing * 3;
                if (this.y >= groundY - this.height) {
                    this.y = groundY - this.height;
                    this.vy = 0;
                    this.jumpAttackPhase = 3;
                    this.comboTimer = 0;
                    this.jumpAttackLand();
                }
                break;
            case 3: // ç€åœ°ç¡¬ç›´
                this.comboTimer++;
                if (this.comboTimer >= 30) {
                    this.state = 'patrol';
                    this.jumpAttackPhase = 0;
                    this.actionCooldown = 60;
                }
                break;
        }
    }

    jumpAttackLand() {
        const aoeRange = 64;
        const dist = Math.abs(player.x - this.x);
        if (dist < aoeRange) {
            damagePlayer(2, this.x, 120);
            showFloatingText('ğŸ’¥ è·³åŠˆ!', this.x + this.width / 2, this.y - 30, '#FF0000');
        }
        for (let i = 0; i < 10; i++) {
            this.particles.push({
                x: this.x + (Math.random() - 0.5) * aoeRange * 2,
                y: groundY,
                vx: (Math.random() - 0.5) * 3,
                vy: -Math.random() * 4,
                life: 1.0
            });
        }
    }

    startBlocking() {
        this.state = 'blocking';
        this.blockTimer = 180;
        this.blockHits = 0;
    }

    updateBlocking() {
        this.blockTimer--;
        if (this.blockTimer <= 0) {
            this.state = 'patrol';
            this.actionCooldown = 60;
        }
    }
// PLACEHOLDER_WSKEL_CONTINUE3

    takeDamage(amount) {
        if (this.state === 'blocking') {
            this.blockHits++;
            showFloatingText('æ ¼æŒ¡!', this.x + this.width / 2, this.y - 20, '#AAAAAA');
            if (this.blockHits >= 7) {
                this.state = 'stunned';
                this.stunTimer = 180;
                showFloatingText('â­ ç ´é˜²!', this.x + this.width / 2, this.y - 30, '#FFD700');
            }
            return;
        }
        if (this.state === 'stunned') amount = Math.ceil(amount * 1.5);
        super.takeDamage(amount);
    }

    summonMinions() {
        if (this.minionsSummoned) return;
        this.minionsSummoned = true;
        this.state = 'summoning';
        this.comboTimer = 0;
        for (let i = 0; i < 4; i++) {
            this.minions.push({
                x: this.x + (i - 1.5) * 50,
                y: groundY - 48,
                hp: 5, maxHp: 5,
                width: 24, height: 48,
                speed: 2.0,
                attackTimer: 0,
                alive: true
            });
        }
        showFloatingText('ğŸ’€ å¬å”¤éª·é«…å°å…µ!', this.x + this.width / 2, this.y - 30, '#666');
    }

    updateMinions() {
        this.minions.forEach(m => {
            if (!m.alive) return;
            const dx = player.x - m.x;
            m.x += Math.sign(dx) * m.speed;
            m.attackTimer++;
            if (m.attackTimer >= 120 && Math.abs(player.x - m.x) < 40) {
                damagePlayer(1, m.x);
                m.attackTimer = 0;
                showFloatingText('ğŸ’€', m.x, m.y - 10, '#666');
            }
        });
    }

    damageMinionAt(ax, ay, range, damage) {
        this.minions.forEach(m => {
            if (!m.alive) return;
            if (Math.abs(ax - m.x - m.width / 2) < range + m.width / 2 &&
                Math.abs(ay - m.y - m.height / 2) < range + m.height / 2) {
                m.hp -= damage;
                showFloatingText(`-${damage}`, m.x + m.width / 2, m.y - 10, '#FF4444');
                if (m.hp <= 0) {
                    m.alive = false;
                    showFloatingText('ğŸ’€', m.x + m.width / 2, m.y - 20, '#FFD700');
                }
            }
        });
    }
// PLACEHOLDER_WSKEL_CONTINUE4

    onPhaseChange(newPhase) {
        this.actionCooldown = 0;
        if (newPhase === 2) {
            this.moveSpeed = 2.6;
            showToast('âš ï¸ å‡‹é›¶éª·é«…å˜å¾—æ›´åŠ å‡¶çŒ›!');
        } else if (newPhase === 3) {
            this.moveSpeed = 3.0;
            showToast('âš ï¸ å‡‹é›¶éª·é«…è¿›å…¥ç‹‚æš´çŠ¶æ€!');
        }
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: this.x + Math.random() * this.width,
                y: this.y + Math.random() * this.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1
            });
        }
    }

    render(ctx, camX) {
        const drawX = this.x - camX;
        const drawY = this.y;
        const squash = this.jumpAttackPhase === 1 ? 0.8 : 1;

        // èº«ä½“
        ctx.fillStyle = this.flashTimer > 0 ? '#FFF' : '#1A1A1A';
        ctx.fillRect(drawX, drawY + this.height * (1 - squash), this.width, this.height * squash);

        // éª·é«…å¤´
        ctx.fillStyle = '#2A2A2A';
        ctx.fillRect(drawX + 8, drawY - 4 + this.height * (1 - squash), 32, 28);
        // çœ¼ç›
        ctx.fillStyle = this.phase >= 3 ? '#FF0000' : '#CC0000';
        ctx.fillRect(drawX + 14, drawY + 4 + this.height * (1 - squash), 6, 6);
        ctx.fillRect(drawX + 28, drawY + 4 + this.height * (1 - squash), 6, 6);

        // çŸ³å‰‘
        ctx.fillStyle = '#808080';
        const swordX = this.facing > 0 ? drawX + this.width : drawX - 12;
        ctx.fillRect(swordX, drawY + 20, 8, 40);
        ctx.fillStyle = '#A0A0A0';
        ctx.fillRect(swordX - 4, drawY + 56, 16, 6);
// PLACEHOLDER_WSKEL_RENDER_END

        // æ ¼æŒ¡çŠ¶æ€ - ç™½è‰²é˜²æŠ¤ç½©
        if (this.state === 'blocking') {
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(drawX + this.width / 2, drawY + this.height / 2, 50, 0, Math.PI * 2);
            ctx.stroke();
        }

        // çœ©æ™•çŠ¶æ€ - å¤´é¡¶æ˜Ÿæ˜Ÿ
        if (this.state === 'stunned') {
            for (let i = 0; i < 3; i++) {
                const sx = drawX + 10 + i * 14 + Math.sin(Date.now() / 200 + i) * 5;
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px Arial';
                ctx.fillText('â­', sx, drawY - 20);
            }
        }

        // æ¸²æŸ“å°å…µ
        this.minions.forEach(m => {
            if (!m.alive) return;
            const mx = m.x - camX;
            ctx.fillStyle = '#333';
            ctx.fillRect(mx, m.y, m.width, m.height);
            ctx.fillStyle = '#F44336';
            ctx.fillRect(mx, m.y - 5, m.width * (m.hp / m.maxHp), 3);
        });

        // ç²’å­
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = '#666';
            ctx.fillRect(p.x - camX, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    }
}

</script>
<script>
/**
 * 12-challenges.js - å­¦ä¹ æŒ‘æˆ˜ç³»ç»Ÿ
 * v1.8.3 æ·»åŠ æ‘åº„æŒ‘æˆ˜æ”¯æŒ
 */

// ========== v1.8.3 æ‘åº„æŒ‘æˆ˜ç³»ç»Ÿ ==========

/**
 * å¯åŠ¨æ‘åº„å­¦ä¹ æŒ‘æˆ˜
 * @param {Object} village - å½“å‰æ‘åº„å®ä¾‹
 * @param {Function} onComplete - å®Œæˆå›è°ƒ
 */
function startVillageChallenge(village, onComplete) {
  if (!village) {
    console.warn('[Village Challenge] No village provided');
    return;
  }

  // ä» villageConfig.challengeQuestionCount è·å–é¢˜ç›®æ•°é‡ï¼ˆé»˜è®¤3ï¼‰
  const questionCount = villageConfig?.challengeQuestionCount || 3;

  // æ£€æµ‹æ‘åº„æ˜¯å¦å·²æœ‰å­¦ä¹ æŒ‘æˆ˜è¿›åº¦
  if (!village.challengeProgress) {
    village.challengeProgress = {
      currentQuestion: 0,
      correctCount: 0,
      wordsSeen: []
    };
  }

  const progress = village.challengeProgress;
  progress.currentQuestion = 0;
  progress.correctCount = 0;

  console.log(`[Village Challenge] Starting challenge for village ${village.id}, questions: ${questionCount}`);

  // è·å–ç¾¤ç³»ä¸“å±å•è¯
  const biomeWords = typeof getVillageWords === 'function'
    ? getVillageWords(village.biomeId)
    : [];

  if (!biomeWords || biomeWords.length === 0) {
    showToast('ğŸ“š å½“å‰ç¾¤ç³»æš‚æ— å¯ç”¨å•è¯');
    if (typeof onComplete === 'function') onComplete(0, questionCount);
    return;
  }

  // éšæœºæ‰“ä¹±å•è¯é¡ºåº
  const shuffled = [...biomeWords].sort(() => Math.random() - 0.5);
  const selectedWords = shuffled.slice(0, Math.min(questionCount, shuffled.length));

  if (selectedWords.length === 0) {
    showToast('ğŸ“š å•è¯æ•°é‡ä¸è¶³');
    if (typeof onComplete === 'function') onComplete(0, 0);
    return;
  }

  // æ˜¾ç¤ºæŒ‘æˆ˜å¼€å§‹ç•Œé¢
  showVillageChallengeIntro(village.biomeId, selectedWords.length, () => {
    // ç»Ÿä¸€ç­”é¢˜å›è°ƒï¼Œæ‰€æœ‰é¢˜ç›®å¤ç”¨
    function handleAnswer(isCorrect) {
      if (isCorrect) progress.correctCount++;
      progress.currentQuestion++;
      if (progress.currentWord && !progress.wordsSeen.includes(progress.currentWord.en)) {
        progress.wordsSeen.push(progress.currentWord.en);
      }
      if (progress.currentQuestion >= selectedWords.length) {
        finishVillageChallenge(village, progress.correctCount, selectedWords.length, onComplete);
      } else {
        setTimeout(() => {
          showVillageQuestion(village, selectedWords, progress, handleAnswer);
        }, 500);
      }
    }

    // å»¶è¿Ÿåæ˜¾ç¤ºç¬¬ä¸€é¢˜
    setTimeout(() => {
      showVillageQuestion(village, selectedWords, progress, handleAnswer);
    }, 300);
  });
}

/**
 * æ˜¾ç¤ºæ‘åº„æŒ‘æˆ˜å¼€å§‹ç•Œé¢
 * @param {string} biomeId - ç¾¤ç³»ID
 * @param {number} count - é¢˜ç›®æ•°é‡
 * @param {Function} onStart - å¼€å§‹å›è°ƒ
 */
function showVillageChallengeIntro(biomeId, count, onStart) {
  const modal = document.getElementById('challenge-modal');
  if (!modal) {
    console.warn('[Village Challenge] Challenge modal not found');
    return;
  }

  // æš‚åœæ¸¸æˆ
  pausedByModal = !paused;
  paused = true;

  const biomeName = getBiomeName(biomeId);

  modal.innerHTML = `
    <div style="text-align:center; padding:20px;">
      <div style="font-size:32px; margin-bottom:10px;">ğŸ“š</div>
      <h3 style="color:#FFD54F; margin:8px 0;">${biomeName}æ‘åº„ Â· å•è¯æŒ‘æˆ˜</h3>
      <p style="color:#EEE; font-size:14px;">å›ç­” ${count} é“å•è¯é¢˜</p>
      <p style="color:#AEA; font-size:12px;">å…¨å¯¹å¥–åŠ±ï¼šğŸ’Ã—1 + ğŸª™Ã—100 + ç¾¤ç³»é“å…·</p>
      <button id="btn-village-challenge-start"
              style="margin-top:16px; padding:10px 30px; font-size:16px;
                     background:#4CAF50; color:#FFF; border:none; border-radius:8px;
                     cursor:pointer;">
        å¼€å§‹æŒ‘æˆ˜
      </button>
    </div>
  `;
  modal.style.display = 'flex';

  const btnStart = document.getElementById('btn-village-challenge-start');
  if (btnStart) {
    btnStart.addEventListener('click', () => {
      modal.style.display = 'none';
      // æ¢å¤æ¸¸æˆ
      if (pausedByModal) paused = false;
      pausedByModal = false;
      if (typeof onStart === 'function') onStart();
    });
  }
}

/**
 * æ˜¾ç¤ºæ‘åº„å•è¯é¢˜ç›®ï¼ˆå­—æ¯å¡«ç©ºé€‰æ‹©é¢˜ï¼‰
 * @param {Object} village - æ‘åº„å®ä¾‹
 * @param {Array} words - å•è¯åˆ—è¡¨
 * @param {Object} progress - è¿›åº¦å¯¹è±¡
 * @param {Function} onAnswer - ç­”é¢˜å›è°ƒ
 */
function showVillageQuestion(village, words, progress, onAnswer) {
  const modal = document.getElementById('challenge-modal');
  if (!modal) return;

  pausedByModal = !paused;
  paused = true;

  const word = words[progress.currentQuestion];
  progress.currentWord = word;

  const en = (word.en || word.english || '').toLowerCase();
  const zh = word.zh || word.chinese || '';

  // éšæœºéšè—ä¸€ä¸ªå­—æ¯
  const hideIndex = Math.floor(Math.random() * en.length);
  const displayed = en.split('').map((ch, i) => i === hideIndex ? '_' : ch);
  const correctLetter = en[hideIndex];

  // ç”Ÿæˆé€‰é¡¹ï¼ˆæ­£ç¡®ç­”æ¡ˆ + 3 ä¸ªå¹²æ‰°é¡¹ï¼‰
  const allLetters = 'abcdefghijklmnopqrstuvwxyz';
  const options = [correctLetter];
  while (options.length < 4) {
    const rand = allLetters[Math.floor(Math.random() * 26)];
    if (!options.includes(rand)) options.push(rand);
  }
  options.sort(() => Math.random() - 0.5);

  modal.innerHTML = `
    <div style="text-align:center; padding:20px;">
      <p style="color:#AAA; font-size:12px; margin-bottom:8px;">é€‰æ‹©æ­£ç¡®çš„å­—æ¯å¡«ç©º</p>
      <div style="font-size:28px; color:#FFF; letter-spacing:4px; margin:12px 0; font-family:monospace;">
        ${displayed.join('')}
      </div>
      <p style="color:#FFD54F; font-size:14px; margin-bottom:16px;">${zh}</p>
      <div id="village-challenge-options" style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        ${options.map(opt => `
          <button class="village-opt-btn"
                  data-letter="${opt}"
                  style="width:50px; height:50px; font-size:22px; font-family:monospace;
                         background:#37474F; color:#FFF; border:2px solid #546E7A;
                         border-radius:8px; cursor:pointer;">
            ${opt}
          </button>
        `).join('')}
      </div>
    </div>
  `;
  modal.style.display = 'flex';

  // ç»‘å®šé€‰é¡¹ç‚¹å‡»
  setTimeout(() => {
    const btns = modal.querySelectorAll('.village-opt-btn');
    btns.forEach(btn => {
      btn.addEventListener('click', () => {
        const selected = btn.dataset.letter;
        const isCorrect = selected === correctLetter;

        // è§†è§‰åé¦ˆ
        btns.forEach(b => {
          b.style.pointerEvents = 'none';
          if (b.dataset.letter === correctLetter) {
            b.style.background = '#4CAF50';
            b.style.borderColor = '#66BB6A';
          } else if (b === btn && !isCorrect) {
            b.style.background = '#F44336';
            b.style.borderColor = '#EF5350';
          }
        });

        // æ’­æ”¾å•è¯å‘éŸ³
        if (typeof speakWord === 'function') {
          speakWord(en);
        }

        // æ˜¾ç¤ºåé¦ˆ
        setTimeout(() => {
          if (isCorrect) {
            showFloatingText('âœ… Correct!', player.x, player.y - 30);
          } else {
            showFloatingText(`âŒ ${en}`, player.x, player.y - 30);
          }

          // æ˜¾ç¤ºå®Œæ•´å•è¯
          setTimeout(() => {
            const fullWordEl = document.createElement('div');
            fullWordEl.style.cssText = 'color:#FFD54F; font-size:14px; margin-top:8px;';
            fullWordEl.textContent = `${en} - ${zh}`;
            modal.appendChild(fullWordEl);

            setTimeout(() => {
              if (typeof onAnswer === 'function') onAnswer(isCorrect);
              fullWordEl.remove();
            }, 800);
          }, 200);
        }, 300);
      });
    });
  }, 100);
}

/**
 * æ‘åº„æŒ‘æˆ˜å®Œæˆç»“ç®—
 * @param {Object} village - æ‘åº„å®ä¾‹
 * @param {number} correct - æ­£ç¡®æ•°é‡
 * @param {number} total - æ€»é¢˜æ•°
 * @param {Function} onComplete - å®Œæˆå›è°ƒ
 */
function finishVillageChallenge(village, correct, total, onComplete) {
  const modal = document.getElementById('challenge-modal');
  if (!modal) return;

  const reward = villageConfig?.challengeReward || {};
  const isPerfect = correct === total;

  const rewardText = isPerfect
    ? `ğŸ‰ å…¨å¯¹! +${reward.perfect?.score || 100}ğŸª™ +${reward.perfect?.diamonds || 1}ğŸ’`
    : `ğŸ“ ${correct}/${total} +${reward.partial?.score || 50}ğŸª™`;

  modal.innerHTML = `
    <div style="text-align:center; padding:20px;">
      <div style="font-size:40px; margin-bottom:10px;">${isPerfect ? 'ğŸ†' : 'ğŸ“–'}</div>
      <h3 style="color:${isPerfect ? '#FFD54F' : '#EEE'}; margin:8px 0;">
        ${isPerfect ? 'å®Œç¾é€šå…³!' : 'æŒ‘æˆ˜å®Œæˆ'}
      </h3>
      <p style="color:#AEA; font-size:16px;">${correct} / ${total} æ­£ç¡®</p>
      <p style="color:#FFD54F; font-size:14px; margin-top:8px;">${rewardText}</p>
      <button id="btn-village-challenge-done"
              style="margin-top:16px; padding:10px 30px; font-size:16px;
                     background:#4CAF50; color:#FFF; border:none; border-radius:8px;
                     cursor:pointer;">
        ç»§ç»­å†’é™©
      </button>
    </div>
  `;
  modal.style.display = 'flex';

  const btnDone = document.getElementById('btn-village-challenge-done');
  if (btnDone) {
    btnDone.addEventListener('click', () => {
      modal.style.display = 'none';
      // å‘æ”¾å¥–åŠ±
      if (isPerfect) {
        score += reward.perfect?.score || 100;
        inventory.diamond += reward.perfect?.diamonds || 1;
      } else {
        score += reward.partial?.score || 50;
      }
      updateDiamondUI();

      // ç¾¤ç³»ä¸“å±é“å…·å¥–åŠ±
      if (typeof grantBiomeReward === 'function') {
        grantBiomeReward(village.biomeId);
      }

      // æ¢å¤æ¸¸æˆ
      if (pausedByModal) paused = false;
      pausedByModal = false;

      if (typeof onComplete === 'function') onComplete(correct, total);
    });
  }
}

</script>
<script>
/**
 * 18-village.js - æ‘åº„ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘
 * v1.8.0 å®ç°æ‘åº„åŸºç¡€æ¡†æ¶
 */

// ========== æ‘åº„é£æ ¼å®šä¹‰ ==========
const VILLAGE_STYLES = {
  forest: {
    buildingColors: { wall: '#8B6914', roof: '#2E7D32', door: '#5D4037' },
    groundColor: '#6D4C41',
    decorations: ['well', 'farm', 'fence', 'flower_pot'],
    specialBuilding: 'library'
  },
  snow: {
    buildingColors: { wall: '#ECEFF1', roof: '#1565C0', door: '#37474F' },
    groundColor: '#B0BEC5',
    decorations: ['snowman', 'ice_lamp', 'pine_fence'],
    specialBuilding: 'hot_spring'
  },
  desert: {
    buildingColors: { wall: '#D7CCC8', roof: '#FF8F00', door: '#4E342E' },
    groundColor: '#BCAAA4',
    decorations: ['cactus_pot', 'sand_lamp', 'oasis'],
    specialBuilding: 'water_station'
  },
  mountain: {
    buildingColors: { wall: '#78909C', roof: '#455A64', door: '#37474F' },
    groundColor: '#607D8B',
    decorations: ['anvil', 'stone_lamp', 'mine_cart'],
    specialBuilding: 'blacksmith'
  },
  ocean: {
    buildingColors: { wall: '#4FC3F7', roof: '#0277BD', door: '#01579B' },
    groundColor: '#4DB6AC',
    decorations: ['anchor', 'barrel', 'fishing_rod'],
    specialBuilding: 'lighthouse'
  },
  nether: {
    buildingColors: { wall: '#4A148C', roof: '#880E4F', door: '#311B92' },
    groundColor: '#6A1B9A',
    decorations: ['soul_lantern', 'nether_wart_pot', 'chain'],
    specialBuilding: 'brewing_stand'
  }
};

// ========== åŠ è½½é…ç½® ==========
function loadVillageConfig() {
  // ä» config/village.json åŠ è½½ï¼Œå¤±è´¥æ—¶ç”¨é»˜è®¤å€¼
  // åœ¨ 17-bootstrap.js çš„ loadAllConfigs() ä¸­è°ƒç”¨
  const defaultVillageConfig = {
    enabled: true,
    spawnScoreInterval: 500,
    villageWidth: 800,
    safeZone: true,
    restHealFull: true,
    challengeQuestionCount: 3,
    challengeReward: {
      perfect: { score: 100, diamonds: 1 },
      partial: { score: 50, diamonds: 0 }
    },
    npcSpeed: 0.3,
    npcGreetDistance: 80,
    maxActiveVillages: 3,
    buildings: {
      bed_house: { w: 80, h: 60, offset: 100 },
      word_house: { w: 100, h: 80, offset: 300 },
      save_stone: { w: 40, h: 50, offset: 550 },
      special: { w: 80, h: 60, offset: 700 }
    },
    biomeWords: {
      forest: ["tree", "leaf", "bird", "flower", "grass", "wood", "deer", "owl"],
      snow: ["snow", "ice", "cold", "coat", "hat", "scarf", "ski", "sled"],
      desert: ["sand", "sun", "hot", "water", "cactus", "camel", "oasis", "dry"],
      mountain: ["rock", "iron", "gold", "pick", "cave", "stone", "gem", "ore"],
      ocean: ["fish", "wave", "boat", "shell", "whale", "coral", "swim", "sea"],
      nether: ["fire", "red", "lava", "dark", "flame", "ash", "smoke", "glow"]
    }
  };

  fetch('config/village.json')
    .then(r => r.json())
    .then(data => {
      villageConfig = data;
      console.log('[Village] é…ç½®åŠ è½½æˆåŠŸ');
    })
    .catch(() => {
      villageConfig = defaultVillageConfig;
      console.warn('[Village] ä½¿ç”¨é»˜è®¤é…ç½®');
    });
}

// ========== æ‘åº„ç”Ÿæˆ ==========
function maybeSpawnVillage(playerScore, playerX) {
  if (!settings || !settings.villageEnabled) return;
  if (!villageConfig || !villageConfig.enabled) return;
  const interval = villageConfig.spawnScoreInterval || 500;
  // è®¡ç®—å½“å‰åˆ†æ•°åº”è¯¥ç”Ÿæˆçš„æ‘åº„ç¼–å·
  const villageIndex = Math.floor(playerScore / interval);
  if (villageIndex < 1) return; // 0åˆ†ä¸ç”Ÿæˆ
  if (villageSpawnedForScore[villageIndex]) return; // å·²ç”Ÿæˆ

  const biomeId = currentBiome || 'forest';
  const village = createVillage(playerX + 600, biomeId, villageIndex);
  activeVillages.push(village);
  villageSpawnedForScore[villageIndex] = true;

  // å›æ”¶è¿œç¦»çš„æ‘åº„
  cleanupVillages(playerX);
  console.log(`[Village] ç”Ÿæˆæ‘åº„ #${villageIndex} at x=${village.x}, biome=${biomeId}`);
}

function createVillage(startX, biomeId, index) {
  const style = VILLAGE_STYLES[biomeId] || VILLAGE_STYLES.forest;
  const cfg = villageConfig.buildings || {};
  const village = {
    id: index,
    x: startX,
    width: villageConfig.villageWidth || 800,
    biomeId: biomeId,
    style: style,
    buildings: [
      { type: 'bed_house',  x: startX + (cfg.bed_house?.offset || 100),  w: cfg.bed_house?.w || 80,  h: cfg.bed_house?.h || 60 },
      { type: 'word_house', x: startX + (cfg.word_house?.offset || 300), w: cfg.word_house?.w || 100, h: cfg.word_house?.h || 80 },
      { type: 'save_stone', x: startX + (cfg.save_stone?.offset || 550), w: cfg.save_stone?.w || 40,  h: cfg.save_stone?.h || 50 },
      { type: style.specialBuilding, x: startX + (cfg.special?.offset || 700), w: cfg.special?.w || 80, h: cfg.special?.h || 60 }
    ],
    npcs: [],
    decorations: style.decorations.map((d, i) => ({
      type: d, x: startX + 50 + i * 150
    })),
    visited: false,
    restUsed: false,
    questCompleted: false,
    saved: false
  };

  // v1.8.1 æ·»åŠ  NPC
  if (typeof createVillageNPC === 'function') {
    const roles = ['greeter', 'teacher', 'trader'];
    const baseX = startX + 200;
    village.npcs = roles.map((role, i) =>
      createVillageNPC(baseX + i * 200, role, village.x, village.width)
    );
  }

  // Spawn word items and chests inside village
  spawnVillageItems(village);

  return village;
}

function spawnVillageItems(village) {
  if (typeof pickWordForSpawn !== 'function') return;
  if (typeof Item === 'undefined') return;
  const vx = village.x;
  const w = village.width || 800;
  // Spawn 3-5 word items spread across village
  const wordCount = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < wordCount; i++) {
    const ix = vx + 80 + (i * (w - 160) / wordCount) + Math.random() * 40;
    const word = pickWordForSpawn();
    if (word) {
      items.push(new Item(ix, groundY - 60, word));
      if (typeof registerWordItemSpawn === 'function') registerWordItemSpawn(ix);
    }
  }
  // Spawn 1-2 chests
  if (typeof Chest !== 'undefined') {
    const chestCount = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < chestCount; i++) {
      const cx = vx + 200 + i * 300 + Math.random() * 80;
      chests.push(new Chest(cx, groundY));
    }
  }
}

function cleanupVillages(playerX) {
  const max = villageConfig.maxActiveVillages || 3;
  // ç§»é™¤ç©å®¶èº«åè¶…è¿‡ 2000px çš„æ‘åº„
  activeVillages = activeVillages.filter(v => {
    return (v.x + v.width) > playerX - 2000;
  });
  // å¦‚æœä»è¶…è¿‡ä¸Šé™ï¼Œç§»é™¤æœ€è¿œçš„
  while (activeVillages.length > max) {
    activeVillages.shift();
  }
}

// ========== NPC æ‘æ°‘ç³»ç»Ÿ (v1.8.1) ==========

const NPC_ROLES = {
  greeter: {
    greeting: 'Welcome! æ¬¢è¿!',
    speed: 0.3,
    patrolRange: 120
  },
  teacher: {
    greeting: 'Come learn! æ¥å­¦ä¹ !',
    speed: 0.2,
    patrolRange: 80
  },
  trader: {
    greeting: 'Trade? äº¤æ˜“å—?',
    speed: 0.15,
    patrolRange: 60
  }
};

function createVillageNPC(baseX, role, villageX, villageWidth) {
  const cfg = NPC_ROLES[role] || NPC_ROLES.greeter;
  const minX = Math.max(villageX + 20, baseX - cfg.patrolRange);
  const maxX = Math.min(villageX + villageWidth - 20, baseX + cfg.patrolRange);
  return {
    x: baseX,
    y: 0,
    role: role,
    direction: 1,
    speed: cfg.speed,
    minX: minX,
    maxX: maxX,
    showBubble: false,
    bubbleText: cfg.greeting,
    bubbleTimer: 0,
    facingRight: true,
    animFrame: 0,
    animTimer: 0
  };
}

function updateVillageNPCs(village) {
  for (const npc of village.npcs) {
    // æ¥å›èµ°åŠ¨
    npc.x += npc.direction * npc.speed;
    if (npc.x <= npc.minX) {
      npc.x = npc.minX;
      npc.direction = 1;
      npc.facingRight = true;
    } else if (npc.x >= npc.maxX) {
      npc.x = npc.maxX;
      npc.direction = -1;
      npc.facingRight = false;
    }

    // èµ°è·¯åŠ¨ç”»å¸§
    npc.animTimer++;
    if (npc.animTimer >= 15) {
      npc.animTimer = 0;
      npc.animFrame = (npc.animFrame + 1) % 2;
    }

    // ç©å®¶é è¿‘æ—¶æ˜¾ç¤ºæ°”æ³¡
    const dist = Math.abs(player.x - npc.x);
    const greetDist = villageConfig.npcGreetDistance || 80;
    if (dist < greetDist) {
      npc.showBubble = true;
      // é¢å‘ç©å®¶
      npc.facingRight = player.x > npc.x;
      npc.direction = 0; // åœä¸‹æ¥
      npc.bubbleTimer = 120; // æ°”æ³¡æŒç»­ 2 ç§’
    } else if (npc.bubbleTimer > 0) {
      npc.bubbleTimer--;
      if (npc.bubbleTimer <= 0) {
        npc.showBubble = false;
        // æ¢å¤å·¡é€»
        npc.direction = npc.facingRight ? 1 : -1;
      }
    } else {
      npc.showBubble = false;
    }
  }
}

// ========== æ‘åº„çŠ¶æ€æ›´æ–° ==========
function updateVillages() {
  if (!settings || !settings.villageEnabled) return;
  if (!player) return;
  // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ–°æ‘åº„
  maybeSpawnVillage(score, player.x);
  // æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨æ‘åº„å†…
  const wasInVillage = playerInVillage;
  playerInVillage = false;
  currentVillage = null;
  for (const v of activeVillages) {
    if (player.x >= v.x && player.x <= v.x + v.width) {
      playerInVillage = true;
      currentVillage = v;
      if (!v.visited) {
        v.visited = true;
        const biomeName = getBiomeName(v.biomeId);
        showToast(`ğŸ˜ï¸ è¿›å…¥${biomeName}æ‘åº„`);
        // Remove enemies inside village area
        if (typeof enemies !== 'undefined' && Array.isArray(enemies)) {
          enemies = enemies.filter(e => e.x < v.x || e.x > v.x + v.width);
        }
      }
      // v1.8.1 æ›´æ–°æ‘æ°‘ (v1.8.1)
      updateVillageNPCs(v);

      // v1.8.2 æ£€æµ‹ä¼‘æ¯å±‹ (v1.8.2)
      checkVillageRest(v);
      break;
    }
  }
  if (wasInVillage && !playerInVillage) {
    showToast('ğŸ‘‹ ç¦»å¼€æ‘åº„');
    // v1.8.2 æ¸…é™¤ä¼‘æ¯æç¤º
    hideRestPrompt();
  }
}

// ========== ä¼‘æ¯ç³»ç»Ÿ (v1.8.2) ==========
let restPromptVisible = false;
let restPromptVillage = null;

function checkVillageRest(village) {
  if (!village) return;
  if (village.restUsed) return; // å·²ä½¿ç”¨è¿‡

  // æŸ¥æ‰¾ bed_house å»ºç­‘
  const bedHouse = village.buildings.find(b => b.type === 'bed_house');
  if (!bedHouse) return;

  // æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨åºŠå±‹åŒºåŸŸå†…
  const inBedHouse = player.x >= bedHouse.x && player.x <= bedHouse.x + bedHouse.w;
  if (inBedHouse && !restPromptVisible) {
    showRestPrompt(village);
  } else if (!inBedHouse && restPromptVisible) {
    hideRestPrompt();
  }
}

function checkVillageBuildings(village) {
  if (!village) return;

  for (const building of village.buildings) {
    const buildingLeft = building.x;
    const buildingRight = building.x + building.w;

    // æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨å»ºç­‘åŒºåŸŸå†…
    if (player.x + player.width / 2 >= buildingLeft &&
        player.x + player.width / 2 <= buildingRight) {
      handleVillageInteraction(building, village);
    }
  }
}

function showRestPrompt(village) {
  restPromptVisible = true;
  restPromptVillage = village;
  const restPromptEl = document.getElementById('rest-prompt');
  if (restPromptEl) {
    restPromptEl.style.display = 'block';
    return;
  }

  // åŠ¨æ€åˆ›å»ºä¼‘æ¯æç¤º
  const prompt = document.createElement('div');
  prompt.id = 'rest-prompt';
  prompt.className = 'rest-prompt';
  prompt.innerHTML = `
    <div class="rest-prompt-content">
      <div>ğŸ’¤ ä¼‘æ¯å›è¡€</div>
      <button id="btn-rest" class="game-btn">ä¼‘æ¯ (Y)</button>
    </div>
  `;
  document.getElementById('game-container').appendChild(prompt);

  const btnRest = document.getElementById('btn-rest');
  if (btnRest) {
    btnRest.addEventListener('click', () => {
      performRest(restPromptVillage);
    });
  }
}

function hideRestPrompt() {
  restPromptVisible = false;
  restPromptVillage = null;
  const restPromptEl = document.getElementById('rest-prompt');
  if (restPromptEl) {
    restPromptEl.style.display = 'none';
  }
}

function performRest(village) {
  if (!village) return;
  if (village.restUsed) {
    showToast('ğŸ’¤ å·²ç»ä¼‘æ¯è¿‡äº†');
    return;
  }

  // æ£€æŸ¥æ»¡è¡€æ¡ä»¶
  const isFullHp = playerHp >= playerMaxHp;
  if (isFullHp && villageConfig.restHealFull) {
    showToast('â¤ï¸ å·²æ»¡è¡€ï¼Œæ— éœ€ä¼‘æ¯');
    return;
  }

  // æ‰§è¡Œä¼‘æ¯å›è¡€
  if (villageConfig.restHealFull) {
    playerHp = playerMaxHp;
  } else {
    playerHp = Math.min(playerMaxHp, playerHp + 5);
  }

  updateHpUI();
  village.restUsed = true;
  hideRestPrompt();

  const healAmount = villageConfig.restHealFull ? 'å…¨æ»¡' : '+5';
  showToast(`ğŸ’¤ ä¼‘æ¯æˆåŠŸï¼ç”Ÿå‘½${healAmount}`);
  showFloatingText('â¤ï¸ +ä¼‘æ¯', player.x, player.y - 60);

  // ä¿å­˜è¿›åº¦
  if (typeof saveCurrentProgress === 'function') {
    saveCurrentProgress();
  }
}

// ========== è¾…åŠ©å‡½æ•° ==========
function isInVillageArea(x) {
  for (const v of activeVillages) {
    if (x >= v.x && x <= v.x + v.width) return true;
  }
  return false;
}

function getVillageAt(x) {
  for (const v of activeVillages) {
    if (x >= v.x && x <= v.x + v.width) return v;
  }
  return null;
}

function getBiomeName(biomeId) {
  if (typeof biomeConfigs === 'undefined' || !biomeConfigs) return biomeId || 'forest';
  const biome = biomeConfigs[biomeId];
  return biome ? biome.name : biomeId;
}

// ========== v1.8.3 æ‘åº„å•è¯ç³»ç»Ÿ ==========
function getVillageWords(biomeId) {
  if (!villageConfig || !villageConfig.biomeWords) return [];
  return villageConfig.biomeWords[biomeId] || villageConfig.biomeWords.forest || [];
}

function handleVillageInteraction(building, village) {
  if (!building || !village) return false;

  switch (building.type) {
    case 'bed_house':
      // v1.8.2 ä¼‘æ¯ç³»ç»Ÿå·²åœ¨ checkVillageRest ä¸­å¤„ç†
      return true;
    case 'word_house':
      // v1.8.3 å•è¯å­¦ä¹ å±‹
      if (village.questCompleted) {
        showToast('ğŸ“š å·²å®Œæˆå­¦ä¹ ä»»åŠ¡');
        return false;
      }
      if (typeof startVillageChallenge === 'function') {
        startVillageChallenge(village, () => {
          village.questCompleted = true;
        });
      }
      return true;
    case 'save_stone':
      // v1.8.4 å­˜æ¡£çŸ³ç¢‘
      if (typeof saveVillageProgress === 'function') {
        saveVillageProgress(village);
      }
      return true;
    case 'special':
      // v1.8.4 ç‰¹è‰²å»ºç­‘
      showToast('ğŸ— ç‰¹è‰²å»ºç­‘æš‚æœªå¼€æ”¾');
      return true;
  }
  return false;
}

function saveVillageProgress(village) {
  village.saved = true;
  showToast('ğŸ’¾ æ¸¸æˆè¿›åº¦å·²ä¿å­˜');
  // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„å­˜æ¡£é€»è¾‘
}

</script>
<script>
/**
 * 18-village-render.js - Village rendering (Minecraft style)
 * Draws village as background environment with stone/wood block buildings
 */

// Block colors per biome
const VILLAGE_BLOCK_COLORS = {
  forest: { stone: '#8B8B8B', plank: '#B8945A', log: '#6B4226', glass: '#A8D8EA', roof: '#2E7D32', path: '#6D4C41' },
  snow: { stone: '#C8C8C8', plank: '#D7CCC8', log: '#5D4037', glass: '#B3E5FC', roof: '#1565C0', path: '#B0BEC5' },
  desert: { stone: '#D2B48C', plank: '#DEB887', log: '#8B7355', glass: '#FFE0B2', roof: '#FF8F00', path: '#BCAAA4' },
  mountain: { stone: '#696969', plank: '#8B7D6B', log: '#4A4A4A', glass: '#B0C4DE', roof: '#455A64', path: '#607D8B' },
  ocean: { stone: '#5F9EA0', plank: '#87CEEB', log: '#2F4F4F', glass: '#E0F7FA', roof: '#0277BD', path: '#4DB6AC' },
  nether: { stone: '#8B0000', plank: '#4A0028', log: '#2C0014', glass: '#FF6F00', roof: '#880E4F', path: '#6A1B9A' }
};

function getVillageColors(biomeId) {
  return VILLAGE_BLOCK_COLORS[biomeId] || VILLAGE_BLOCK_COLORS.forest;
}

// Draw a single Minecraft-style block (stone/plank with grid lines)
function drawBlock_village(ctx, x, y, w, h, color, borderColor) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = borderColor || 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(x, y, w, h);
}

// Draw a Minecraft-style house using blocks
function drawBlockHouse(ctx, bx, by, w, h, colors, type) {
  const bs = 10; // block size
  const cols = Math.floor(w / bs);
  const rows = Math.floor(h / bs);
  // Walls - stone/plank blocks
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const isEdge = c === 0 || c === cols - 1;
      const color = isEdge ? colors.log : colors.plank;
      drawBlock_village(ctx, bx + c * bs, by + r * bs, bs, bs, color);
    }
  }
  // Roof - triangle of blocks
  const roofRows = Math.ceil(cols / 2);
  for (let r = 0; r < roofRows; r++) {
    const startC = r;
    const endC = cols - r;
    for (let c = startC; c < endC; c++) {
      drawBlock_village(ctx, bx + c * bs, by - (r + 1) * bs, bs, bs, colors.roof);
    }
  }
  // Door
  const doorW = Math.max(1, Math.floor(cols / 4));
  const doorH = Math.min(3, rows - 1);
  const doorStartC = Math.floor((cols - doorW) / 2);
  for (let r = rows - doorH; r < rows; r++) {
    for (let c = doorStartC; c < doorStartC + doorW; c++) {
      drawBlock_village(ctx, bx + c * bs, by + r * bs, bs, bs, '#3E2723');
    }
  }
  // Windows (glass blocks)
  if (cols >= 6) {
    const winY = by + bs;
    drawBlock_village(ctx, bx + bs, winY, bs, bs, colors.glass);
    drawBlock_village(ctx, bx + (cols - 2) * bs, winY, bs, bs, colors.glass);
  }
  // Icon label
  const icons = { bed_house: 'ğŸ›ï¸', word_house: 'ğŸ“–', save_stone: 'ğŸ’¾' };
  const icon = icons[type] || 'ğŸ ';
  ctx.font = `${14 * (worldScale?.x || 1)}px serif`;
  ctx.textAlign = 'center';
  ctx.fillText(icon, bx + w / 2, by - roofRows * bs - 4);
  ctx.textAlign = 'left';
}

// Draw a bed inside the bed_house area
function drawVillageBed(ctx, bx, by, colors) {
  // Bed frame (wood)
  ctx.fillStyle = colors.log;
  ctx.fillRect(bx, by, 30, 8);
  // Pillow (white)
  ctx.fillStyle = '#FFF';
  ctx.fillRect(bx, by - 4, 10, 4);
  // Blanket (red)
  ctx.fillStyle = '#D32F2F';
  ctx.fillRect(bx + 10, by - 3, 20, 3);
}

// Draw village path (cobblestone)
function drawVillagePath(ctx, village) {
  const sx = village.x - cameraX;
  const w = village.width || 800;
  const colors = getVillageColors(village.biomeId);
  const bs = 12;
  const pathY = groundY;
  // Cobblestone path
  ctx.fillStyle = colors.path;
  ctx.fillRect(sx, pathY, w, 8);
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i < w; i += bs) {
    ctx.strokeRect(sx + i, pathY, bs, 8);
  }
}

// Draw a well (stone blocks + water)
function drawVillageWell(ctx, x) {
  const sx = x - cameraX;
  const wy = groundY - 24;
  // Stone base
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      drawBlock_village(ctx, sx + c * 8, wy + r * 8, 8, 8, '#8B8B8B');
    }
  }
  // Water inside
  ctx.fillStyle = 'rgba(33,150,243,0.6)';
  ctx.fillRect(sx + 8, wy + 8, 8, 8);
  // Roof posts
  ctx.fillStyle = '#6B4226';
  ctx.fillRect(sx + 2, wy - 16, 3, 16);
  ctx.fillRect(sx + 19, wy - 16, 3, 16);
  // Roof
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(sx, wy - 20, 24, 4);
}

// Draw a lamp post
function drawVillageLamp(ctx, x, colors) {
  const sx = x - cameraX;
  const ly = groundY - 40;
  ctx.fillStyle = colors.log;
  ctx.fillRect(sx + 3, ly, 4, 40);
  // Lantern
  ctx.fillStyle = '#FFEB3B';
  ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 300) * 0.2;
  ctx.fillRect(sx, ly - 4, 10, 8);
  ctx.globalAlpha = 1.0;
  // Glow
  ctx.fillStyle = 'rgba(255,235,59,0.15)';
  ctx.beginPath();
  ctx.arc(sx + 5, ly, 20, 0, Math.PI * 2);
  ctx.fill();
}

// Draw a fence section
function drawVillageFence(ctx, x, colors) {
  const sx = x - cameraX;
  const fy = groundY - 18;
  ctx.fillStyle = colors.log;
  ctx.fillRect(sx, fy, 3, 18);
  ctx.fillRect(sx + 14, fy, 3, 18);
  ctx.fillRect(sx + 28, fy, 3, 18);
  ctx.fillStyle = colors.plank;
  ctx.fillRect(sx, fy + 4, 31, 3);
  ctx.fillRect(sx, fy + 12, 31, 3);
}

// Draw village entrance sign
function drawVillageSign(ctx, x, biomeName) {
  const sx = x - cameraX;
  const sy = groundY - 50;
  // Post
  ctx.fillStyle = '#6B4226';
  ctx.fillRect(sx + 12, sy + 20, 4, 30);
  // Sign board
  ctx.fillStyle = '#B8945A';
  ctx.fillRect(sx, sy, 28, 18);
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 1;
  ctx.strokeRect(sx, sy, 28, 18);
  // Text
  ctx.fillStyle = '#3E2723';
  ctx.font = 'bold 7px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('Village', sx + 14, sy + 12);
  ctx.textAlign = 'left';
}

// Draw NPC (Minecraft villager style)
function drawVillageNPC(ctx, npc) {
  if (!npc) return;
  const sx = npc.x - cameraX;
  const sy = groundY - 28;
  const legOff = npc.animFrame === 0 ? 0 : 2;
  // Body (brown robe)
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(sx, sy + 8, 14, 14);
  // Head (skin)
  ctx.fillStyle = '#D2A679';
  ctx.fillRect(sx + 2, sy, 10, 10);
  // Nose (big villager nose)
  ctx.fillStyle = '#C49A6C';
  ctx.fillRect(sx + 5, sy + 4, 4, 4);
  // Eyes
  ctx.fillStyle = '#3E2723';
  const eyeX = npc.facingRight ? sx + 7 : sx + 3;
  ctx.fillRect(eyeX, sy + 3, 2, 2);
  // Legs
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(sx + 1 + legOff, sy + 22, 5, 6);
  ctx.fillRect(sx + 8 - legOff, sy + 22, 5, 6);
  // Speech bubble
  if (npc.showBubble) {
    const bw = 70, bh = 16;
    const bx = sx + 7 - bw / 2;
    const by = sy - bh - 6;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.beginPath();
    if (typeof ctx.roundRect === 'function') ctx.roundRect(bx, by, bw, bh, 3);
    else ctx.rect(bx, by, bw, bh);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(npc.bubbleText || '', sx + 7, by + 12);
    ctx.textAlign = 'left';
  }
}

// Main village draw function
function drawVillages(ctx) {
  if (!settings?.villageEnabled) return;
  if (!Array.isArray(activeVillages)) return;
  for (const village of activeVillages) {
    if (!village) continue;
    if (village.x + village.width < cameraX - 100) continue;
    if (village.x > cameraX + canvas.width + 100) continue;
    drawVillageBackground(ctx, village);
    drawVillagePath(ctx, village);
    drawVillageDecorations(ctx, village);
    if (Array.isArray(village.buildings)) {
      for (const building of village.buildings) {
        const colors = getVillageColors(village.biomeId);
        drawBlockHouse(ctx, building.x - cameraX, groundY - building.h, building.w, building.h, colors, building.type);
        // Draw bed next to bed_house
        if (building.type === 'bed_house') {
          drawVillageBed(ctx, building.x - cameraX + building.w + 8, groundY - 10, colors);
        }
      }
    }
    if (Array.isArray(village.npcs)) {
      for (const npc of village.npcs) drawVillageNPC(ctx, npc);
    }
    // Village name banner
    drawVillageBanner(ctx, village);
  }
}

// Draw soft background tint for village area
function drawVillageBackground(ctx, village) {
  const sx = village.x - cameraX;
  const w = village.width || 800;
  // Soft warm overlay
  ctx.fillStyle = 'rgba(255,248,225,0.12)';
  ctx.fillRect(sx, 0, w, groundY);
  // Entrance/exit pillars (stone blocks)
  const colors = getVillageColors(village.biomeId);
  const pillarH = 60;
  for (let r = 0; r < pillarH; r += 10) {
    drawBlock_village(ctx, sx, groundY - pillarH + r, 10, 10, colors.stone);
    drawBlock_village(ctx, sx + w - 10, groundY - pillarH + r, 10, 10, colors.stone);
  }
  // Torch on pillars
  ctx.fillStyle = '#FFEB3B';
  ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 250) * 0.3;
  ctx.fillRect(sx + 2, groundY - pillarH - 6, 6, 6);
  ctx.fillRect(sx + w - 8, groundY - pillarH - 6, 6, 6);
  ctx.globalAlpha = 1.0;
}

// Draw village decorations
function drawVillageDecorations(ctx, village) {
  if (!village) return;
  const colors = getVillageColors(village.biomeId);
  const vx = village.x;
  const w = village.width || 800;
  // Entrance sign
  drawVillageSign(ctx, vx + 20, village.biomeId);
  // Well in center
  drawVillageWell(ctx, vx + w / 2 - 12);
  // Lamp posts
  drawVillageLamp(ctx, vx + 160, colors);
  drawVillageLamp(ctx, vx + w - 180, colors);
  // Fences at edges
  drawVillageFence(ctx, vx + 40, colors);
  drawVillageFence(ctx, vx + w - 70, colors);
}

// Draw village name banner at top
function drawVillageBanner(ctx, village) {
  const sx = village.x - cameraX;
  const w = village.width || 800;
  const cx = sx + w / 2;
  const biomeName = typeof getBiomeName === 'function' ? getBiomeName(village.biomeId) : village.biomeId;
  const text = `ğŸ˜ï¸ ${biomeName}æ‘åº„`;
  ctx.font = `bold ${12 * (worldScale?.x || 1)}px sans-serif`;
  ctx.textAlign = 'center';
  // Background bar
  const tw = ctx.measureText(text).width + 16;
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  if (typeof ctx.roundRect === 'function') {
    ctx.beginPath();
    ctx.roundRect(cx - tw / 2, 8, tw, 22, 6);
    ctx.fill();
  } else {
    ctx.fillRect(cx - tw / 2, 8, tw, 22);
  }
  ctx.fillStyle = '#FFF';
  ctx.fillText(text, cx, 24);
  ctx.textAlign = 'left';
}

</script>
<script>
/**
 * 16-events.js - äº‹ä»¶ç»‘å®šä¸è¾“å…¥å¤„ç†
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 7076-7401)
 */
function wireSettingsModal() {
    const modal = document.getElementById("settings-modal");
    const btnOpen = document.getElementById("btn-settings");
    const btnClose = document.getElementById("btn-settings-close");
    const btnSave = document.getElementById("btn-settings-save");
    const btnResetProgress = document.getElementById("btn-reset-progress");
    const progressVocab = document.getElementById("progress-vocab");

    const optLearningMode = document.getElementById("opt-learning-mode");
    const optChallengeMode = document.getElementById("opt-challenge-mode");
    const optChallengeFrequency = document.getElementById("opt-challenge-frequency");
    const optWordCardDuration = document.getElementById("opt-word-card-duration");
    const optSpeech = document.getElementById("opt-speech");
    const optSpeechEn = document.getElementById("opt-speech-en");
    const optSpeechZh = document.getElementById("opt-speech-zh");
    const optSpeechZhEnabled = document.getElementById("opt-speech-zh-enabled");
    const optBgm = document.getElementById("opt-bgm");
    const optUiScale = document.getElementById("opt-ui-scale");
    const optMotionScale = document.getElementById("opt-motion-scale");
    const optDifficulty = document.getElementById("opt-difficulty");
    const optBiomeStep = document.getElementById("opt-biome-step");
    const optTouch = document.getElementById("opt-touch");
    const optNoRepeat = document.getElementById("opt-no-repeat");
    const optVocab = document.getElementById("opt-vocab");
    if (optVocab) {
        optVocab.addEventListener("change", () => updateVocabPreview(optVocab.value));
    }
    if (optSpeechZhEnabled && optSpeechZh) {
        optSpeechZhEnabled.addEventListener("change", () => {
            optSpeechZh.disabled = !optSpeechZhEnabled.checked;
        });
    }
    const optShowImage = document.getElementById("opt-show-image");
    const optWordGate = document.getElementById("opt-word-gate");
    const optWordMatch = document.getElementById("opt-word-match");
    const optSpeed = document.getElementById("opt-speed");
    const optKeys = document.getElementById("opt-keys");
    let resetArmed = false;
    let resetTimer = null;

    function fill() {
        if (optLearningMode) optLearningMode.checked = !!settings.learningMode;
        if (optChallengeMode) optChallengeMode.checked = !!settings.challengeEnabled;
        if (optChallengeFrequency) {
            const currentFreq = Number(settings.challengeFrequency ?? 0.3);
            const options = [0.15, 0.3, 0.5];
            const closest = options.reduce((a, b) =>
                Math.abs(b - currentFreq) < Math.abs(a - currentFreq) ? b : a
            );
            optChallengeFrequency.value = String(closest);
        }
        if (optWordCardDuration) optWordCardDuration.value = String(settings.wordCardDuration || 900);
        if (optSpeech) optSpeech.checked = !!settings.speechEnabled;
        if (optSpeechEn) optSpeechEn.value = String(settings.speechEnRate ?? 0.8);
        if (optSpeechZh) optSpeechZh.value = String(settings.speechZhRate ?? 0.9);
        if (optSpeechZhEnabled) optSpeechZhEnabled.checked = !!settings.speechZhEnabled;
        if (optSpeechZh) optSpeechZh.disabled = !settings.speechZhEnabled;
        if (optBgm) optBgm.checked = !!settings.musicEnabled;
        if (optUiScale) optUiScale.value = String(settings.uiScale ?? 1.0);
        if (optMotionScale) optMotionScale.value = String(settings.motionScale ?? 1.25);
        if (optDifficulty) {
            const desired = settings.difficultySelection || "auto";
            optDifficulty.value = desired;
            if (optDifficulty.value !== desired) optDifficulty.value = "auto";
        }
        if (optBiomeStep) optBiomeStep.value = String(settings.biomeSwitchStepScore ?? 200);
        if (optTouch) optTouch.checked = !!settings.touchControls;
        if (optNoRepeat) optNoRepeat.checked = !!settings.avoidWordRepeats;
        if (optShowImage) optShowImage.checked = !!settings.showWordImage;
        if (optVocab) optVocab.value = settings.vocabSelection || "auto";
        if (optWordGate) optWordGate.checked = !!settings.wordGateEnabled;
        if (optWordMatch) optWordMatch.checked = !!settings.wordMatchEnabled;
        if (optSpeed) optSpeed.value = settings.movementSpeedLevel || "normal";
        if (optKeys) optKeys.value = settings.keyCodes || [keyBindings.jump, keyBindings.attack, keyBindings.interact, keyBindings.switch, keyBindings.useDiamond].join(",");
        if (progressVocab) updateVocabProgressUI();
        if (optVocab) updateVocabPreview(optVocab.value);
    }

    function open() {
        if (!modal) return;
        pausedByModal = !paused;
        paused = true;
        fill();
        modal.classList.add("visible");
        modal.setAttribute("aria-hidden", "false");
    }

    function close() {
        if (!modal) return;
        modal.classList.remove("visible");
        modal.setAttribute("aria-hidden", "true");
        if (pausedByModal) paused = false;
        pausedByModal = false;
    }

    function resetProgress() {
        resetVocabRotationAndProgress();
    }

    async function save() {
        if (optLearningMode) settings.learningMode = !!optLearningMode.checked;
        if (optChallengeMode) settings.challengeEnabled = !!optChallengeMode.checked;
        if (optChallengeFrequency) settings.challengeFrequency = Number(optChallengeFrequency.value) || 0.3;
        if (optWordCardDuration) settings.wordCardDuration = Number(optWordCardDuration.value) || 900;
        if (optSpeech) settings.speechEnabled = !!optSpeech.checked;
        if (optSpeechEn) settings.speechEnRate = Number(optSpeechEn.value);
        if (optSpeechZh) settings.speechZhRate = Number(optSpeechZh.value);
        if (optSpeechZhEnabled) settings.speechZhEnabled = !!optSpeechZhEnabled.checked;
        if (optBgm) settings.musicEnabled = !!optBgm.checked;
        if (optUiScale) settings.uiScale = Number(optUiScale.value);
        if (optMotionScale) settings.motionScale = Number(optMotionScale.value);
        if (optDifficulty) settings.difficultySelection = String(optDifficulty.value || "auto");
        if (optBiomeStep) settings.biomeSwitchStepScore = Number(optBiomeStep.value);
        if (optTouch) settings.touchControls = !!optTouch.checked;
        if (optNoRepeat) settings.avoidWordRepeats = !!optNoRepeat.checked;
        if (optShowImage) settings.showWordImage = !!optShowImage.checked;
        if (optVocab) settings.vocabSelection = String(optVocab.value || "auto");
        if (optWordGate) settings.wordGateEnabled = !!optWordGate.checked;
        if (optWordMatch) settings.wordMatchEnabled = !!optWordMatch.checked;
        if (optSpeed) settings.movementSpeedLevel = String(optSpeed.value || "normal");
        if (optKeys) settings.keyCodes = String(optKeys.value || "");

        settings = normalizeSettings(settings);
        const parsed = parseKeyCodes(settings.keyCodes);
        if (parsed) {
            keyBindings.jump = parsed[0];
            keyBindings.attack = parsed[1];
            keyBindings.interact = parsed[2];
            keyBindings.switch = parsed[3];
            keyBindings.useDiamond = parsed[4];
        }

        wordPicker = null;
        applyBgmSetting();
        saveSettings();
        applySettingsToUI();
        // Apply selected difficulty immediately (even while paused in settings).
        difficultyState = null;
        updateDifficultyState(true);
        if (player) {
            applyMotionToPlayer(player);
            applyBiomeEffectsToPlayer();
        }
        await setActiveVocabPack(settings.vocabSelection || "auto");
        clearOldWordItems();
        spawnWordItemNearPlayer();
        showVocabSwitchEffect();
        updateVocabPreview(settings.vocabSelection);
        close();
    }

    if (btnOpen) btnOpen.addEventListener("click", open);
    if (btnClose) btnClose.addEventListener("click", close);
    if (btnSave) btnSave.addEventListener("click", save);
    if (btnResetProgress) {
        btnResetProgress.addEventListener("click", () => {
            if (!resetArmed) {
                resetArmed = true;
                btnResetProgress.innerText = "å†ç‚¹ä¸€æ¬¡ç¡®è®¤";
                if (resetTimer) clearTimeout(resetTimer);
                resetTimer = setTimeout(() => {
                    resetArmed = false;
                    btnResetProgress.innerText = "é‡ç½®è½®æ¢";
                }, 2000);
                return;
            }
            resetArmed = false;
            if (resetTimer) clearTimeout(resetTimer);
            btnResetProgress.innerText = "é‡ç½®è½®æ¢";
            resetProgress();
        });
    }
    if (modal) {
        modal.addEventListener("click", e => {
            if (e.target === modal) close();
        });
    }
}

function wireHudButtons() {
    const btnMix = document.getElementById("btn-repeat-pause");
    if (btnMix) {
        btnMix.addEventListener("click", () => {
            if (repeatPauseState === "repeat") {
                if (lastWord) speakWord(lastWord);
                repeatPauseState = "pause";
                btnMix.innerText = "â¸ æš‚åœ";
                return;
            }
            paused = !paused;
            if (paused && startedOnce) setOverlay(true, "pause");
            if (!paused) setOverlay(false);
            repeatPauseState = "repeat";
            btnMix.innerText = "ğŸ”Š é‡è¯»";
        });
    }

    const btnSummon = document.getElementById("btn-summon-golem");
    if (btnSummon) {
        btnSummon.addEventListener("click", () => {
            if (inventory.iron >= 10) {
                tryCraft("iron_golem");
            } else if (inventory.pumpkin >= 10) {
                tryCraft("snow_golem");
            } else {
                showToast("ææ–™ä¸è¶³ï¼éœ€è¦ 10 ä¸ªé“å—æˆ–å—ç“œ");
            }
        });
    }
    const btnProfile = document.getElementById("btn-profile");
    if (btnProfile) {
        btnProfile.addEventListener("click", showProfileModal);
    }
    const armorBadge = document.getElementById("armor-status");
    if (armorBadge) {
        armorBadge.addEventListener("click", () => {
            showArmorSelectUI();
        });
    }
    const invBadge = document.getElementById("inventory-status");
    if (invBadge) {
        invBadge.addEventListener("click", () => {
            showInventoryModal();
        });
    }
}

function wireArmorModal() {
    const modal = document.getElementById("armor-select-modal");
    const btnClose = document.getElementById("btn-armor-close");
    if (btnClose) btnClose.addEventListener("click", hideArmorSelectUI);
    if (modal) {
        modal.addEventListener("click", e => {
            if (e.target === modal) hideArmorSelectUI();
        });
    }
}

function wireInventoryModal() {
    inventoryModalEl = document.getElementById("inventory-modal");
    inventoryContentEl = document.getElementById("inventory-content");
    inventoryTabButtons = Array.from(document.querySelectorAll(".inventory-tab"));
    const btnClose = document.getElementById("btn-inventory-close");
    if (btnClose) btnClose.addEventListener("click", hideInventoryModal);
    if (inventoryTabButtons) {
        inventoryTabButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                setInventoryTab(btn.dataset.tab || "items");
            });
        });
    }
    if (inventoryModalEl) {
        inventoryModalEl.addEventListener("click", e => {
            if (e.target === inventoryModalEl) hideInventoryModal();
        });
    }
}

function wireTouchControls() {
    const root = document.getElementById("touch-controls");
    if (!root) return;

    function bindHold(action, onDown, onUp) {
        const btn = root.querySelector(`[data-action="${action}"]`);
        if (!btn) return;
        btn.addEventListener("pointerdown", e => {
            e.preventDefault();
            btn.setPointerCapture(e.pointerId);
            onDown();
        }, { passive: false });
        btn.addEventListener("pointerup", e => {
            e.preventDefault();
            onUp();
        }, { passive: false });
        btn.addEventListener("pointercancel", e => {
            e.preventDefault();
            onUp();
        }, { passive: false });
        btn.addEventListener("lostpointercapture", () => onUp());
    }

    function bindTap(action, fn) {
        const btn = root.querySelector(`[data-action="${action}"]`);
        if (!btn) return;
        btn.addEventListener("pointerdown", e => {
            e.preventDefault();
            fn();
        }, { passive: false });
    }

    bindHold("left", () => { keys.left = true; }, () => { keys.left = false; });
    bindHold("right", () => { keys.right = true; }, () => { keys.right = false; });
    bindTap("jump", () => { jumpBuffer = gameConfig.jump.bufferFrames; });
    bindTap("attack", () => { handleAttack("tap"); });
    bindTap("interact", () => { handleInteraction(); });
    bindTap("switch", () => { switchWeapon(); });
    bindTap("use-diamond", () => { useDiamondForHp(); });
}

function wireLearningModals() {
    challengeModalEl = document.getElementById("challenge-modal");
    challengeQuestionEl = document.getElementById("challenge-question");
    challengeOptionsEl = document.getElementById("challenge-options");
    challengeInputWrapperEl = document.getElementById("challenge-input-wrapper");
    challengeInputEl = document.getElementById("challenge-input");
    challengeTimerEl = document.getElementById("challenge-timer");
    challengeRepeatBtn = document.getElementById("challenge-repeat");
    wordMatchScreenEl = document.getElementById("word-match-screen");
    matchLeftEl = document.getElementById("match-left");
    matchRightEl = document.getElementById("match-right");
    matchLinesEl = document.getElementById("match-lines");
    matchCountEl = document.getElementById("match-count");
    matchTotalEl = document.getElementById("match-total");
    matchResultEl = document.getElementById("match-result");
    matchSubtitleEl = document.getElementById("match-subtitle");
    matchTimerEl = document.getElementById("match-timer");
    matchSubmitBtn = document.getElementById("btn-match-submit");

    // === v1.6.4 æ–°å¢ï¼šå•è¯æœ¬æŒ‰é’®äº‹ä»¶ç»‘å®š ===
    const btnVocabBook = document.getElementById("btn-vocab-book");
    if (btnVocabBook) {
        btnVocabBook.addEventListener("click", () => {
            showVocabBook();
        });
    }

    const btnCloseVocabBook = document.getElementById("btn-close-vocab-book");
    if (btnCloseVocabBook) {
        btnCloseVocabBook.addEventListener("click", () => {
            hideVocabBook();
        });
    }

    const vocabBookModal = document.getElementById("vocab-book-modal");
    if (vocabBookModal) {
        vocabBookModal.addEventListener("click", e => {
            if (e.target === vocabBookModal) hideVocabBook();
        });
    }

    if (challengeRepeatBtn) {
        challengeRepeatBtn.addEventListener("click", () => {
            if (currentLearningChallenge?.wordObj) {
                speakWord(currentLearningChallenge.wordObj);
            }
        });
    }
    if (challengeInputEl) {
        challengeInputEl.addEventListener("keydown", e => {
            if (e.key === "Enter") {
                e.preventDefault();
                const userAnswer = (challengeInputEl.value || "").trim().toLowerCase();
                const target = (currentLearningChallenge?.answer || "").toLowerCase();
                completeLearningChallenge(userAnswer === target);
            }
        });
    }
    if (matchSubmitBtn) {
        matchSubmitBtn.addEventListener("click", () => {
            activeWordMatch?.submit();
        });
    }
}

</script>
<script>
/**
 * 17-bootstrap.js - å¯åŠ¨å…¥å£ä¸æµ‹è¯•API
 * ä» main.js æ‹†åˆ† (åŸå§‹è¡Œ 7402-7663)
 */
async function start() {
    const [loadedGame, loadedControls, loadedLevels, loadedWords, loadedBiomes, loadedVillage] = await Promise.all([
        loadJsonWithFallback("config/game.json", defaultGameConfig),
        loadJsonWithFallback("config/controls.json", defaultControls),
        loadJsonWithFallback("config/levels.json", defaultLevels),
        loadJsonWithFallback("words/words-base.json", defaultWords),
        loadJsonWithFallback("config/biomes.json", { switch: DEFAULT_BIOME_SWITCH, biomes: DEFAULT_BIOME_CONFIGS }),
        loadJsonWithFallback("config/village.json", { enabled: true, spawnScoreInterval: 500 })
    ]);

    gameConfig = mergeDeep(defaultGameConfig, loadedGame);
    difficultyConfigCache = null;
    lootConfigCache = null;
    keyBindings = { ...defaultControls, ...(loadedControls || {}) };
    levels = Array.isArray(loadedLevels) && loadedLevels.length ? loadedLevels : defaultLevels;
    wordDatabase = Array.isArray(loadedWords) && loadedWords.length ? loadedWords : defaultWords;
    const bundle = normalizeBiomeBundle(loadedBiomes);
    biomeConfigs = bundle.biomes;
    biomeSwitchConfig = bundle.switch;
    if (typeof villageConfig !== 'undefined') villageConfig = loadedVillage || {};
    baseGameConfig = JSON.parse(JSON.stringify(gameConfig));
    baseCanvasSize = { width: baseGameConfig.canvas.width, height: baseGameConfig.canvas.height };
    baseEnemyStats = JSON.parse(JSON.stringify(ENEMY_STATS));
    baseWeapons = JSON.parse(JSON.stringify(WEAPONS));
    baseBiomeConfigs = JSON.parse(JSON.stringify(biomeConfigs));
    baseCloudPlatformConfig = typeof CLOUD_PLATFORM_CONFIG === "undefined"
        ? null
        : JSON.parse(JSON.stringify(CLOUD_PLATFORM_CONFIG));
    settings = normalizeSettings(settings);
    const parsed = parseKeyCodes(settings.keyCodes);
    if (parsed) {
        keyBindings.jump = parsed[0];
        keyBindings.attack = parsed[1];
        keyBindings.interact = parsed[2];
        keyBindings.switch = parsed[3];
        keyBindings.useDiamond = parsed[4];
    }

    wireAudioUnlock();
    applyBgmSetting();

    applySettingsToUI();
    window.addEventListener("resize", scheduleApplySettingsToUI);
    window.addEventListener("orientationchange", scheduleApplySettingsToUI);
    if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", scheduleApplySettingsToUI, { passive: true });
        // Some mobile browsers only update visual viewport via scroll when the URL bar collapses/expands.
        window.visualViewport.addEventListener("scroll", scheduleApplySettingsToUI, { passive: true });
    }
    ensureVocabEngine();
    renderVocabSelect();
    await setActiveVocabPack(settings.vocabSelection || "auto");
    wireHudButtons();
    wireArmorModal();
    wireInventoryModal();
    wireProfileModal();
    wireSettingsModal();
    wireLearningModals();
    wireTouchControls();
    await initLoginScreen();

    const overlayBtn = document.getElementById("btn-overlay-action");
    if (overlayBtn) {
        overlayBtn.addEventListener("click", resumeGameFromOverlay);
        overlayBtn.addEventListener("pointerdown", e => {
            e.preventDefault();
            resumeGameFromOverlay();
        }, { passive: false });
    }
    const overlayScorebtn = document.getElementById("btn-overlay-score-revive");
    if (overlayScorebtn) {
        overlayScorebtn.addEventListener("click", () => {
            reviveWithScore();
        });
    }
    const overlay = document.getElementById("screen-overlay");
    if (overlay) {
        overlay.addEventListener("click", e => { if (e.target === overlay) resumeGameFromOverlay(); });
        overlay.addEventListener("pointerdown", e => {
            if (e.target !== overlay) return;
            e.preventDefault();
            resumeGameFromOverlay();
        }, { passive: false });
    }

    function matchesBinding(e, binding) {
        if (!binding) return false;
        if (e.code === binding || e.key === binding) return true;
        const k = String(e.key || "");
        if (binding === "Space") return e.code === "Space" || k === " " || k === "Spacebar";
        if (binding.startsWith("Key") && binding.length === 4) {
            return e.code === binding || k.toLowerCase() === binding.slice(3).toLowerCase();
        }
        return false;
    }

    window.addEventListener("keydown", e => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
        const isJump = matchesBinding(e, keyBindings.jump) || e.code === "ArrowUp" || e.code === "Space";
        const isRight = matchesBinding(e, keyBindings.right) || e.code === "ArrowRight" || e.key === "ArrowRight";
        const isLeft = matchesBinding(e, keyBindings.left) || e.code === "ArrowLeft" || e.key === "ArrowLeft";
        const isAttack = matchesBinding(e, keyBindings.attack) || String(e.key || "").toLowerCase() === "j";
        const isWeaponSwitch = matchesBinding(e, keyBindings.switch) || String(e.key || "").toLowerCase() === "k";
        const isInteract = matchesBinding(e, keyBindings.interact) || String(e.key || "").toLowerCase() === "y";
        const isUseDiamond = matchesBinding(e, keyBindings.useDiamond) || String(e.key || "").toLowerCase() === "z";
        const isDecorInteract = String(e.key || "").toLowerCase() === "e";
        const isPause = e.code === "Escape";
        const tag = e.target && e.target.tagName ? e.target.tagName.toUpperCase() : "";
        const inInput = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
        if (isJump) {
            if (!e.repeat) {
                jumpBuffer = gameConfig.jump.bufferFrames;
            }
        }
        if (isRight) keys.right = true;
        if (isLeft) keys.left = true;
        if (isAttack) handleAttack("press");
        if (isWeaponSwitch) switchWeapon();
        if (isUseDiamond) useDiamondForHp();
        if (isInteract) handleInteraction();
        if (isDecorInteract) handleDecorationInteract();
        if (!inInput && e.key >= "1" && e.key <= "9") {
            selectedSlot = parseInt(e.key, 10) - 1;
            updateInventoryUI();
            const itemKey = HOTBAR_ITEMS[selectedSlot];
            showToast(`é€‰æ‹©: ${ITEM_LABELS[itemKey] || itemKey || "ç©º"}`);
        }
        if (!inInput && String(e.key || "").toLowerCase() === "x" && !paused) {
            if (inventory.iron >= 10) {
                tryCraft("iron_golem");
            } else if (inventory.pumpkin >= 10) {
                tryCraft("snow_golem");
            } else {
                showToast("ææ–™ä¸è¶³ï¼éœ€è¦ 10 ä¸ªé“å—æˆ–å—ç“œ");
            }
        }
        if (isPause && startedOnce) {
            paused = !paused;
            const btnPause = document.getElementById("btn-pause");
            if (btnPause) btnPause.innerText = paused ? "â–¶ï¸ ç»§ç»­" : "â¸ æš‚åœ";
            if (paused) setOverlay(true, "pause");
            else setOverlay(false);
        }
    });

    window.addEventListener("keyup", e => {
        const isRight = matchesBinding(e, keyBindings.right) || e.code === "ArrowRight" || e.key === "ArrowRight";
        const isLeft = matchesBinding(e, keyBindings.left) || e.code === "ArrowLeft" || e.key === "ArrowLeft";
        const isAttack = matchesBinding(e, keyBindings.attack) || String(e.key || "").toLowerCase() === "j";
        if (isRight) keys.right = false;
        if (isLeft) keys.left = false;
        if (isAttack) handleAttackRelease();
    });

    window.addEventListener("blur", () => { keys.right = false; keys.left = false; });
    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            if (bgmAudio && !bgmAudio.paused) {
                bgmPausedByVisibility = true;
                try { bgmAudio.pause(); } catch {}
            }
        } else if (bgmPausedByVisibility) {
            bgmPausedByVisibility = false;
            applyBgmSetting();
        }

        if (!startedOnce) return;
        if (document.hidden) {
            paused = true;
            const btnPause = document.getElementById("btn-pause");
            if (btnPause) btnPause.innerText = "â–¶ï¸ ç»§ç»­";
            if (!pausedByModal) setOverlay(true, "pause");
        }
    });

    bootReady = true;
    const loginVisible = document.getElementById("login-screen")?.classList.contains("visible");
    if (!loginVisible) {
        bootGameLoopIfNeeded();
    }
    return;
}

start();

// Minimal test hook for Playwright. Kept small to avoid coupling gameplay to tests.
// (Top-level `let` bindings are not readable from Playwright `page.evaluate()`, so expose closures instead.)
function registerTestApi() {
    if (typeof window === "undefined") return;
    if (window.MMWG_TEST_API) return;

    window.MMWG_TEST_API = {
        getState() {
            return {
                paused,
                pausedByModal,
                startedOnce,
                bootReady,
                score,
                levelScore,
                playerHp,
                playerMaxHp,
                playerInvincibleTimer,
                settings: settings ? { ...settings } : null,
                activeVocabPackId: activeVocabPackId || null,
                wordCount: Array.isArray(wordDatabase) ? wordDatabase.length : 0,
                wordItemsCount: Array.isArray(items) ? items.filter(i => i && i.wordObj).length : 0,
                movementSpeed: gameConfig?.physics?.movementSpeed ?? null,
                golemCount: Array.isArray(golems) ? golems.length : 0,
                firstGolemFollowDelay: Array.isArray(golems) && golems[0] ? (golems[0].followDelay ?? null) : null,
                inventory: inventory ? { ...inventory } : null,
                equipment: playerEquipment ? { ...playerEquipment } : null,
                armorInventory: Array.isArray(armorInventory) ? [...armorInventory] : null,
                currentAccount: currentAccount ? { id: currentAccount.id, username: currentAccount.username } : null
            };
        },
        setState(patch) {
            if (!patch || typeof patch !== "object") return;
            if (typeof patch.score === "number") score = patch.score;
            if (typeof patch.levelScore === "number") levelScore = patch.levelScore;
            if (typeof patch.paused === "boolean") paused = patch.paused;
            if (typeof patch.pausedByModal === "boolean") pausedByModal = patch.pausedByModal;
            if (typeof patch.playerHp === "number") playerHp = patch.playerHp;
            if (typeof patch.playerMaxHp === "number") playerMaxHp = patch.playerMaxHp;
            if (typeof patch.playerInvincibleTimer === "number") playerInvincibleTimer = patch.playerInvincibleTimer;
            if (patch.settings && typeof patch.settings === "object") {
                settings = normalizeSettings({ ...settings, ...patch.settings });
                saveSettings();
                applySettingsToUI();
            }
            if (patch.inventory && typeof patch.inventory === "object" && inventory) {
                inventory = { ...inventory, ...patch.inventory };
                updateInventoryUI();
            }
            if (patch.equipment && typeof patch.equipment === "object" && playerEquipment) {
                playerEquipment = { ...playerEquipment, ...patch.equipment };
                updateArmorUI();
            }
            if (Array.isArray(patch.armorInventory)) {
                armorInventory = patch.armorInventory.map(a => ({ id: a.id, durability: a.durability }));
                updateArmorUI();
            }
        },
        actions: {
            bootGameLoopIfNeeded,
            loginWithAccount,
            reviveWithScore,
            setActiveVocabPack,
            clearOldWordItems,
            equipArmor,
            unequipArmor,
            applySpeedSetting,
            spawnWordItemNearPlayer,
            tryCraft,
            saveCurrentProgress,
            updateInventoryUI,
            updateArmorUI,
            updateVocabProgressUI
        }
    };
}

registerTestApi();

</script>
</body>
</html>
