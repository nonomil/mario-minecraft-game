# v1.13.0 — 学习算法与题型增强

> **优先级**: P1
> **版本号**: 1.13.0 / versionCode: 91
> **前置版本**: v1.12.0（学习反馈核心优化完成）
> **预期效果**: 间隔复习区分答题质量、难度曲线平滑过渡、新增多字母填空和字母排序题型

---

## 问题描述

1. **间隔复习不区分答题质量**：`11-game-init.js:113` 的 `buildWordPicker()` 使用固定间隔数组 `[0, 3, 10, 28, 80, 220]`，所有单词无论答对答错都用同一间隔，答错的词没有更频繁地复现。
2. **难度跳变明显**：`05-difficulty.js:16-28` 使用阶梯式 tier 查找，5 个固定档位在边界处（如 499→500 分）参数突变，玩家体验不连贯。
3. **题型单一**：`12-challenges.js:112` 的 `generateFillBlankChallenge()` 只隐藏单个字母，长期游玩后缺乏新鲜感。

---

## 修改清单

### Step 1: 增强间隔复习算法

#### 文件 A: `src/modules/11-game-init.js`

**位置**: `buildWordPicker()` 函数（约第 109 行）

**当前代码**（核心部分）:
```javascript
const intervals = [0, 3, 10, 28, 80, 220];
const stats = Object.create(null);
```

**改为**:
```javascript
// 根据答题质量选择不同间隔表
const INTERVALS = {
    correct_fast: [0, 5, 15, 40, 120, 300],   // 秒答 → 间隔拉长
    correct_slow: [0, 3, 10, 28, 80, 220],     // 犹豫答对 → 保持原有
    wrong:        [0, 1, 3, 8, 20, 60]          // 答错 → 间隔缩短，频繁复现
};
const stats = Object.create(null);
// stats[en] = { count: number, quality: "correct_fast"|"correct_slow"|"wrong" }
```

**操作详解**:

1. 将 `stats[en]` 从简单计数改为对象结构:
```javascript
// 原来: stats[en] = (stats[en] || 0) + 1;
// 改为:
if (!stats[en]) stats[en] = { count: 0, quality: "correct_slow" };
stats[en].count++;
```

2. `next()` 选词时根据 quality 选择间隔表:
```javascript
// 原来: due[en] = tick + intervals[Math.min(stats[en], intervals.length - 1)];
// 改为:
const q = stats[en]?.quality || "correct_slow";
const ivl = INTERVALS[q] || INTERVALS.correct_slow;
due[en] = tick + ivl[Math.min(stats[en].count, ivl.length - 1)];
```

3. 新增 `updateWordQuality(en, quality)` 方法供外部调用:
```javascript
return {
    next(excludeSet) { /* ... 现有逻辑，用上述改法 ... */ },
    updateWordQuality(en, quality) {
        if (!stats[en]) stats[en] = { count: 0, quality: "correct_slow" };
        stats[en].quality = quality;
        // 答错时立即将 due 设为当前 tick，使其尽快复现
        if (quality === "wrong") {
            due[en] = tick;
        }
    }
};
```

#### 文件 B: `src/modules/12-challenges.js`

**位置**: `completeLearningChallenge()` 函数（v1.12.0 改造后的版本）

**操作**: 在答题完成时调用 `wordPicker.updateWordQuality()`。

在 `correct` 分支中添加:
```javascript
if (correct) {
    // 判断答题速度：挑战开始时间 vs 当前时间
    const elapsed = Date.now() - (challengeDeadline - (LEARNING_CONFIG.challenge.timeLimit || 10000));
    const isFast = elapsed < 3000; // 3 秒内答对算"秒答"
    if (wordPicker && wordPicker.updateWordQuality) {
        wordPicker.updateWordQuality(wordObj.en, isFast ? "correct_fast" : "correct_slow");
    }
    // ... 现有正确逻辑
}
```

在 `else`（答错）分支中添加:
```javascript
if (wordPicker && wordPicker.updateWordQuality) {
    wordPicker.updateWordQuality(wordObj.en, "wrong");
}
```

**验证**: 答错的单词应在 1-3 次其他单词后再次出现；秒答的单词间隔明显拉长。

---

### Step 2: 难度曲线平滑化

#### 文件: `src/modules/05-difficulty.js`

**位置**: `computeDifficultyState()` 函数（约第 31 行）

**当前代码**:
```javascript
function computeDifficultyState() {
    const cfg = getDifficultyConfig();
    const tier = getDifficultyTier(getProgressScore());
    const dda = cfg.dda || {};
    let enemyDamageMult = Number(tier.enemyDamage) || 1;
    let enemyHpMult = Number(tier.enemyHp) || 1;
    let enemySpawnMult = Number(tier.enemySpawn) || 1;
    let chestSpawnMult = Number(tier.chestSpawn) || 1;
    // ...
}
```

**改为**（在 `const tier = ...` 之后，`const dda = ...` 之前插入插值逻辑）:
```javascript
function computeDifficultyState() {
    const cfg = getDifficultyConfig();
    const tiers = Array.isArray(cfg.tiers) ? cfg.tiers : [];
    const s = getProgressScore();
    const tier = getDifficultyTier(s);
    const dda = cfg.dda || {};

    let enemyDamageMult, enemyHpMult, enemySpawnMult, chestSpawnMult;
    let chestRareBoost, chestRollBonus;

    // 手动选择难度时保持原逻辑（不插值）
    const selected = String(settings?.difficultySelection || "auto");
    const tierIdx = tiers.indexOf(tier);
    const nextTier = tierIdx >= 0 ? tiers[tierIdx + 1] : null;

    if (selected === "auto" && nextTier && (tier.maxScore ?? 999999) < 999999) {
        // 自动难度：在相邻 tier 之间线性插值
        const range = (tier.maxScore ?? 999999) - (tier.minScore ?? 0);
        const t = range > 0 ? (s - (tier.minScore ?? 0)) / range : 0;
        enemyDamageMult = (Number(tier.enemyDamage) || 1) +
            ((Number(nextTier.enemyDamage) || 1) - (Number(tier.enemyDamage) || 1)) * t;
        enemyHpMult = (Number(tier.enemyHp) || 1) +
            ((Number(nextTier.enemyHp) || 1) - (Number(tier.enemyHp) || 1)) * t;
        enemySpawnMult = (Number(tier.enemySpawn) || 1) +
            ((Number(nextTier.enemySpawn) || 1) - (Number(tier.enemySpawn) || 1)) * t;
        chestSpawnMult = (Number(tier.chestSpawn) || 1) +
            ((Number(nextTier.chestSpawn) || 1) - (Number(tier.chestSpawn) || 1)) * t;
    } else {
        // 最高/最低 tier 或手动选择：保持原值
        enemyDamageMult = Number(tier.enemyDamage) || 1;
        enemyHpMult = Number(tier.enemyHp) || 1;
        enemySpawnMult = Number(tier.enemySpawn) || 1;
        chestSpawnMult = Number(tier.chestSpawn) || 1;
    }
    chestRareBoost = Number(tier.chestRareBoost) || 0;
    chestRollBonus = Number(tier.chestRollBonus) || 0;
    const scoreMultiplier = Number(tier.scoreMultiplier) || 1;

    // 以下 learningMode + DDA 叠加逻辑不变 ...
```

**注意**: 不改 `game.json` 中的 tier 定义，只改计算逻辑。手动选择难度时完全不受影响。

**验证**: 在 499 分和 501 分时，敌人伤害应接近而非突变。可用调试工具设置分数观察。

---

### Step 3: 拼写练习多样化

#### 文件: `src/modules/12-challenges.js`

**位置**: `CHALLENGE_TYPES` 对象和 `CHALLENGE_TYPE_KEYS` 数组（约第 135-159 行）

**操作 A**: 新增 `generateMultiBlankChallenge()` 函数（在 `generateFillBlankChallenge` 下方）:

```javascript
function generateMultiBlankChallenge(wordObj) {
    const enRaw = String(wordObj?.en || "").toLowerCase();
    const en = enRaw.replace(/[^a-z]/g, "");
    if (en.length < 4) return generateFillBlankChallenge(wordObj); // 短词退回单字母
    const blankCount = Math.min(2, Math.floor(en.length / 3));
    // 随机选 blankCount 个不相邻位置隐藏
    const positions = [];
    const available = [];
    for (let i = 1; i < en.length - 1; i++) available.push(i);
    for (let b = 0; b < blankCount && available.length > 0; b++) {
        const idx = Math.floor(Math.random() * available.length);
        const pos = available[idx];
        positions.push(pos);
        // 移除相邻位置，防止连续空格
        available.splice(idx, 1);
        const adjIdx = available.indexOf(pos - 1);
        if (adjIdx >= 0) available.splice(adjIdx, 1);
        const adjIdx2 = available.indexOf(pos + 1);
        if (adjIdx2 >= 0) available.splice(adjIdx2, 1);
    }
    positions.sort((a, b) => a - b);
    const missingLetters = positions.map(i => en[i]);
    const wordDisplay = en.split("").map((ch, i) =>
        positions.includes(i) ? "_" : ch
    ).join(" ");
    // 选项为字母组合（正确答案 + 干扰项）
    const correctAnswer = missingLetters.join("");
    const options = [correctAnswer];
    while (options.length < 4) {
        const fake = missingLetters.map(() => {
            const all = "abcdefghijklmnopqrstuvwxyz";
            return all[Math.floor(Math.random() * 26)];
        }).join("");
        if (!options.includes(fake)) options.push(fake);
    }
    return {
        mode: "fill_blank",
        questionHtml:
            `<div class="challenge-fill">` +
            `<div class="challenge-fill-word">${wordDisplay}</div>` +
            `<div class="challenge-fill-hint">填入缺少的 ${blankCount} 个字母</div>` +
            `<div class="challenge-fill-zh">${wordObj?.zh || ""}</div>` +
            `</div>`,
        options: shuffle(options).map(opt => ({
            text: opt, value: opt, correct: opt === correctAnswer
        })),
        answer: correctAnswer
    };
}
```

**操作 B**: 新增 `generateUnscrambleChallenge()` 函数:

```javascript
function generateUnscrambleChallenge(wordObj) {
    const enRaw = String(wordObj?.en || "").toLowerCase();
    const en = enRaw.replace(/[^a-z]/g, "");
    if (en.length < 3) return generateFillBlankChallenge(wordObj);
    // 打乱字母顺序
    let scrambled = shuffle(en.split(""));
    // 确保打乱后与原词不同
    let tries = 0;
    while (scrambled.join("") === en && tries < 10) {
        scrambled = shuffle(en.split(""));
        tries++;
    }
    return {
        mode: "fill_blank",
        questionHtml:
            `<div class="challenge-fill">` +
            `<div class="challenge-fill-word" style="letter-spacing:8px; color:#FFD54F;">` +
            `${scrambled.join(" ")}</div>` +
            `<div class="challenge-fill-hint">重新排列字母，拼出正确单词</div>` +
            `<div class="challenge-fill-zh">${wordObj?.zh || ""}</div>` +
            `</div>`,
        options: shuffle([
            { text: en, value: en, correct: true },
            ...generateScrambleDistractors(en, 3)
        ]),
        answer: en
    };
}

function generateScrambleDistractors(en, count) {
    const distractors = [];
    const pool = Array.isArray(wordDatabase) ? wordDatabase : [];
    const candidates = pool.filter(w => w.en && w.en !== en && Math.abs(w.en.length - en.length) <= 2);
    const picked = shuffle(candidates).slice(0, count);
    picked.forEach(w => {
        distractors.push({ text: w.en.toLowerCase(), value: w.en.toLowerCase(), correct: false });
    });
    // 补足不够的
    while (distractors.length < count) {
        const fake = shuffle(en.split("")).join("");
        if (fake !== en && !distractors.find(d => d.text === fake)) {
            distractors.push({ text: fake, value: fake, correct: false });
        }
    }
    return distractors;
}
```

**操作 C**: 注册新题型到 `CHALLENGE_TYPES` 和 `CHALLENGE_TYPE_KEYS`:

```javascript
// 在现有 CHALLENGE_TYPES 对象中追加:
CHALLENGE_TYPES.multi_blank = function(wordObj) {
    return generateMultiBlankChallenge(wordObj);
};
CHALLENGE_TYPES.unscramble = function(wordObj) {
    return generateUnscrambleChallenge(wordObj);
};

// 在 CHALLENGE_TYPE_KEYS 数组中追加:
CHALLENGE_TYPE_KEYS.push("multi_blank", "unscramble");
```

**验证**: 游戏中触发挑战时，应随机出现 5 种题型（translate、listen、fill_blank、multi_blank、unscramble）。

---

## 验证步骤

### A. 间隔复习验证

1. 连续收集单词，故意答错某个词。
2. 观察该词是否在 1-3 次后再次出现（而非等到原间隔）。
3. 快速答对的词应间隔更长才再次出现。

### B. 难度曲线验证

1. 使用调试工具设置分数为 490、500、510。
2. 观察敌人伤害/生命值是否平滑过渡（而非在 500 分突变）。
3. 手动选择固定难度时，确认不受插值影响。

### C. 新题型验证

1. 多字母填空：长单词（4+ 字母）应出现 2 个空格，选项为字母组合。
2. 字母排序：显示打乱的字母，选项为 4 个单词（含正确答案）。
3. 短单词（< 4 字母）应退回单字母填空。

### D. 回归验证（必须）

1. 首页首次进入与重进后地面持续可见。
2. 触控按钮不丢失响应。
3. BOSS 与村庄触发链路不回归。
4. v1.12.0 的答错反馈、例句展示、学习模式重试功能正常。

---

## 版本发布步骤

```bash
# 1. 更新版本号
# apk/package.json → "version": "1.13.0"
# apk/android-app/package.json → "version": "1.13.0"
# build.gradle → versionName "1.13.0", versionCode 91

# 2. 更新版本文档
# docs/version/CHANGELOG.md → 追加 v1.13.0 条目
# docs/version/Progress.md → 追加 v1.13.0 条目

# 3. 提交
git add src/modules/11-game-init.js src/modules/12-challenges.js src/modules/05-difficulty.js
git add apk/package.json apk/android-app/package.json
git add docs/version/CHANGELOG.md docs/version/Progress.md
git commit -m "feat(v1.13.0): quality-aware spaced repetition, smooth difficulty curve, new challenge types"

# 4. 推送
push.bat
```

---

## CHANGELOG 条目（预写）

```markdown
## v1.13.0 (2026-02-xx)

### 学习系统
- 间隔复习算法增强：答错的词更频繁复现，秒答的词间隔拉长
- 新增多字母填空题型（长单词隐藏 2 个字母）
- 新增字母排序题型（打乱字母，选择正确单词）

### 游戏平衡
- 难度曲线平滑化：相邻难度档位之间线性插值，消除跳变
```

---

*编制日期：2026-02-16*
