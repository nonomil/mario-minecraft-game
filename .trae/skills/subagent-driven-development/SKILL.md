---
name: subagent-driven-development
description: 当在具有离散任务的当前会话中执行实施计划时使用 - 通过在每个任务之间进行代码审查的新鲜子代理提供快速迭代
---

# 子代理驱动开发

## 概述

子代理驱动开发通过为每个任务分配新鲜的、专用的子代理来执行实施计划。这种方法通过强制执行任务间的代码审查来确保高质量和任务隔离。

**核心原则：** 一个任务，一个代理，一个审查。

**开始时声明：** “我正在使用子代理驱动开发来逐个执行任务。”

**先决条件：** 必须已经在 worktree 中并拥有一个实施计划（由 brainstorming 和 writing-plans 技能创建）。

## 工作流程

对于计划中的每个任务：

### 1. 调度子代理

使用带有 `implementation` 类型的 Task 工具。

**提供：**
- 任务的具体说明（从计划中复制粘贴）
- 相关文件上下文
- 任何必要的环境变量或凭据

### 2. 子代理执行

子代理将：
1. 编写失败的测试（TDD）
2. 运行并确认失败
3. 编写最小实施
4. 运行并确认通过
5. 提交更改

### 3. 请求代码审查

任务完成后，**立即**使用 superpowers:requesting-code-review。

**审查者必须验证：**
- 规格符合性（它是否做了它该做的事？）
- 代码质量（它是否写得好？）
- 测试覆盖率（它是否经过测试？）

### 4. 根据反馈采取行动

- **通过：** 移动到下一个任务。
- **失败：** 在同一子代理（如果可能）或新代理中修复问题，直到审查通过。

## 示例循环

```
[任务 1：创建验证逻辑]

你：[调度子代理] “你的任务是实施 docs/plans/auth.md 中的任务 1...”
子代理：[工作，测试，提交] “任务 1 已完成。”

你：[调度代码审查子代理]
审查者：“发现问题：验证逻辑忽略了空字符串。”

你：[反馈给子代理] “修复对空字符串的处理。”
子代理：[修复，测试，提交] “已修复。”

你：[再次审查] -> 通过。
你：[开始任务 2]
```

## 优势

- **新鲜上下文：** 代理不会受到之前任务的残留干扰。
- **内置质量：** 每个步骤都经过独立审查。
- **可并行性：** 如果任务完全独立，可以同时运行多个。

## 危险信号

**切勿：**
- 跳过任务间的代码审查。
- 让子代理同时处理多个任务。
- 在未修复严重审查意见的情况下继续。
- 忽略子代理的测试失败。

## 集成

**调用者：**
- **writing-plans** - 作为推荐的执行选项之一。

**依赖：**
- **test-driven-development** - 子代理内部使用。
- **requesting-code-review** - 用于验证每个任务。
- **using-git-worktrees** - 工作应在 worktree 中发生。
